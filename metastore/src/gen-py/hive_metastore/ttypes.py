#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
import fb303.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Version:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'version', None, None, ), # 1
    (2, TType.STRING, 'comments', None, None, ), # 2
  )

  def __init__(self, d=None):
    self.version = None
    self.comments = None
    if isinstance(d, dict):
      if 'version' in d:
        self.version = d['version']
      if 'comments' in d:
        self.comments = d['comments']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.version = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.comments = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Version')
    if self.version != None:
      oprot.writeFieldBegin('version', TType.STRING, 1)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    if self.comments != None:
      oprot.writeFieldBegin('comments', TType.STRING, 2)
      oprot.writeString(self.comments)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FieldSchema:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'type', None, None, ), # 2
    (3, TType.STRING, 'comment', None, None, ), # 3
  )

  def __init__(self, d=None):
    self.name = None
    self.type = None
    self.comment = None
    if isinstance(d, dict):
      if 'name' in d:
        self.name = d['name']
      if 'type' in d:
        self.type = d['type']
      if 'comment' in d:
        self.comment = d['comment']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FieldSchema')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.STRING, 2)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.comment != None:
      oprot.writeFieldBegin('comment', TType.STRING, 3)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Type:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'type1', None, None, ), # 2
    (3, TType.STRING, 'type2', None, None, ), # 3
    (4, TType.LIST, 'fields', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 4
  )

  def __init__(self, d=None):
    self.name = None
    self.type1 = None
    self.type2 = None
    self.fields = None
    if isinstance(d, dict):
      if 'name' in d:
        self.name = d['name']
      if 'type1' in d:
        self.type1 = d['type1']
      if 'type2' in d:
        self.type2 = d['type2']
      if 'fields' in d:
        self.fields = d['fields']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.type1 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.type2 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fields = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = FieldSchema()
            _elem5.read(iprot)
            self.fields.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Type')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type1 != None:
      oprot.writeFieldBegin('type1', TType.STRING, 2)
      oprot.writeString(self.type1)
      oprot.writeFieldEnd()
    if self.type2 != None:
      oprot.writeFieldBegin('type2', TType.STRING, 3)
      oprot.writeString(self.type2)
      oprot.writeFieldEnd()
    if self.fields != None:
      oprot.writeFieldBegin('fields', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.fields))
      for iter6 in self.fields:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Database:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'description', None, None, ), # 2
  )

  def __init__(self, d=None):
    self.name = None
    self.description = None
    if isinstance(d, dict):
      if 'name' in d:
        self.name = d['name']
      if 'description' in d:
        self.description = d['description']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Database')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.description != None:
      oprot.writeFieldBegin('description', TType.STRING, 2)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SerDeInfo:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'serializationLib', None, None, ), # 2
    (3, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 3
  )

  def __init__(self, d=None):
    self.name = None
    self.serializationLib = None
    self.parameters = None
    if isinstance(d, dict):
      if 'name' in d:
        self.name = d['name']
      if 'serializationLib' in d:
        self.serializationLib = d['serializationLib']
      if 'parameters' in d:
        self.parameters = d['parameters']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.serializationLib = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin() 
          for _i11 in xrange(_size7):
            _key12 = iprot.readString();
            _val13 = iprot.readString();
            self.parameters[_key12] = _val13
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SerDeInfo')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.serializationLib != None:
      oprot.writeFieldBegin('serializationLib', TType.STRING, 2)
      oprot.writeString(self.serializationLib)
      oprot.writeFieldEnd()
    if self.parameters != None:
      oprot.writeFieldBegin('parameters', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter14,viter15 in self.parameters.items():
        oprot.writeString(kiter14)
        oprot.writeString(viter15)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Order:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'col', None, None, ), # 1
    (2, TType.I32, 'order', None, None, ), # 2
  )

  def __init__(self, d=None):
    self.col = None
    self.order = None
    if isinstance(d, dict):
      if 'col' in d:
        self.col = d['col']
      if 'order' in d:
        self.order = d['order']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.col = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.order = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Order')
    if self.col != None:
      oprot.writeFieldBegin('col', TType.STRING, 1)
      oprot.writeString(self.col)
      oprot.writeFieldEnd()
    if self.order != None:
      oprot.writeFieldBegin('order', TType.I32, 2)
      oprot.writeI32(self.order)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StorageDescriptor:

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'cols', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'location', None, None, ), # 2
    (3, TType.STRING, 'inputFormat', None, None, ), # 3
    (4, TType.STRING, 'outputFormat', None, None, ), # 4
    (5, TType.BOOL, 'compressed', None, None, ), # 5
    (6, TType.I32, 'numBuckets', None, None, ), # 6
    (7, TType.STRUCT, 'serdeInfo', (SerDeInfo, SerDeInfo.thrift_spec), None, ), # 7
    (8, TType.LIST, 'bucketCols', (TType.STRING,None), None, ), # 8
    (9, TType.LIST, 'sortCols', (TType.STRUCT,(Order, Order.thrift_spec)), None, ), # 9
    (10, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 10
  )

  def __init__(self, d=None):
    self.cols = None
    self.location = None
    self.inputFormat = None
    self.outputFormat = None
    self.compressed = None
    self.numBuckets = None
    self.serdeInfo = None
    self.bucketCols = None
    self.sortCols = None
    self.parameters = None
    if isinstance(d, dict):
      if 'cols' in d:
        self.cols = d['cols']
      if 'location' in d:
        self.location = d['location']
      if 'inputFormat' in d:
        self.inputFormat = d['inputFormat']
      if 'outputFormat' in d:
        self.outputFormat = d['outputFormat']
      if 'compressed' in d:
        self.compressed = d['compressed']
      if 'numBuckets' in d:
        self.numBuckets = d['numBuckets']
      if 'serdeInfo' in d:
        self.serdeInfo = d['serdeInfo']
      if 'bucketCols' in d:
        self.bucketCols = d['bucketCols']
      if 'sortCols' in d:
        self.sortCols = d['sortCols']
      if 'parameters' in d:
        self.parameters = d['parameters']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.cols = []
          (_etype19, _size16) = iprot.readListBegin()
          for _i20 in xrange(_size16):
            _elem21 = FieldSchema()
            _elem21.read(iprot)
            self.cols.append(_elem21)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.inputFormat = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.outputFormat = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.compressed = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.numBuckets = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.serdeInfo = SerDeInfo()
          self.serdeInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.bucketCols = []
          (_etype25, _size22) = iprot.readListBegin()
          for _i26 in xrange(_size22):
            _elem27 = iprot.readString();
            self.bucketCols.append(_elem27)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.sortCols = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = Order()
            _elem33.read(iprot)
            self.sortCols.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype35, _vtype36, _size34 ) = iprot.readMapBegin() 
          for _i38 in xrange(_size34):
            _key39 = iprot.readString();
            _val40 = iprot.readString();
            self.parameters[_key39] = _val40
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StorageDescriptor')
    if self.cols != None:
      oprot.writeFieldBegin('cols', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.cols))
      for iter41 in self.cols:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.location != None:
      oprot.writeFieldBegin('location', TType.STRING, 2)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.inputFormat != None:
      oprot.writeFieldBegin('inputFormat', TType.STRING, 3)
      oprot.writeString(self.inputFormat)
      oprot.writeFieldEnd()
    if self.outputFormat != None:
      oprot.writeFieldBegin('outputFormat', TType.STRING, 4)
      oprot.writeString(self.outputFormat)
      oprot.writeFieldEnd()
    if self.compressed != None:
      oprot.writeFieldBegin('compressed', TType.BOOL, 5)
      oprot.writeBool(self.compressed)
      oprot.writeFieldEnd()
    if self.numBuckets != None:
      oprot.writeFieldBegin('numBuckets', TType.I32, 6)
      oprot.writeI32(self.numBuckets)
      oprot.writeFieldEnd()
    if self.serdeInfo != None:
      oprot.writeFieldBegin('serdeInfo', TType.STRUCT, 7)
      self.serdeInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.bucketCols != None:
      oprot.writeFieldBegin('bucketCols', TType.LIST, 8)
      oprot.writeListBegin(TType.STRING, len(self.bucketCols))
      for iter42 in self.bucketCols:
        oprot.writeString(iter42)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sortCols != None:
      oprot.writeFieldBegin('sortCols', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.sortCols))
      for iter43 in self.sortCols:
        iter43.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parameters != None:
      oprot.writeFieldBegin('parameters', TType.MAP, 10)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter44,viter45 in self.parameters.items():
        oprot.writeString(kiter44)
        oprot.writeString(viter45)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Table:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'owner', None, None, ), # 3
    (4, TType.I32, 'createTime', None, None, ), # 4
    (5, TType.I32, 'lastAccessTime', None, None, ), # 5
    (6, TType.I32, 'retention', None, None, ), # 6
    (7, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 7
    (8, TType.LIST, 'partitionKeys', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 8
    (9, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 9
  )

  def __init__(self, d=None):
    self.tableName = None
    self.dbName = None
    self.owner = None
    self.createTime = None
    self.lastAccessTime = None
    self.retention = None
    self.sd = None
    self.partitionKeys = None
    self.parameters = None
    if isinstance(d, dict):
      if 'tableName' in d:
        self.tableName = d['tableName']
      if 'dbName' in d:
        self.dbName = d['dbName']
      if 'owner' in d:
        self.owner = d['owner']
      if 'createTime' in d:
        self.createTime = d['createTime']
      if 'lastAccessTime' in d:
        self.lastAccessTime = d['lastAccessTime']
      if 'retention' in d:
        self.retention = d['retention']
      if 'sd' in d:
        self.sd = d['sd']
      if 'partitionKeys' in d:
        self.partitionKeys = d['partitionKeys']
      if 'parameters' in d:
        self.parameters = d['parameters']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.owner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.createTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.retention = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.partitionKeys = []
          (_etype49, _size46) = iprot.readListBegin()
          for _i50 in xrange(_size46):
            _elem51 = FieldSchema()
            _elem51.read(iprot)
            self.partitionKeys.append(_elem51)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype53, _vtype54, _size52 ) = iprot.readMapBegin() 
          for _i56 in xrange(_size52):
            _key57 = iprot.readString();
            _val58 = iprot.readString();
            self.parameters[_key57] = _val58
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Table')
    if self.tableName != None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.dbName != None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.owner != None:
      oprot.writeFieldBegin('owner', TType.STRING, 3)
      oprot.writeString(self.owner)
      oprot.writeFieldEnd()
    if self.createTime != None:
      oprot.writeFieldBegin('createTime', TType.I32, 4)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime != None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 5)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.retention != None:
      oprot.writeFieldBegin('retention', TType.I32, 6)
      oprot.writeI32(self.retention)
      oprot.writeFieldEnd()
    if self.sd != None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 7)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.partitionKeys != None:
      oprot.writeFieldBegin('partitionKeys', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.partitionKeys))
      for iter59 in self.partitionKeys:
        iter59.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parameters != None:
      oprot.writeFieldBegin('parameters', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter60,viter61 in self.parameters.items():
        oprot.writeString(kiter60)
        oprot.writeString(viter61)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Partition:

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'values', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
    (3, TType.STRING, 'tableName', None, None, ), # 3
    (4, TType.I32, 'createTime', None, None, ), # 4
    (5, TType.I32, 'lastAccessTime', None, None, ), # 5
    (6, TType.STRUCT, 'sd', (StorageDescriptor, StorageDescriptor.thrift_spec), None, ), # 6
    (7, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 7
  )

  def __init__(self, d=None):
    self.values = None
    self.dbName = None
    self.tableName = None
    self.createTime = None
    self.lastAccessTime = None
    self.sd = None
    self.parameters = None
    if isinstance(d, dict):
      if 'values' in d:
        self.values = d['values']
      if 'dbName' in d:
        self.dbName = d['dbName']
      if 'tableName' in d:
        self.tableName = d['tableName']
      if 'createTime' in d:
        self.createTime = d['createTime']
      if 'lastAccessTime' in d:
        self.lastAccessTime = d['lastAccessTime']
      if 'sd' in d:
        self.sd = d['sd']
      if 'parameters' in d:
        self.parameters = d['parameters']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = iprot.readString();
            self.values.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.createTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.lastAccessTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.sd = StorageDescriptor()
          self.sd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype69, _vtype70, _size68 ) = iprot.readMapBegin() 
          for _i72 in xrange(_size68):
            _key73 = iprot.readString();
            _val74 = iprot.readString();
            self.parameters[_key73] = _val74
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Partition')
    if self.values != None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.values))
      for iter75 in self.values:
        oprot.writeString(iter75)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dbName != None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName != None:
      oprot.writeFieldBegin('tableName', TType.STRING, 3)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.createTime != None:
      oprot.writeFieldBegin('createTime', TType.I32, 4)
      oprot.writeI32(self.createTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime != None:
      oprot.writeFieldBegin('lastAccessTime', TType.I32, 5)
      oprot.writeI32(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.sd != None:
      oprot.writeFieldBegin('sd', TType.STRUCT, 6)
      self.sd.write(oprot)
      oprot.writeFieldEnd()
    if self.parameters != None:
      oprot.writeFieldBegin('parameters', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter76,viter77 in self.parameters.items():
        oprot.writeString(kiter76)
        oprot.writeString(viter77)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Index:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'indexName', None, None, ), # 1
    (2, TType.I32, 'indexType', None, None, ), # 2
    (3, TType.STRING, 'tableName', None, None, ), # 3
    (4, TType.STRING, 'dbName', None, None, ), # 4
    (5, TType.LIST, 'colNames', (TType.STRING,None), None, ), # 5
  )

  def __init__(self, d=None):
    self.indexName = None
    self.indexType = None
    self.tableName = None
    self.dbName = None
    self.colNames = None
    if isinstance(d, dict):
      if 'indexName' in d:
        self.indexName = d['indexName']
      if 'indexType' in d:
        self.indexType = d['indexType']
      if 'tableName' in d:
        self.tableName = d['tableName']
      if 'dbName' in d:
        self.dbName = d['dbName']
      if 'colNames' in d:
        self.colNames = d['colNames']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.indexName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.indexType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.colNames = []
          (_etype81, _size78) = iprot.readListBegin()
          for _i82 in xrange(_size78):
            _elem83 = iprot.readString();
            self.colNames.append(_elem83)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Index')
    if self.indexName != None:
      oprot.writeFieldBegin('indexName', TType.STRING, 1)
      oprot.writeString(self.indexName)
      oprot.writeFieldEnd()
    if self.indexType != None:
      oprot.writeFieldBegin('indexType', TType.I32, 2)
      oprot.writeI32(self.indexType)
      oprot.writeFieldEnd()
    if self.tableName != None:
      oprot.writeFieldBegin('tableName', TType.STRING, 3)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.dbName != None:
      oprot.writeFieldBegin('dbName', TType.STRING, 4)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.colNames != None:
      oprot.writeFieldBegin('colNames', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.colNames))
      for iter84 in self.colNames:
        oprot.writeString(iter84)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Schema:

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fieldSchemas', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 1
    (2, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, d=None):
    self.fieldSchemas = None
    self.properties = None
    if isinstance(d, dict):
      if 'fieldSchemas' in d:
        self.fieldSchemas = d['fieldSchemas']
      if 'properties' in d:
        self.properties = d['properties']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fieldSchemas = []
          (_etype88, _size85) = iprot.readListBegin()
          for _i89 in xrange(_size85):
            _elem90 = FieldSchema()
            _elem90.read(iprot)
            self.fieldSchemas.append(_elem90)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype92, _vtype93, _size91 ) = iprot.readMapBegin() 
          for _i95 in xrange(_size91):
            _key96 = iprot.readString();
            _val97 = iprot.readString();
            self.properties[_key96] = _val97
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Schema')
    if self.fieldSchemas != None:
      oprot.writeFieldBegin('fieldSchemas', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.fieldSchemas))
      for iter98 in self.fieldSchemas:
        iter98.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.properties != None:
      oprot.writeFieldBegin('properties', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter99,viter100 in self.properties.items():
        oprot.writeString(kiter99)
        oprot.writeString(viter100)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MetaException(Exception):

  thrift_spec = None
  def __init__(self, d=None):
    self.message = None
    if isinstance(d, dict):
      if 'message' in d:
        self.message = d['message']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MetaException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, -1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownTableException(Exception):

  thrift_spec = None
  def __init__(self, d=None):
    self.message = None
    if isinstance(d, dict):
      if 'message' in d:
        self.message = d['message']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownTableException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, -1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownDBException(Exception):

  thrift_spec = None
  def __init__(self, d=None):
    self.message = None
    if isinstance(d, dict):
      if 'message' in d:
        self.message = d['message']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownDBException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, -1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AlreadyExistsException(Exception):

  thrift_spec = None
  def __init__(self, d=None):
    self.message = None
    if isinstance(d, dict):
      if 'message' in d:
        self.message = d['message']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AlreadyExistsException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, -1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidObjectException(Exception):

  thrift_spec = None
  def __init__(self, d=None):
    self.message = None
    if isinstance(d, dict):
      if 'message' in d:
        self.message = d['message']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidObjectException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, -1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoSuchObjectException(Exception):

  thrift_spec = None
  def __init__(self, d=None):
    self.message = None
    if isinstance(d, dict):
      if 'message' in d:
        self.message = d['message']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoSuchObjectException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, -1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IndexAlreadyExistsException(Exception):

  thrift_spec = None
  def __init__(self, d=None):
    self.message = None
    if isinstance(d, dict):
      if 'message' in d:
        self.message = d['message']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IndexAlreadyExistsException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, -1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidOperationException(Exception):

  thrift_spec = None
  def __init__(self, d=None):
    self.message = None
    if isinstance(d, dict):
      if 'message' in d:
        self.message = d['message']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidOperationException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, -1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

