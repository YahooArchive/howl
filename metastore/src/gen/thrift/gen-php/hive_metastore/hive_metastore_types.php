<?php
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
include_once $GLOBALS['THRIFT_ROOT'].'/Thrift.php';

include_once $GLOBALS['THRIFT_ROOT'].'/packages/fb303/fb303_types.php';

class metastore_Version {
  static $_TSPEC;

  public $version = null;
  public $comments = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'version',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'comments',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['version'])) {
        $this->version = $vals['version'];
      }
      if (isset($vals['comments'])) {
        $this->comments = $vals['comments'];
      }
    }
  }

  public function getName() {
    return 'Version';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->version);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->comments);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Version');
    if ($this->version !== null) {
      $xfer += $output->writeFieldBegin('version', TType::STRING, 1);
      $xfer += $output->writeString($this->version);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->comments !== null) {
      $xfer += $output->writeFieldBegin('comments', TType::STRING, 2);
      $xfer += $output->writeString($this->comments);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_FieldSchema {
  static $_TSPEC;

  public $name = null;
  public $type = null;
  public $comment = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'type',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'comment',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['comment'])) {
        $this->comment = $vals['comment'];
      }
    }
  }

  public function getName() {
    return 'FieldSchema';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->comment);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FieldSchema');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::STRING, 2);
      $xfer += $output->writeString($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->comment !== null) {
      $xfer += $output->writeFieldBegin('comment', TType::STRING, 3);
      $xfer += $output->writeString($this->comment);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_Type {
  static $_TSPEC;

  public $name = null;
  public $type1 = null;
  public $type2 = null;
  public $fields = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'type1',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'type2',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'fields',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'metastore_FieldSchema',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['type1'])) {
        $this->type1 = $vals['type1'];
      }
      if (isset($vals['type2'])) {
        $this->type2 = $vals['type2'];
      }
      if (isset($vals['fields'])) {
        $this->fields = $vals['fields'];
      }
    }
  }

  public function getName() {
    return 'Type';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->type1);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->type2);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->fields = array();
            $_size0 = 0;
            $_etype3 = 0;
            $xfer += $input->readListBegin($_etype3, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $elem5 = new metastore_FieldSchema();
              $xfer += $elem5->read($input);
              $this->fields []= $elem5;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Type');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type1 !== null) {
      $xfer += $output->writeFieldBegin('type1', TType::STRING, 2);
      $xfer += $output->writeString($this->type1);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type2 !== null) {
      $xfer += $output->writeFieldBegin('type2', TType::STRING, 3);
      $xfer += $output->writeString($this->type2);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fields !== null) {
      if (!is_array($this->fields)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fields', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRUCT, count($this->fields));
        {
          foreach ($this->fields as $iter6)
          {
            $xfer += $iter6->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_Database {
  static $_TSPEC;

  public $name = null;
  public $description = null;
  public $locationUri = null;
  public $parameters = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'locationUri',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'parameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
      if (isset($vals['locationUri'])) {
        $this->locationUri = $vals['locationUri'];
      }
      if (isset($vals['parameters'])) {
        $this->parameters = $vals['parameters'];
      }
    }
  }

  public function getName() {
    return 'Database';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->locationUri);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->parameters = array();
            $_size7 = 0;
            $_ktype8 = 0;
            $_vtype9 = 0;
            $xfer += $input->readMapBegin($_ktype8, $_vtype9, $_size7);
            for ($_i11 = 0; $_i11 < $_size7; ++$_i11)
            {
              $key12 = '';
              $val13 = '';
              $xfer += $input->readString($key12);
              $xfer += $input->readString($val13);
              $this->parameters[$key12] = $val13;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Database');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 2);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->locationUri !== null) {
      $xfer += $output->writeFieldBegin('locationUri', TType::STRING, 3);
      $xfer += $output->writeString($this->locationUri);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameters !== null) {
      if (!is_array($this->parameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parameters', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->parameters));
        {
          foreach ($this->parameters as $kiter14 => $viter15)
          {
            $xfer += $output->writeString($kiter14);
            $xfer += $output->writeString($viter15);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_SerDeInfo {
  static $_TSPEC;

  public $name = null;
  public $serializationLib = null;
  public $parameters = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'serializationLib',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'parameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['serializationLib'])) {
        $this->serializationLib = $vals['serializationLib'];
      }
      if (isset($vals['parameters'])) {
        $this->parameters = $vals['parameters'];
      }
    }
  }

  public function getName() {
    return 'SerDeInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->serializationLib);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->parameters = array();
            $_size16 = 0;
            $_ktype17 = 0;
            $_vtype18 = 0;
            $xfer += $input->readMapBegin($_ktype17, $_vtype18, $_size16);
            for ($_i20 = 0; $_i20 < $_size16; ++$_i20)
            {
              $key21 = '';
              $val22 = '';
              $xfer += $input->readString($key21);
              $xfer += $input->readString($val22);
              $this->parameters[$key21] = $val22;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SerDeInfo');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->serializationLib !== null) {
      $xfer += $output->writeFieldBegin('serializationLib', TType::STRING, 2);
      $xfer += $output->writeString($this->serializationLib);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameters !== null) {
      if (!is_array($this->parameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parameters', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->parameters));
        {
          foreach ($this->parameters as $kiter23 => $viter24)
          {
            $xfer += $output->writeString($kiter23);
            $xfer += $output->writeString($viter24);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_Order {
  static $_TSPEC;

  public $col = null;
  public $order = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'col',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'order',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['col'])) {
        $this->col = $vals['col'];
      }
      if (isset($vals['order'])) {
        $this->order = $vals['order'];
      }
    }
  }

  public function getName() {
    return 'Order';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->col);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->order);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Order');
    if ($this->col !== null) {
      $xfer += $output->writeFieldBegin('col', TType::STRING, 1);
      $xfer += $output->writeString($this->col);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->order !== null) {
      $xfer += $output->writeFieldBegin('order', TType::I32, 2);
      $xfer += $output->writeI32($this->order);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_StorageDescriptor {
  static $_TSPEC;

  public $cols = null;
  public $location = null;
  public $inputFormat = null;
  public $outputFormat = null;
  public $compressed = null;
  public $numBuckets = null;
  public $serdeInfo = null;
  public $bucketCols = null;
  public $sortCols = null;
  public $parameters = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cols',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'metastore_FieldSchema',
            ),
          ),
        2 => array(
          'var' => 'location',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'inputFormat',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'outputFormat',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'compressed',
          'type' => TType::BOOL,
          ),
        6 => array(
          'var' => 'numBuckets',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'serdeInfo',
          'type' => TType::STRUCT,
          'class' => 'metastore_SerDeInfo',
          ),
        8 => array(
          'var' => 'bucketCols',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        9 => array(
          'var' => 'sortCols',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'metastore_Order',
            ),
          ),
        10 => array(
          'var' => 'parameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['cols'])) {
        $this->cols = $vals['cols'];
      }
      if (isset($vals['location'])) {
        $this->location = $vals['location'];
      }
      if (isset($vals['inputFormat'])) {
        $this->inputFormat = $vals['inputFormat'];
      }
      if (isset($vals['outputFormat'])) {
        $this->outputFormat = $vals['outputFormat'];
      }
      if (isset($vals['compressed'])) {
        $this->compressed = $vals['compressed'];
      }
      if (isset($vals['numBuckets'])) {
        $this->numBuckets = $vals['numBuckets'];
      }
      if (isset($vals['serdeInfo'])) {
        $this->serdeInfo = $vals['serdeInfo'];
      }
      if (isset($vals['bucketCols'])) {
        $this->bucketCols = $vals['bucketCols'];
      }
      if (isset($vals['sortCols'])) {
        $this->sortCols = $vals['sortCols'];
      }
      if (isset($vals['parameters'])) {
        $this->parameters = $vals['parameters'];
      }
    }
  }

  public function getName() {
    return 'StorageDescriptor';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->cols = array();
            $_size25 = 0;
            $_etype28 = 0;
            $xfer += $input->readListBegin($_etype28, $_size25);
            for ($_i29 = 0; $_i29 < $_size25; ++$_i29)
            {
              $elem30 = null;
              $elem30 = new metastore_FieldSchema();
              $xfer += $elem30->read($input);
              $this->cols []= $elem30;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->location);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->inputFormat);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->outputFormat);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->compressed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->numBuckets);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->serdeInfo = new metastore_SerDeInfo();
            $xfer += $this->serdeInfo->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::LST) {
            $this->bucketCols = array();
            $_size31 = 0;
            $_etype34 = 0;
            $xfer += $input->readListBegin($_etype34, $_size31);
            for ($_i35 = 0; $_i35 < $_size31; ++$_i35)
            {
              $elem36 = null;
              $xfer += $input->readString($elem36);
              $this->bucketCols []= $elem36;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::LST) {
            $this->sortCols = array();
            $_size37 = 0;
            $_etype40 = 0;
            $xfer += $input->readListBegin($_etype40, $_size37);
            for ($_i41 = 0; $_i41 < $_size37; ++$_i41)
            {
              $elem42 = null;
              $elem42 = new metastore_Order();
              $xfer += $elem42->read($input);
              $this->sortCols []= $elem42;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::MAP) {
            $this->parameters = array();
            $_size43 = 0;
            $_ktype44 = 0;
            $_vtype45 = 0;
            $xfer += $input->readMapBegin($_ktype44, $_vtype45, $_size43);
            for ($_i47 = 0; $_i47 < $_size43; ++$_i47)
            {
              $key48 = '';
              $val49 = '';
              $xfer += $input->readString($key48);
              $xfer += $input->readString($val49);
              $this->parameters[$key48] = $val49;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('StorageDescriptor');
    if ($this->cols !== null) {
      if (!is_array($this->cols)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('cols', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->cols));
        {
          foreach ($this->cols as $iter50)
          {
            $xfer += $iter50->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->location !== null) {
      $xfer += $output->writeFieldBegin('location', TType::STRING, 2);
      $xfer += $output->writeString($this->location);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->inputFormat !== null) {
      $xfer += $output->writeFieldBegin('inputFormat', TType::STRING, 3);
      $xfer += $output->writeString($this->inputFormat);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->outputFormat !== null) {
      $xfer += $output->writeFieldBegin('outputFormat', TType::STRING, 4);
      $xfer += $output->writeString($this->outputFormat);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->compressed !== null) {
      $xfer += $output->writeFieldBegin('compressed', TType::BOOL, 5);
      $xfer += $output->writeBool($this->compressed);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numBuckets !== null) {
      $xfer += $output->writeFieldBegin('numBuckets', TType::I32, 6);
      $xfer += $output->writeI32($this->numBuckets);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->serdeInfo !== null) {
      if (!is_object($this->serdeInfo)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('serdeInfo', TType::STRUCT, 7);
      $xfer += $this->serdeInfo->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bucketCols !== null) {
      if (!is_array($this->bucketCols)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('bucketCols', TType::LST, 8);
      {
        $output->writeListBegin(TType::STRING, count($this->bucketCols));
        {
          foreach ($this->bucketCols as $iter51)
          {
            $xfer += $output->writeString($iter51);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sortCols !== null) {
      if (!is_array($this->sortCols)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sortCols', TType::LST, 9);
      {
        $output->writeListBegin(TType::STRUCT, count($this->sortCols));
        {
          foreach ($this->sortCols as $iter52)
          {
            $xfer += $iter52->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameters !== null) {
      if (!is_array($this->parameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parameters', TType::MAP, 10);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->parameters));
        {
          foreach ($this->parameters as $kiter53 => $viter54)
          {
            $xfer += $output->writeString($kiter53);
            $xfer += $output->writeString($viter54);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_Table {
  static $_TSPEC;

  public $tableName = null;
  public $dbName = null;
  public $owner = null;
  public $createTime = null;
  public $lastAccessTime = null;
  public $retention = null;
  public $sd = null;
  public $partitionKeys = null;
  public $parameters = null;
  public $viewOriginalText = null;
  public $viewExpandedText = null;
  public $tableType = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'owner',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'createTime',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'lastAccessTime',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'retention',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'sd',
          'type' => TType::STRUCT,
          'class' => 'metastore_StorageDescriptor',
          ),
        8 => array(
          'var' => 'partitionKeys',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'metastore_FieldSchema',
            ),
          ),
        9 => array(
          'var' => 'parameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        10 => array(
          'var' => 'viewOriginalText',
          'type' => TType::STRING,
          ),
        11 => array(
          'var' => 'viewExpandedText',
          'type' => TType::STRING,
          ),
        12 => array(
          'var' => 'tableType',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['owner'])) {
        $this->owner = $vals['owner'];
      }
      if (isset($vals['createTime'])) {
        $this->createTime = $vals['createTime'];
      }
      if (isset($vals['lastAccessTime'])) {
        $this->lastAccessTime = $vals['lastAccessTime'];
      }
      if (isset($vals['retention'])) {
        $this->retention = $vals['retention'];
      }
      if (isset($vals['sd'])) {
        $this->sd = $vals['sd'];
      }
      if (isset($vals['partitionKeys'])) {
        $this->partitionKeys = $vals['partitionKeys'];
      }
      if (isset($vals['parameters'])) {
        $this->parameters = $vals['parameters'];
      }
      if (isset($vals['viewOriginalText'])) {
        $this->viewOriginalText = $vals['viewOriginalText'];
      }
      if (isset($vals['viewExpandedText'])) {
        $this->viewExpandedText = $vals['viewExpandedText'];
      }
      if (isset($vals['tableType'])) {
        $this->tableType = $vals['tableType'];
      }
    }
  }

  public function getName() {
    return 'Table';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->owner);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->createTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->lastAccessTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->retention);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->sd = new metastore_StorageDescriptor();
            $xfer += $this->sd->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::LST) {
            $this->partitionKeys = array();
            $_size55 = 0;
            $_etype58 = 0;
            $xfer += $input->readListBegin($_etype58, $_size55);
            for ($_i59 = 0; $_i59 < $_size55; ++$_i59)
            {
              $elem60 = null;
              $elem60 = new metastore_FieldSchema();
              $xfer += $elem60->read($input);
              $this->partitionKeys []= $elem60;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::MAP) {
            $this->parameters = array();
            $_size61 = 0;
            $_ktype62 = 0;
            $_vtype63 = 0;
            $xfer += $input->readMapBegin($_ktype62, $_vtype63, $_size61);
            for ($_i65 = 0; $_i65 < $_size61; ++$_i65)
            {
              $key66 = '';
              $val67 = '';
              $xfer += $input->readString($key66);
              $xfer += $input->readString($val67);
              $this->parameters[$key66] = $val67;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->viewOriginalText);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->viewExpandedText);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Table');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->owner !== null) {
      $xfer += $output->writeFieldBegin('owner', TType::STRING, 3);
      $xfer += $output->writeString($this->owner);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->createTime !== null) {
      $xfer += $output->writeFieldBegin('createTime', TType::I32, 4);
      $xfer += $output->writeI32($this->createTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lastAccessTime !== null) {
      $xfer += $output->writeFieldBegin('lastAccessTime', TType::I32, 5);
      $xfer += $output->writeI32($this->lastAccessTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->retention !== null) {
      $xfer += $output->writeFieldBegin('retention', TType::I32, 6);
      $xfer += $output->writeI32($this->retention);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sd !== null) {
      if (!is_object($this->sd)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sd', TType::STRUCT, 7);
      $xfer += $this->sd->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partitionKeys !== null) {
      if (!is_array($this->partitionKeys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partitionKeys', TType::LST, 8);
      {
        $output->writeListBegin(TType::STRUCT, count($this->partitionKeys));
        {
          foreach ($this->partitionKeys as $iter68)
          {
            $xfer += $iter68->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameters !== null) {
      if (!is_array($this->parameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parameters', TType::MAP, 9);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->parameters));
        {
          foreach ($this->parameters as $kiter69 => $viter70)
          {
            $xfer += $output->writeString($kiter69);
            $xfer += $output->writeString($viter70);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->viewOriginalText !== null) {
      $xfer += $output->writeFieldBegin('viewOriginalText', TType::STRING, 10);
      $xfer += $output->writeString($this->viewOriginalText);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->viewExpandedText !== null) {
      $xfer += $output->writeFieldBegin('viewExpandedText', TType::STRING, 11);
      $xfer += $output->writeString($this->viewExpandedText);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableType !== null) {
      $xfer += $output->writeFieldBegin('tableType', TType::STRING, 12);
      $xfer += $output->writeString($this->tableType);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_Partition {
  static $_TSPEC;

  public $values = null;
  public $dbName = null;
  public $tableName = null;
  public $createTime = null;
  public $lastAccessTime = null;
  public $sd = null;
  public $parameters = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'createTime',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'lastAccessTime',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'sd',
          'type' => TType::STRUCT,
          'class' => 'metastore_StorageDescriptor',
          ),
        7 => array(
          'var' => 'parameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['createTime'])) {
        $this->createTime = $vals['createTime'];
      }
      if (isset($vals['lastAccessTime'])) {
        $this->lastAccessTime = $vals['lastAccessTime'];
      }
      if (isset($vals['sd'])) {
        $this->sd = $vals['sd'];
      }
      if (isset($vals['parameters'])) {
        $this->parameters = $vals['parameters'];
      }
    }
  }

  public function getName() {
    return 'Partition';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size71 = 0;
            $_etype74 = 0;
            $xfer += $input->readListBegin($_etype74, $_size71);
            for ($_i75 = 0; $_i75 < $_size71; ++$_i75)
            {
              $elem76 = null;
              $xfer += $input->readString($elem76);
              $this->values []= $elem76;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->createTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->lastAccessTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->sd = new metastore_StorageDescriptor();
            $xfer += $this->sd->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::MAP) {
            $this->parameters = array();
            $_size77 = 0;
            $_ktype78 = 0;
            $_vtype79 = 0;
            $xfer += $input->readMapBegin($_ktype78, $_vtype79, $_size77);
            for ($_i81 = 0; $_i81 < $_size77; ++$_i81)
            {
              $key82 = '';
              $val83 = '';
              $xfer += $input->readString($key82);
              $xfer += $input->readString($val83);
              $this->parameters[$key82] = $val83;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Partition');
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->values));
        {
          foreach ($this->values as $iter84)
          {
            $xfer += $output->writeString($iter84);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 3);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->createTime !== null) {
      $xfer += $output->writeFieldBegin('createTime', TType::I32, 4);
      $xfer += $output->writeI32($this->createTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lastAccessTime !== null) {
      $xfer += $output->writeFieldBegin('lastAccessTime', TType::I32, 5);
      $xfer += $output->writeI32($this->lastAccessTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sd !== null) {
      if (!is_object($this->sd)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sd', TType::STRUCT, 6);
      $xfer += $this->sd->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameters !== null) {
      if (!is_array($this->parameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parameters', TType::MAP, 7);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->parameters));
        {
          foreach ($this->parameters as $kiter85 => $viter86)
          {
            $xfer += $output->writeString($kiter85);
            $xfer += $output->writeString($viter86);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_Index {
  static $_TSPEC;

  public $indexName = null;
  public $indexHandlerClass = null;
  public $dbName = null;
  public $origTableName = null;
  public $createTime = null;
  public $lastAccessTime = null;
  public $indexTableName = null;
  public $sd = null;
  public $parameters = null;
  public $deferredRebuild = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'indexName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'indexHandlerClass',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'origTableName',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'createTime',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'lastAccessTime',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'indexTableName',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'sd',
          'type' => TType::STRUCT,
          'class' => 'metastore_StorageDescriptor',
          ),
        9 => array(
          'var' => 'parameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        10 => array(
          'var' => 'deferredRebuild',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['indexName'])) {
        $this->indexName = $vals['indexName'];
      }
      if (isset($vals['indexHandlerClass'])) {
        $this->indexHandlerClass = $vals['indexHandlerClass'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['origTableName'])) {
        $this->origTableName = $vals['origTableName'];
      }
      if (isset($vals['createTime'])) {
        $this->createTime = $vals['createTime'];
      }
      if (isset($vals['lastAccessTime'])) {
        $this->lastAccessTime = $vals['lastAccessTime'];
      }
      if (isset($vals['indexTableName'])) {
        $this->indexTableName = $vals['indexTableName'];
      }
      if (isset($vals['sd'])) {
        $this->sd = $vals['sd'];
      }
      if (isset($vals['parameters'])) {
        $this->parameters = $vals['parameters'];
      }
      if (isset($vals['deferredRebuild'])) {
        $this->deferredRebuild = $vals['deferredRebuild'];
      }
    }
  }

  public function getName() {
    return 'Index';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->indexName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->indexHandlerClass);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->origTableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->createTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->lastAccessTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->indexTableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRUCT) {
            $this->sd = new metastore_StorageDescriptor();
            $xfer += $this->sd->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::MAP) {
            $this->parameters = array();
            $_size87 = 0;
            $_ktype88 = 0;
            $_vtype89 = 0;
            $xfer += $input->readMapBegin($_ktype88, $_vtype89, $_size87);
            for ($_i91 = 0; $_i91 < $_size87; ++$_i91)
            {
              $key92 = '';
              $val93 = '';
              $xfer += $input->readString($key92);
              $xfer += $input->readString($val93);
              $this->parameters[$key92] = $val93;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deferredRebuild);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Index');
    if ($this->indexName !== null) {
      $xfer += $output->writeFieldBegin('indexName', TType::STRING, 1);
      $xfer += $output->writeString($this->indexName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->indexHandlerClass !== null) {
      $xfer += $output->writeFieldBegin('indexHandlerClass', TType::STRING, 2);
      $xfer += $output->writeString($this->indexHandlerClass);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 3);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->origTableName !== null) {
      $xfer += $output->writeFieldBegin('origTableName', TType::STRING, 4);
      $xfer += $output->writeString($this->origTableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->createTime !== null) {
      $xfer += $output->writeFieldBegin('createTime', TType::I32, 5);
      $xfer += $output->writeI32($this->createTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lastAccessTime !== null) {
      $xfer += $output->writeFieldBegin('lastAccessTime', TType::I32, 6);
      $xfer += $output->writeI32($this->lastAccessTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->indexTableName !== null) {
      $xfer += $output->writeFieldBegin('indexTableName', TType::STRING, 7);
      $xfer += $output->writeString($this->indexTableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sd !== null) {
      if (!is_object($this->sd)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sd', TType::STRUCT, 8);
      $xfer += $this->sd->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameters !== null) {
      if (!is_array($this->parameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parameters', TType::MAP, 9);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->parameters));
        {
          foreach ($this->parameters as $kiter94 => $viter95)
          {
            $xfer += $output->writeString($kiter94);
            $xfer += $output->writeString($viter95);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deferredRebuild !== null) {
      $xfer += $output->writeFieldBegin('deferredRebuild', TType::BOOL, 10);
      $xfer += $output->writeBool($this->deferredRebuild);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_Schema {
  static $_TSPEC;

  public $fieldSchemas = null;
  public $properties = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fieldSchemas',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'metastore_FieldSchema',
            ),
          ),
        2 => array(
          'var' => 'properties',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fieldSchemas'])) {
        $this->fieldSchemas = $vals['fieldSchemas'];
      }
      if (isset($vals['properties'])) {
        $this->properties = $vals['properties'];
      }
    }
  }

  public function getName() {
    return 'Schema';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->fieldSchemas = array();
            $_size96 = 0;
            $_etype99 = 0;
            $xfer += $input->readListBegin($_etype99, $_size96);
            for ($_i100 = 0; $_i100 < $_size96; ++$_i100)
            {
              $elem101 = null;
              $elem101 = new metastore_FieldSchema();
              $xfer += $elem101->read($input);
              $this->fieldSchemas []= $elem101;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->properties = array();
            $_size102 = 0;
            $_ktype103 = 0;
            $_vtype104 = 0;
            $xfer += $input->readMapBegin($_ktype103, $_vtype104, $_size102);
            for ($_i106 = 0; $_i106 < $_size102; ++$_i106)
            {
              $key107 = '';
              $val108 = '';
              $xfer += $input->readString($key107);
              $xfer += $input->readString($val108);
              $this->properties[$key107] = $val108;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Schema');
    if ($this->fieldSchemas !== null) {
      if (!is_array($this->fieldSchemas)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fieldSchemas', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->fieldSchemas));
        {
          foreach ($this->fieldSchemas as $iter109)
          {
            $xfer += $iter109->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->properties !== null) {
      if (!is_array($this->properties)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('properties', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->properties));
        {
          foreach ($this->properties as $kiter110 => $viter111)
          {
            $xfer += $output->writeString($kiter110);
            $xfer += $output->writeString($viter111);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_MetaException extends TException {
  static $_TSPEC;

  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'MetaException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MetaException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_UnknownTableException extends TException {
  static $_TSPEC;

  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'UnknownTableException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('UnknownTableException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_UnknownDBException extends TException {
  static $_TSPEC;

  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'UnknownDBException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('UnknownDBException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_AlreadyExistsException extends TException {
  static $_TSPEC;

  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'AlreadyExistsException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AlreadyExistsException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_InvalidObjectException extends TException {
  static $_TSPEC;

  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'InvalidObjectException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('InvalidObjectException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_NoSuchObjectException extends TException {
  static $_TSPEC;

  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'NoSuchObjectException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NoSuchObjectException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_IndexAlreadyExistsException extends TException {
  static $_TSPEC;

  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'IndexAlreadyExistsException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('IndexAlreadyExistsException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_InvalidOperationException extends TException {
  static $_TSPEC;

  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'InvalidOperationException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('InvalidOperationException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class metastore_ConfigValSecurityException extends TException {
  static $_TSPEC;

  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'ConfigValSecurityException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ConfigValSecurityException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

?>
