/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.apache.hadoop.hive.metastore.api;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.async.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.transport.*;
import org.apache.thrift.protocol.*;

public class ThriftHiveMetastore {

  /**
   * This interface is live.
   */
  public interface Iface extends com.facebook.fb303.FacebookService.Iface {

    public void create_database(Database database) throws AlreadyExistsException, InvalidObjectException, MetaException, TException;

    public Database get_database(String name) throws NoSuchObjectException, MetaException, TException;

    public void drop_database(String name, boolean deleteData) throws NoSuchObjectException, InvalidOperationException, MetaException, TException;

    public List<String> get_databases(String pattern) throws MetaException, TException;

    public List<String> get_all_databases() throws MetaException, TException;

    public Type get_type(String name) throws MetaException, NoSuchObjectException, TException;

    public boolean create_type(Type type) throws AlreadyExistsException, InvalidObjectException, MetaException, TException;

    public boolean drop_type(String type) throws MetaException, NoSuchObjectException, TException;

    public Map<String,Type> get_type_all(String name) throws MetaException, TException;

    public List<FieldSchema> get_fields(String db_name, String table_name) throws MetaException, UnknownTableException, UnknownDBException, TException;

    public List<FieldSchema> get_schema(String db_name, String table_name) throws MetaException, UnknownTableException, UnknownDBException, TException;

    public void create_table(Table tbl) throws AlreadyExistsException, InvalidObjectException, MetaException, NoSuchObjectException, TException;

    public void drop_table(String dbname, String name, boolean deleteData) throws NoSuchObjectException, MetaException, TException;

    public List<String> get_tables(String db_name, String pattern) throws MetaException, TException;

    public List<String> get_all_tables(String db_name) throws MetaException, TException;

    public Table get_table(String dbname, String tbl_name) throws MetaException, NoSuchObjectException, TException;

    public void alter_table(String dbname, String tbl_name, Table new_tbl) throws InvalidOperationException, MetaException, TException;

    public Partition add_partition(Partition new_part) throws InvalidObjectException, AlreadyExistsException, MetaException, TException;

    public Partition append_partition(String db_name, String tbl_name, List<String> part_vals) throws InvalidObjectException, AlreadyExistsException, MetaException, TException;

    public Partition append_partition_by_name(String db_name, String tbl_name, String part_name) throws InvalidObjectException, AlreadyExistsException, MetaException, TException;

    public boolean drop_partition(String db_name, String tbl_name, List<String> part_vals, boolean deleteData) throws NoSuchObjectException, MetaException, TException;

    public boolean drop_partition_by_name(String db_name, String tbl_name, String part_name, boolean deleteData) throws NoSuchObjectException, MetaException, TException;

    public Partition get_partition(String db_name, String tbl_name, List<String> part_vals) throws MetaException, NoSuchObjectException, TException;

    public Partition get_partition_by_name(String db_name, String tbl_name, String part_name) throws MetaException, NoSuchObjectException, TException;

    public List<Partition> get_partitions(String db_name, String tbl_name, short max_parts) throws NoSuchObjectException, MetaException, TException;

    public List<String> get_partition_names(String db_name, String tbl_name, short max_parts) throws MetaException, TException;

    public List<Partition> get_partitions_ps(String db_name, String tbl_name, List<String> part_vals, short max_parts) throws MetaException, TException;

    public List<String> get_partition_names_ps(String db_name, String tbl_name, List<String> part_vals, short max_parts) throws MetaException, TException;

    public List<Partition> get_partitions_by_filter(String db_name, String tbl_name, String filter, short max_parts) throws MetaException, NoSuchObjectException, TException;

    public void alter_partition(String db_name, String tbl_name, Partition new_part) throws InvalidOperationException, MetaException, TException;

    public String get_config_value(String name, String defaultValue) throws ConfigValSecurityException, TException;

    public List<String> partition_name_to_vals(String part_name) throws MetaException, TException;

    public Map<String,String> partition_name_to_spec(String part_name) throws MetaException, TException;

    public Index add_index(Index new_index, Table index_table) throws InvalidObjectException, AlreadyExistsException, MetaException, TException;

    public void alter_index(String dbname, String base_tbl_name, String idx_name, Index new_idx) throws InvalidOperationException, MetaException, TException;

    public boolean drop_index_by_name(String db_name, String tbl_name, String index_name, boolean deleteData) throws NoSuchObjectException, MetaException, TException;

    public Index get_index_by_name(String db_name, String tbl_name, String index_name) throws MetaException, NoSuchObjectException, TException;

    public List<Index> get_indexes(String db_name, String tbl_name, short max_indexes) throws NoSuchObjectException, MetaException, TException;

    public List<String> get_index_names(String db_name, String tbl_name, short max_indexes) throws MetaException, TException;

  }

  public interface AsyncIface extends com.facebook.fb303.FacebookService .AsyncIface {

    public void create_database(Database database, AsyncMethodCallback<AsyncClient.create_database_call> resultHandler) throws TException;

    public void get_database(String name, AsyncMethodCallback<AsyncClient.get_database_call> resultHandler) throws TException;

    public void drop_database(String name, boolean deleteData, AsyncMethodCallback<AsyncClient.drop_database_call> resultHandler) throws TException;

    public void get_databases(String pattern, AsyncMethodCallback<AsyncClient.get_databases_call> resultHandler) throws TException;

    public void get_all_databases(AsyncMethodCallback<AsyncClient.get_all_databases_call> resultHandler) throws TException;

    public void get_type(String name, AsyncMethodCallback<AsyncClient.get_type_call> resultHandler) throws TException;

    public void create_type(Type type, AsyncMethodCallback<AsyncClient.create_type_call> resultHandler) throws TException;

    public void drop_type(String type, AsyncMethodCallback<AsyncClient.drop_type_call> resultHandler) throws TException;

    public void get_type_all(String name, AsyncMethodCallback<AsyncClient.get_type_all_call> resultHandler) throws TException;

    public void get_fields(String db_name, String table_name, AsyncMethodCallback<AsyncClient.get_fields_call> resultHandler) throws TException;

    public void get_schema(String db_name, String table_name, AsyncMethodCallback<AsyncClient.get_schema_call> resultHandler) throws TException;

    public void create_table(Table tbl, AsyncMethodCallback<AsyncClient.create_table_call> resultHandler) throws TException;

    public void drop_table(String dbname, String name, boolean deleteData, AsyncMethodCallback<AsyncClient.drop_table_call> resultHandler) throws TException;

    public void get_tables(String db_name, String pattern, AsyncMethodCallback<AsyncClient.get_tables_call> resultHandler) throws TException;

    public void get_all_tables(String db_name, AsyncMethodCallback<AsyncClient.get_all_tables_call> resultHandler) throws TException;

    public void get_table(String dbname, String tbl_name, AsyncMethodCallback<AsyncClient.get_table_call> resultHandler) throws TException;

    public void alter_table(String dbname, String tbl_name, Table new_tbl, AsyncMethodCallback<AsyncClient.alter_table_call> resultHandler) throws TException;

    public void add_partition(Partition new_part, AsyncMethodCallback<AsyncClient.add_partition_call> resultHandler) throws TException;

    public void append_partition(String db_name, String tbl_name, List<String> part_vals, AsyncMethodCallback<AsyncClient.append_partition_call> resultHandler) throws TException;

    public void append_partition_by_name(String db_name, String tbl_name, String part_name, AsyncMethodCallback<AsyncClient.append_partition_by_name_call> resultHandler) throws TException;

    public void drop_partition(String db_name, String tbl_name, List<String> part_vals, boolean deleteData, AsyncMethodCallback<AsyncClient.drop_partition_call> resultHandler) throws TException;

    public void drop_partition_by_name(String db_name, String tbl_name, String part_name, boolean deleteData, AsyncMethodCallback<AsyncClient.drop_partition_by_name_call> resultHandler) throws TException;

    public void get_partition(String db_name, String tbl_name, List<String> part_vals, AsyncMethodCallback<AsyncClient.get_partition_call> resultHandler) throws TException;

    public void get_partition_by_name(String db_name, String tbl_name, String part_name, AsyncMethodCallback<AsyncClient.get_partition_by_name_call> resultHandler) throws TException;

    public void get_partitions(String db_name, String tbl_name, short max_parts, AsyncMethodCallback<AsyncClient.get_partitions_call> resultHandler) throws TException;

    public void get_partition_names(String db_name, String tbl_name, short max_parts, AsyncMethodCallback<AsyncClient.get_partition_names_call> resultHandler) throws TException;

    public void get_partitions_ps(String db_name, String tbl_name, List<String> part_vals, short max_parts, AsyncMethodCallback<AsyncClient.get_partitions_ps_call> resultHandler) throws TException;

    public void get_partition_names_ps(String db_name, String tbl_name, List<String> part_vals, short max_parts, AsyncMethodCallback<AsyncClient.get_partition_names_ps_call> resultHandler) throws TException;

    public void get_partitions_by_filter(String db_name, String tbl_name, String filter, short max_parts, AsyncMethodCallback<AsyncClient.get_partitions_by_filter_call> resultHandler) throws TException;

    public void alter_partition(String db_name, String tbl_name, Partition new_part, AsyncMethodCallback<AsyncClient.alter_partition_call> resultHandler) throws TException;

    public void get_config_value(String name, String defaultValue, AsyncMethodCallback<AsyncClient.get_config_value_call> resultHandler) throws TException;

    public void partition_name_to_vals(String part_name, AsyncMethodCallback<AsyncClient.partition_name_to_vals_call> resultHandler) throws TException;

    public void partition_name_to_spec(String part_name, AsyncMethodCallback<AsyncClient.partition_name_to_spec_call> resultHandler) throws TException;

    public void add_index(Index new_index, Table index_table, AsyncMethodCallback<AsyncClient.add_index_call> resultHandler) throws TException;

    public void alter_index(String dbname, String base_tbl_name, String idx_name, Index new_idx, AsyncMethodCallback<AsyncClient.alter_index_call> resultHandler) throws TException;

    public void drop_index_by_name(String db_name, String tbl_name, String index_name, boolean deleteData, AsyncMethodCallback<AsyncClient.drop_index_by_name_call> resultHandler) throws TException;

    public void get_index_by_name(String db_name, String tbl_name, String index_name, AsyncMethodCallback<AsyncClient.get_index_by_name_call> resultHandler) throws TException;

    public void get_indexes(String db_name, String tbl_name, short max_indexes, AsyncMethodCallback<AsyncClient.get_indexes_call> resultHandler) throws TException;

    public void get_index_names(String db_name, String tbl_name, short max_indexes, AsyncMethodCallback<AsyncClient.get_index_names_call> resultHandler) throws TException;

  }

  public static class Client extends com.facebook.fb303.FacebookService.Client implements TServiceClient, Iface {
    public static class Factory implements TServiceClientFactory<Client> {
      public Factory() {}
      public Client getClient(TProtocol prot) {
        return new Client(prot);
      }
      public Client getClient(TProtocol iprot, TProtocol oprot) {
        return new Client(iprot, oprot);
      }
    }

    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      super(iprot, oprot);
    }

    public void create_database(Database database) throws AlreadyExistsException, InvalidObjectException, MetaException, TException
    {
      send_create_database(database);
      recv_create_database();
    }

    public void send_create_database(Database database) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("create_database", TMessageType.CALL, ++seqid_));
      create_database_args args = new create_database_args();
      args.setDatabase(database);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_create_database() throws AlreadyExistsException, InvalidObjectException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "create_database failed: out of sequence response");
      }
      create_database_result result = new create_database_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      if (result.o3 != null) {
        throw result.o3;
      }
      return;
    }

    public Database get_database(String name) throws NoSuchObjectException, MetaException, TException
    {
      send_get_database(name);
      return recv_get_database();
    }

    public void send_get_database(String name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_database", TMessageType.CALL, ++seqid_));
      get_database_args args = new get_database_args();
      args.setName(name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Database recv_get_database() throws NoSuchObjectException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_database failed: out of sequence response");
      }
      get_database_result result = new get_database_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_database failed: unknown result");
    }

    public void drop_database(String name, boolean deleteData) throws NoSuchObjectException, InvalidOperationException, MetaException, TException
    {
      send_drop_database(name, deleteData);
      recv_drop_database();
    }

    public void send_drop_database(String name, boolean deleteData) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("drop_database", TMessageType.CALL, ++seqid_));
      drop_database_args args = new drop_database_args();
      args.setName(name);
      args.setDeleteData(deleteData);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_drop_database() throws NoSuchObjectException, InvalidOperationException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "drop_database failed: out of sequence response");
      }
      drop_database_result result = new drop_database_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      if (result.o3 != null) {
        throw result.o3;
      }
      return;
    }

    public List<String> get_databases(String pattern) throws MetaException, TException
    {
      send_get_databases(pattern);
      return recv_get_databases();
    }

    public void send_get_databases(String pattern) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_databases", TMessageType.CALL, ++seqid_));
      get_databases_args args = new get_databases_args();
      args.setPattern(pattern);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_get_databases() throws MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_databases failed: out of sequence response");
      }
      get_databases_result result = new get_databases_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_databases failed: unknown result");
    }

    public List<String> get_all_databases() throws MetaException, TException
    {
      send_get_all_databases();
      return recv_get_all_databases();
    }

    public void send_get_all_databases() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_all_databases", TMessageType.CALL, ++seqid_));
      get_all_databases_args args = new get_all_databases_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_get_all_databases() throws MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_all_databases failed: out of sequence response");
      }
      get_all_databases_result result = new get_all_databases_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_all_databases failed: unknown result");
    }

    public Type get_type(String name) throws MetaException, NoSuchObjectException, TException
    {
      send_get_type(name);
      return recv_get_type();
    }

    public void send_get_type(String name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_type", TMessageType.CALL, ++seqid_));
      get_type_args args = new get_type_args();
      args.setName(name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Type recv_get_type() throws MetaException, NoSuchObjectException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_type failed: out of sequence response");
      }
      get_type_result result = new get_type_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_type failed: unknown result");
    }

    public boolean create_type(Type type) throws AlreadyExistsException, InvalidObjectException, MetaException, TException
    {
      send_create_type(type);
      return recv_create_type();
    }

    public void send_create_type(Type type) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("create_type", TMessageType.CALL, ++seqid_));
      create_type_args args = new create_type_args();
      args.setType(type);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_create_type() throws AlreadyExistsException, InvalidObjectException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "create_type failed: out of sequence response");
      }
      create_type_result result = new create_type_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      if (result.o3 != null) {
        throw result.o3;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "create_type failed: unknown result");
    }

    public boolean drop_type(String type) throws MetaException, NoSuchObjectException, TException
    {
      send_drop_type(type);
      return recv_drop_type();
    }

    public void send_drop_type(String type) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("drop_type", TMessageType.CALL, ++seqid_));
      drop_type_args args = new drop_type_args();
      args.setType(type);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_drop_type() throws MetaException, NoSuchObjectException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "drop_type failed: out of sequence response");
      }
      drop_type_result result = new drop_type_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "drop_type failed: unknown result");
    }

    public Map<String,Type> get_type_all(String name) throws MetaException, TException
    {
      send_get_type_all(name);
      return recv_get_type_all();
    }

    public void send_get_type_all(String name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_type_all", TMessageType.CALL, ++seqid_));
      get_type_all_args args = new get_type_all_args();
      args.setName(name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<String,Type> recv_get_type_all() throws MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_type_all failed: out of sequence response");
      }
      get_type_all_result result = new get_type_all_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_type_all failed: unknown result");
    }

    public List<FieldSchema> get_fields(String db_name, String table_name) throws MetaException, UnknownTableException, UnknownDBException, TException
    {
      send_get_fields(db_name, table_name);
      return recv_get_fields();
    }

    public void send_get_fields(String db_name, String table_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_fields", TMessageType.CALL, ++seqid_));
      get_fields_args args = new get_fields_args();
      args.setDb_name(db_name);
      args.setTable_name(table_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<FieldSchema> recv_get_fields() throws MetaException, UnknownTableException, UnknownDBException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_fields failed: out of sequence response");
      }
      get_fields_result result = new get_fields_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      if (result.o3 != null) {
        throw result.o3;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_fields failed: unknown result");
    }

    public List<FieldSchema> get_schema(String db_name, String table_name) throws MetaException, UnknownTableException, UnknownDBException, TException
    {
      send_get_schema(db_name, table_name);
      return recv_get_schema();
    }

    public void send_get_schema(String db_name, String table_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_schema", TMessageType.CALL, ++seqid_));
      get_schema_args args = new get_schema_args();
      args.setDb_name(db_name);
      args.setTable_name(table_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<FieldSchema> recv_get_schema() throws MetaException, UnknownTableException, UnknownDBException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_schema failed: out of sequence response");
      }
      get_schema_result result = new get_schema_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      if (result.o3 != null) {
        throw result.o3;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_schema failed: unknown result");
    }

    public void create_table(Table tbl) throws AlreadyExistsException, InvalidObjectException, MetaException, NoSuchObjectException, TException
    {
      send_create_table(tbl);
      recv_create_table();
    }

    public void send_create_table(Table tbl) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("create_table", TMessageType.CALL, ++seqid_));
      create_table_args args = new create_table_args();
      args.setTbl(tbl);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_create_table() throws AlreadyExistsException, InvalidObjectException, MetaException, NoSuchObjectException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "create_table failed: out of sequence response");
      }
      create_table_result result = new create_table_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      if (result.o3 != null) {
        throw result.o3;
      }
      if (result.o4 != null) {
        throw result.o4;
      }
      return;
    }

    public void drop_table(String dbname, String name, boolean deleteData) throws NoSuchObjectException, MetaException, TException
    {
      send_drop_table(dbname, name, deleteData);
      recv_drop_table();
    }

    public void send_drop_table(String dbname, String name, boolean deleteData) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("drop_table", TMessageType.CALL, ++seqid_));
      drop_table_args args = new drop_table_args();
      args.setDbname(dbname);
      args.setName(name);
      args.setDeleteData(deleteData);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_drop_table() throws NoSuchObjectException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "drop_table failed: out of sequence response");
      }
      drop_table_result result = new drop_table_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o3 != null) {
        throw result.o3;
      }
      return;
    }

    public List<String> get_tables(String db_name, String pattern) throws MetaException, TException
    {
      send_get_tables(db_name, pattern);
      return recv_get_tables();
    }

    public void send_get_tables(String db_name, String pattern) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_tables", TMessageType.CALL, ++seqid_));
      get_tables_args args = new get_tables_args();
      args.setDb_name(db_name);
      args.setPattern(pattern);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_get_tables() throws MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_tables failed: out of sequence response");
      }
      get_tables_result result = new get_tables_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_tables failed: unknown result");
    }

    public List<String> get_all_tables(String db_name) throws MetaException, TException
    {
      send_get_all_tables(db_name);
      return recv_get_all_tables();
    }

    public void send_get_all_tables(String db_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_all_tables", TMessageType.CALL, ++seqid_));
      get_all_tables_args args = new get_all_tables_args();
      args.setDb_name(db_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_get_all_tables() throws MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_all_tables failed: out of sequence response");
      }
      get_all_tables_result result = new get_all_tables_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_all_tables failed: unknown result");
    }

    public Table get_table(String dbname, String tbl_name) throws MetaException, NoSuchObjectException, TException
    {
      send_get_table(dbname, tbl_name);
      return recv_get_table();
    }

    public void send_get_table(String dbname, String tbl_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_table", TMessageType.CALL, ++seqid_));
      get_table_args args = new get_table_args();
      args.setDbname(dbname);
      args.setTbl_name(tbl_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Table recv_get_table() throws MetaException, NoSuchObjectException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_table failed: out of sequence response");
      }
      get_table_result result = new get_table_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_table failed: unknown result");
    }

    public void alter_table(String dbname, String tbl_name, Table new_tbl) throws InvalidOperationException, MetaException, TException
    {
      send_alter_table(dbname, tbl_name, new_tbl);
      recv_alter_table();
    }

    public void send_alter_table(String dbname, String tbl_name, Table new_tbl) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("alter_table", TMessageType.CALL, ++seqid_));
      alter_table_args args = new alter_table_args();
      args.setDbname(dbname);
      args.setTbl_name(tbl_name);
      args.setNew_tbl(new_tbl);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_alter_table() throws InvalidOperationException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "alter_table failed: out of sequence response");
      }
      alter_table_result result = new alter_table_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      return;
    }

    public Partition add_partition(Partition new_part) throws InvalidObjectException, AlreadyExistsException, MetaException, TException
    {
      send_add_partition(new_part);
      return recv_add_partition();
    }

    public void send_add_partition(Partition new_part) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("add_partition", TMessageType.CALL, ++seqid_));
      add_partition_args args = new add_partition_args();
      args.setNew_part(new_part);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Partition recv_add_partition() throws InvalidObjectException, AlreadyExistsException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "add_partition failed: out of sequence response");
      }
      add_partition_result result = new add_partition_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      if (result.o3 != null) {
        throw result.o3;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "add_partition failed: unknown result");
    }

    public Partition append_partition(String db_name, String tbl_name, List<String> part_vals) throws InvalidObjectException, AlreadyExistsException, MetaException, TException
    {
      send_append_partition(db_name, tbl_name, part_vals);
      return recv_append_partition();
    }

    public void send_append_partition(String db_name, String tbl_name, List<String> part_vals) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("append_partition", TMessageType.CALL, ++seqid_));
      append_partition_args args = new append_partition_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setPart_vals(part_vals);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Partition recv_append_partition() throws InvalidObjectException, AlreadyExistsException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "append_partition failed: out of sequence response");
      }
      append_partition_result result = new append_partition_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      if (result.o3 != null) {
        throw result.o3;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "append_partition failed: unknown result");
    }

    public Partition append_partition_by_name(String db_name, String tbl_name, String part_name) throws InvalidObjectException, AlreadyExistsException, MetaException, TException
    {
      send_append_partition_by_name(db_name, tbl_name, part_name);
      return recv_append_partition_by_name();
    }

    public void send_append_partition_by_name(String db_name, String tbl_name, String part_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("append_partition_by_name", TMessageType.CALL, ++seqid_));
      append_partition_by_name_args args = new append_partition_by_name_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setPart_name(part_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Partition recv_append_partition_by_name() throws InvalidObjectException, AlreadyExistsException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "append_partition_by_name failed: out of sequence response");
      }
      append_partition_by_name_result result = new append_partition_by_name_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      if (result.o3 != null) {
        throw result.o3;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_by_name failed: unknown result");
    }

    public boolean drop_partition(String db_name, String tbl_name, List<String> part_vals, boolean deleteData) throws NoSuchObjectException, MetaException, TException
    {
      send_drop_partition(db_name, tbl_name, part_vals, deleteData);
      return recv_drop_partition();
    }

    public void send_drop_partition(String db_name, String tbl_name, List<String> part_vals, boolean deleteData) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("drop_partition", TMessageType.CALL, ++seqid_));
      drop_partition_args args = new drop_partition_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setPart_vals(part_vals);
      args.setDeleteData(deleteData);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_drop_partition() throws NoSuchObjectException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "drop_partition failed: out of sequence response");
      }
      drop_partition_result result = new drop_partition_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition failed: unknown result");
    }

    public boolean drop_partition_by_name(String db_name, String tbl_name, String part_name, boolean deleteData) throws NoSuchObjectException, MetaException, TException
    {
      send_drop_partition_by_name(db_name, tbl_name, part_name, deleteData);
      return recv_drop_partition_by_name();
    }

    public void send_drop_partition_by_name(String db_name, String tbl_name, String part_name, boolean deleteData) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("drop_partition_by_name", TMessageType.CALL, ++seqid_));
      drop_partition_by_name_args args = new drop_partition_by_name_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setPart_name(part_name);
      args.setDeleteData(deleteData);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_drop_partition_by_name() throws NoSuchObjectException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "drop_partition_by_name failed: out of sequence response");
      }
      drop_partition_by_name_result result = new drop_partition_by_name_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_by_name failed: unknown result");
    }

    public Partition get_partition(String db_name, String tbl_name, List<String> part_vals) throws MetaException, NoSuchObjectException, TException
    {
      send_get_partition(db_name, tbl_name, part_vals);
      return recv_get_partition();
    }

    public void send_get_partition(String db_name, String tbl_name, List<String> part_vals) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_partition", TMessageType.CALL, ++seqid_));
      get_partition_args args = new get_partition_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setPart_vals(part_vals);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Partition recv_get_partition() throws MetaException, NoSuchObjectException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_partition failed: out of sequence response");
      }
      get_partition_result result = new get_partition_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_partition failed: unknown result");
    }

    public Partition get_partition_by_name(String db_name, String tbl_name, String part_name) throws MetaException, NoSuchObjectException, TException
    {
      send_get_partition_by_name(db_name, tbl_name, part_name);
      return recv_get_partition_by_name();
    }

    public void send_get_partition_by_name(String db_name, String tbl_name, String part_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_partition_by_name", TMessageType.CALL, ++seqid_));
      get_partition_by_name_args args = new get_partition_by_name_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setPart_name(part_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Partition recv_get_partition_by_name() throws MetaException, NoSuchObjectException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_partition_by_name failed: out of sequence response");
      }
      get_partition_by_name_result result = new get_partition_by_name_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_by_name failed: unknown result");
    }

    public List<Partition> get_partitions(String db_name, String tbl_name, short max_parts) throws NoSuchObjectException, MetaException, TException
    {
      send_get_partitions(db_name, tbl_name, max_parts);
      return recv_get_partitions();
    }

    public void send_get_partitions(String db_name, String tbl_name, short max_parts) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_partitions", TMessageType.CALL, ++seqid_));
      get_partitions_args args = new get_partitions_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setMax_parts(max_parts);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Partition> recv_get_partitions() throws NoSuchObjectException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_partitions failed: out of sequence response");
      }
      get_partitions_result result = new get_partitions_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions failed: unknown result");
    }

    public List<String> get_partition_names(String db_name, String tbl_name, short max_parts) throws MetaException, TException
    {
      send_get_partition_names(db_name, tbl_name, max_parts);
      return recv_get_partition_names();
    }

    public void send_get_partition_names(String db_name, String tbl_name, short max_parts) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_partition_names", TMessageType.CALL, ++seqid_));
      get_partition_names_args args = new get_partition_names_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setMax_parts(max_parts);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_get_partition_names() throws MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_partition_names failed: out of sequence response");
      }
      get_partition_names_result result = new get_partition_names_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names failed: unknown result");
    }

    public List<Partition> get_partitions_ps(String db_name, String tbl_name, List<String> part_vals, short max_parts) throws MetaException, TException
    {
      send_get_partitions_ps(db_name, tbl_name, part_vals, max_parts);
      return recv_get_partitions_ps();
    }

    public void send_get_partitions_ps(String db_name, String tbl_name, List<String> part_vals, short max_parts) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_partitions_ps", TMessageType.CALL, ++seqid_));
      get_partitions_ps_args args = new get_partitions_ps_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setPart_vals(part_vals);
      args.setMax_parts(max_parts);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Partition> recv_get_partitions_ps() throws MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_partitions_ps failed: out of sequence response");
      }
      get_partitions_ps_result result = new get_partitions_ps_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps failed: unknown result");
    }

    public List<String> get_partition_names_ps(String db_name, String tbl_name, List<String> part_vals, short max_parts) throws MetaException, TException
    {
      send_get_partition_names_ps(db_name, tbl_name, part_vals, max_parts);
      return recv_get_partition_names_ps();
    }

    public void send_get_partition_names_ps(String db_name, String tbl_name, List<String> part_vals, short max_parts) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_partition_names_ps", TMessageType.CALL, ++seqid_));
      get_partition_names_ps_args args = new get_partition_names_ps_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setPart_vals(part_vals);
      args.setMax_parts(max_parts);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_get_partition_names_ps() throws MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_partition_names_ps failed: out of sequence response");
      }
      get_partition_names_ps_result result = new get_partition_names_ps_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names_ps failed: unknown result");
    }

    public List<Partition> get_partitions_by_filter(String db_name, String tbl_name, String filter, short max_parts) throws MetaException, NoSuchObjectException, TException
    {
      send_get_partitions_by_filter(db_name, tbl_name, filter, max_parts);
      return recv_get_partitions_by_filter();
    }

    public void send_get_partitions_by_filter(String db_name, String tbl_name, String filter, short max_parts) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_partitions_by_filter", TMessageType.CALL, ++seqid_));
      get_partitions_by_filter_args args = new get_partitions_by_filter_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setFilter(filter);
      args.setMax_parts(max_parts);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Partition> recv_get_partitions_by_filter() throws MetaException, NoSuchObjectException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_partitions_by_filter failed: out of sequence response");
      }
      get_partitions_by_filter_result result = new get_partitions_by_filter_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_filter failed: unknown result");
    }

    public void alter_partition(String db_name, String tbl_name, Partition new_part) throws InvalidOperationException, MetaException, TException
    {
      send_alter_partition(db_name, tbl_name, new_part);
      recv_alter_partition();
    }

    public void send_alter_partition(String db_name, String tbl_name, Partition new_part) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("alter_partition", TMessageType.CALL, ++seqid_));
      alter_partition_args args = new alter_partition_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setNew_part(new_part);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_alter_partition() throws InvalidOperationException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "alter_partition failed: out of sequence response");
      }
      alter_partition_result result = new alter_partition_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      return;
    }

    public String get_config_value(String name, String defaultValue) throws ConfigValSecurityException, TException
    {
      send_get_config_value(name, defaultValue);
      return recv_get_config_value();
    }

    public void send_get_config_value(String name, String defaultValue) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_config_value", TMessageType.CALL, ++seqid_));
      get_config_value_args args = new get_config_value_args();
      args.setName(name);
      args.setDefaultValue(defaultValue);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_get_config_value() throws ConfigValSecurityException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_config_value failed: out of sequence response");
      }
      get_config_value_result result = new get_config_value_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_config_value failed: unknown result");
    }

    public List<String> partition_name_to_vals(String part_name) throws MetaException, TException
    {
      send_partition_name_to_vals(part_name);
      return recv_partition_name_to_vals();
    }

    public void send_partition_name_to_vals(String part_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("partition_name_to_vals", TMessageType.CALL, ++seqid_));
      partition_name_to_vals_args args = new partition_name_to_vals_args();
      args.setPart_name(part_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_partition_name_to_vals() throws MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "partition_name_to_vals failed: out of sequence response");
      }
      partition_name_to_vals_result result = new partition_name_to_vals_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_vals failed: unknown result");
    }

    public Map<String,String> partition_name_to_spec(String part_name) throws MetaException, TException
    {
      send_partition_name_to_spec(part_name);
      return recv_partition_name_to_spec();
    }

    public void send_partition_name_to_spec(String part_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("partition_name_to_spec", TMessageType.CALL, ++seqid_));
      partition_name_to_spec_args args = new partition_name_to_spec_args();
      args.setPart_name(part_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<String,String> recv_partition_name_to_spec() throws MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "partition_name_to_spec failed: out of sequence response");
      }
      partition_name_to_spec_result result = new partition_name_to_spec_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_spec failed: unknown result");
    }

    public Index add_index(Index new_index, Table index_table) throws InvalidObjectException, AlreadyExistsException, MetaException, TException
    {
      send_add_index(new_index, index_table);
      return recv_add_index();
    }

    public void send_add_index(Index new_index, Table index_table) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("add_index", TMessageType.CALL, ++seqid_));
      add_index_args args = new add_index_args();
      args.setNew_index(new_index);
      args.setIndex_table(index_table);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Index recv_add_index() throws InvalidObjectException, AlreadyExistsException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "add_index failed: out of sequence response");
      }
      add_index_result result = new add_index_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      if (result.o3 != null) {
        throw result.o3;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "add_index failed: unknown result");
    }

    public void alter_index(String dbname, String base_tbl_name, String idx_name, Index new_idx) throws InvalidOperationException, MetaException, TException
    {
      send_alter_index(dbname, base_tbl_name, idx_name, new_idx);
      recv_alter_index();
    }

    public void send_alter_index(String dbname, String base_tbl_name, String idx_name, Index new_idx) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("alter_index", TMessageType.CALL, ++seqid_));
      alter_index_args args = new alter_index_args();
      args.setDbname(dbname);
      args.setBase_tbl_name(base_tbl_name);
      args.setIdx_name(idx_name);
      args.setNew_idx(new_idx);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_alter_index() throws InvalidOperationException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "alter_index failed: out of sequence response");
      }
      alter_index_result result = new alter_index_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      return;
    }

    public boolean drop_index_by_name(String db_name, String tbl_name, String index_name, boolean deleteData) throws NoSuchObjectException, MetaException, TException
    {
      send_drop_index_by_name(db_name, tbl_name, index_name, deleteData);
      return recv_drop_index_by_name();
    }

    public void send_drop_index_by_name(String db_name, String tbl_name, String index_name, boolean deleteData) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("drop_index_by_name", TMessageType.CALL, ++seqid_));
      drop_index_by_name_args args = new drop_index_by_name_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setIndex_name(index_name);
      args.setDeleteData(deleteData);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_drop_index_by_name() throws NoSuchObjectException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "drop_index_by_name failed: out of sequence response");
      }
      drop_index_by_name_result result = new drop_index_by_name_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "drop_index_by_name failed: unknown result");
    }

    public Index get_index_by_name(String db_name, String tbl_name, String index_name) throws MetaException, NoSuchObjectException, TException
    {
      send_get_index_by_name(db_name, tbl_name, index_name);
      return recv_get_index_by_name();
    }

    public void send_get_index_by_name(String db_name, String tbl_name, String index_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_index_by_name", TMessageType.CALL, ++seqid_));
      get_index_by_name_args args = new get_index_by_name_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setIndex_name(index_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Index recv_get_index_by_name() throws MetaException, NoSuchObjectException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_index_by_name failed: out of sequence response");
      }
      get_index_by_name_result result = new get_index_by_name_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_index_by_name failed: unknown result");
    }

    public List<Index> get_indexes(String db_name, String tbl_name, short max_indexes) throws NoSuchObjectException, MetaException, TException
    {
      send_get_indexes(db_name, tbl_name, max_indexes);
      return recv_get_indexes();
    }

    public void send_get_indexes(String db_name, String tbl_name, short max_indexes) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_indexes", TMessageType.CALL, ++seqid_));
      get_indexes_args args = new get_indexes_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setMax_indexes(max_indexes);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Index> recv_get_indexes() throws NoSuchObjectException, MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_indexes failed: out of sequence response");
      }
      get_indexes_result result = new get_indexes_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o1 != null) {
        throw result.o1;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_indexes failed: unknown result");
    }

    public List<String> get_index_names(String db_name, String tbl_name, short max_indexes) throws MetaException, TException
    {
      send_get_index_names(db_name, tbl_name, max_indexes);
      return recv_get_index_names();
    }

    public void send_get_index_names(String db_name, String tbl_name, short max_indexes) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_index_names", TMessageType.CALL, ++seqid_));
      get_index_names_args args = new get_index_names_args();
      args.setDb_name(db_name);
      args.setTbl_name(tbl_name);
      args.setMax_indexes(max_indexes);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_get_index_names() throws MetaException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_index_names failed: out of sequence response");
      }
      get_index_names_result result = new get_index_names_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.o2 != null) {
        throw result.o2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_index_names failed: unknown result");
    }

  }
  public static class AsyncClient extends com.facebook.fb303.FacebookService.AsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private TAsyncClientManager clientManager;
      private TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void create_database(Database database, AsyncMethodCallback<create_database_call> resultHandler) throws TException {
      checkReady();
      create_database_call method_call = new create_database_call(database, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class create_database_call extends TAsyncMethodCall {
      private Database database;
      public create_database_call(Database database, AsyncMethodCallback<create_database_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.database = database;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("create_database", TMessageType.CALL, 0));
        create_database_args args = new create_database_args();
        args.setDatabase(database);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws AlreadyExistsException, InvalidObjectException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_create_database();
      }
    }

    public void get_database(String name, AsyncMethodCallback<get_database_call> resultHandler) throws TException {
      checkReady();
      get_database_call method_call = new get_database_call(name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_database_call extends TAsyncMethodCall {
      private String name;
      public get_database_call(String name, AsyncMethodCallback<get_database_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.name = name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_database", TMessageType.CALL, 0));
        get_database_args args = new get_database_args();
        args.setName(name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Database getResult() throws NoSuchObjectException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_database();
      }
    }

    public void drop_database(String name, boolean deleteData, AsyncMethodCallback<drop_database_call> resultHandler) throws TException {
      checkReady();
      drop_database_call method_call = new drop_database_call(name, deleteData, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class drop_database_call extends TAsyncMethodCall {
      private String name;
      private boolean deleteData;
      public drop_database_call(String name, boolean deleteData, AsyncMethodCallback<drop_database_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.name = name;
        this.deleteData = deleteData;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("drop_database", TMessageType.CALL, 0));
        drop_database_args args = new drop_database_args();
        args.setName(name);
        args.setDeleteData(deleteData);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws NoSuchObjectException, InvalidOperationException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_drop_database();
      }
    }

    public void get_databases(String pattern, AsyncMethodCallback<get_databases_call> resultHandler) throws TException {
      checkReady();
      get_databases_call method_call = new get_databases_call(pattern, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_databases_call extends TAsyncMethodCall {
      private String pattern;
      public get_databases_call(String pattern, AsyncMethodCallback<get_databases_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.pattern = pattern;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_databases", TMessageType.CALL, 0));
        get_databases_args args = new get_databases_args();
        args.setPattern(pattern);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_databases();
      }
    }

    public void get_all_databases(AsyncMethodCallback<get_all_databases_call> resultHandler) throws TException {
      checkReady();
      get_all_databases_call method_call = new get_all_databases_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_all_databases_call extends TAsyncMethodCall {
      public get_all_databases_call(AsyncMethodCallback<get_all_databases_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_all_databases", TMessageType.CALL, 0));
        get_all_databases_args args = new get_all_databases_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_all_databases();
      }
    }

    public void get_type(String name, AsyncMethodCallback<get_type_call> resultHandler) throws TException {
      checkReady();
      get_type_call method_call = new get_type_call(name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_type_call extends TAsyncMethodCall {
      private String name;
      public get_type_call(String name, AsyncMethodCallback<get_type_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.name = name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_type", TMessageType.CALL, 0));
        get_type_args args = new get_type_args();
        args.setName(name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Type getResult() throws MetaException, NoSuchObjectException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_type();
      }
    }

    public void create_type(Type type, AsyncMethodCallback<create_type_call> resultHandler) throws TException {
      checkReady();
      create_type_call method_call = new create_type_call(type, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class create_type_call extends TAsyncMethodCall {
      private Type type;
      public create_type_call(Type type, AsyncMethodCallback<create_type_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.type = type;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("create_type", TMessageType.CALL, 0));
        create_type_args args = new create_type_args();
        args.setType(type);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws AlreadyExistsException, InvalidObjectException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_create_type();
      }
    }

    public void drop_type(String type, AsyncMethodCallback<drop_type_call> resultHandler) throws TException {
      checkReady();
      drop_type_call method_call = new drop_type_call(type, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class drop_type_call extends TAsyncMethodCall {
      private String type;
      public drop_type_call(String type, AsyncMethodCallback<drop_type_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.type = type;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("drop_type", TMessageType.CALL, 0));
        drop_type_args args = new drop_type_args();
        args.setType(type);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws MetaException, NoSuchObjectException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_drop_type();
      }
    }

    public void get_type_all(String name, AsyncMethodCallback<get_type_all_call> resultHandler) throws TException {
      checkReady();
      get_type_all_call method_call = new get_type_all_call(name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_type_all_call extends TAsyncMethodCall {
      private String name;
      public get_type_all_call(String name, AsyncMethodCallback<get_type_all_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.name = name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_type_all", TMessageType.CALL, 0));
        get_type_all_args args = new get_type_all_args();
        args.setName(name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Map<String,Type> getResult() throws MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_type_all();
      }
    }

    public void get_fields(String db_name, String table_name, AsyncMethodCallback<get_fields_call> resultHandler) throws TException {
      checkReady();
      get_fields_call method_call = new get_fields_call(db_name, table_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_fields_call extends TAsyncMethodCall {
      private String db_name;
      private String table_name;
      public get_fields_call(String db_name, String table_name, AsyncMethodCallback<get_fields_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.table_name = table_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_fields", TMessageType.CALL, 0));
        get_fields_args args = new get_fields_args();
        args.setDb_name(db_name);
        args.setTable_name(table_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<FieldSchema> getResult() throws MetaException, UnknownTableException, UnknownDBException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_fields();
      }
    }

    public void get_schema(String db_name, String table_name, AsyncMethodCallback<get_schema_call> resultHandler) throws TException {
      checkReady();
      get_schema_call method_call = new get_schema_call(db_name, table_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_schema_call extends TAsyncMethodCall {
      private String db_name;
      private String table_name;
      public get_schema_call(String db_name, String table_name, AsyncMethodCallback<get_schema_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.table_name = table_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_schema", TMessageType.CALL, 0));
        get_schema_args args = new get_schema_args();
        args.setDb_name(db_name);
        args.setTable_name(table_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<FieldSchema> getResult() throws MetaException, UnknownTableException, UnknownDBException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_schema();
      }
    }

    public void create_table(Table tbl, AsyncMethodCallback<create_table_call> resultHandler) throws TException {
      checkReady();
      create_table_call method_call = new create_table_call(tbl, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class create_table_call extends TAsyncMethodCall {
      private Table tbl;
      public create_table_call(Table tbl, AsyncMethodCallback<create_table_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tbl = tbl;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("create_table", TMessageType.CALL, 0));
        create_table_args args = new create_table_args();
        args.setTbl(tbl);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws AlreadyExistsException, InvalidObjectException, MetaException, NoSuchObjectException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_create_table();
      }
    }

    public void drop_table(String dbname, String name, boolean deleteData, AsyncMethodCallback<drop_table_call> resultHandler) throws TException {
      checkReady();
      drop_table_call method_call = new drop_table_call(dbname, name, deleteData, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class drop_table_call extends TAsyncMethodCall {
      private String dbname;
      private String name;
      private boolean deleteData;
      public drop_table_call(String dbname, String name, boolean deleteData, AsyncMethodCallback<drop_table_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.dbname = dbname;
        this.name = name;
        this.deleteData = deleteData;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("drop_table", TMessageType.CALL, 0));
        drop_table_args args = new drop_table_args();
        args.setDbname(dbname);
        args.setName(name);
        args.setDeleteData(deleteData);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws NoSuchObjectException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_drop_table();
      }
    }

    public void get_tables(String db_name, String pattern, AsyncMethodCallback<get_tables_call> resultHandler) throws TException {
      checkReady();
      get_tables_call method_call = new get_tables_call(db_name, pattern, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_tables_call extends TAsyncMethodCall {
      private String db_name;
      private String pattern;
      public get_tables_call(String db_name, String pattern, AsyncMethodCallback<get_tables_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.pattern = pattern;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_tables", TMessageType.CALL, 0));
        get_tables_args args = new get_tables_args();
        args.setDb_name(db_name);
        args.setPattern(pattern);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_tables();
      }
    }

    public void get_all_tables(String db_name, AsyncMethodCallback<get_all_tables_call> resultHandler) throws TException {
      checkReady();
      get_all_tables_call method_call = new get_all_tables_call(db_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_all_tables_call extends TAsyncMethodCall {
      private String db_name;
      public get_all_tables_call(String db_name, AsyncMethodCallback<get_all_tables_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_all_tables", TMessageType.CALL, 0));
        get_all_tables_args args = new get_all_tables_args();
        args.setDb_name(db_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_all_tables();
      }
    }

    public void get_table(String dbname, String tbl_name, AsyncMethodCallback<get_table_call> resultHandler) throws TException {
      checkReady();
      get_table_call method_call = new get_table_call(dbname, tbl_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_table_call extends TAsyncMethodCall {
      private String dbname;
      private String tbl_name;
      public get_table_call(String dbname, String tbl_name, AsyncMethodCallback<get_table_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.dbname = dbname;
        this.tbl_name = tbl_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_table", TMessageType.CALL, 0));
        get_table_args args = new get_table_args();
        args.setDbname(dbname);
        args.setTbl_name(tbl_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Table getResult() throws MetaException, NoSuchObjectException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_table();
      }
    }

    public void alter_table(String dbname, String tbl_name, Table new_tbl, AsyncMethodCallback<alter_table_call> resultHandler) throws TException {
      checkReady();
      alter_table_call method_call = new alter_table_call(dbname, tbl_name, new_tbl, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class alter_table_call extends TAsyncMethodCall {
      private String dbname;
      private String tbl_name;
      private Table new_tbl;
      public alter_table_call(String dbname, String tbl_name, Table new_tbl, AsyncMethodCallback<alter_table_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.dbname = dbname;
        this.tbl_name = tbl_name;
        this.new_tbl = new_tbl;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alter_table", TMessageType.CALL, 0));
        alter_table_args args = new alter_table_args();
        args.setDbname(dbname);
        args.setTbl_name(tbl_name);
        args.setNew_tbl(new_tbl);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws InvalidOperationException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_alter_table();
      }
    }

    public void add_partition(Partition new_part, AsyncMethodCallback<add_partition_call> resultHandler) throws TException {
      checkReady();
      add_partition_call method_call = new add_partition_call(new_part, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class add_partition_call extends TAsyncMethodCall {
      private Partition new_part;
      public add_partition_call(Partition new_part, AsyncMethodCallback<add_partition_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.new_part = new_part;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("add_partition", TMessageType.CALL, 0));
        add_partition_args args = new add_partition_args();
        args.setNew_part(new_part);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Partition getResult() throws InvalidObjectException, AlreadyExistsException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_add_partition();
      }
    }

    public void append_partition(String db_name, String tbl_name, List<String> part_vals, AsyncMethodCallback<append_partition_call> resultHandler) throws TException {
      checkReady();
      append_partition_call method_call = new append_partition_call(db_name, tbl_name, part_vals, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class append_partition_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private List<String> part_vals;
      public append_partition_call(String db_name, String tbl_name, List<String> part_vals, AsyncMethodCallback<append_partition_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.part_vals = part_vals;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("append_partition", TMessageType.CALL, 0));
        append_partition_args args = new append_partition_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setPart_vals(part_vals);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Partition getResult() throws InvalidObjectException, AlreadyExistsException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_append_partition();
      }
    }

    public void append_partition_by_name(String db_name, String tbl_name, String part_name, AsyncMethodCallback<append_partition_by_name_call> resultHandler) throws TException {
      checkReady();
      append_partition_by_name_call method_call = new append_partition_by_name_call(db_name, tbl_name, part_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class append_partition_by_name_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private String part_name;
      public append_partition_by_name_call(String db_name, String tbl_name, String part_name, AsyncMethodCallback<append_partition_by_name_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.part_name = part_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("append_partition_by_name", TMessageType.CALL, 0));
        append_partition_by_name_args args = new append_partition_by_name_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setPart_name(part_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Partition getResult() throws InvalidObjectException, AlreadyExistsException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_append_partition_by_name();
      }
    }

    public void drop_partition(String db_name, String tbl_name, List<String> part_vals, boolean deleteData, AsyncMethodCallback<drop_partition_call> resultHandler) throws TException {
      checkReady();
      drop_partition_call method_call = new drop_partition_call(db_name, tbl_name, part_vals, deleteData, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class drop_partition_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private List<String> part_vals;
      private boolean deleteData;
      public drop_partition_call(String db_name, String tbl_name, List<String> part_vals, boolean deleteData, AsyncMethodCallback<drop_partition_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.part_vals = part_vals;
        this.deleteData = deleteData;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("drop_partition", TMessageType.CALL, 0));
        drop_partition_args args = new drop_partition_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setPart_vals(part_vals);
        args.setDeleteData(deleteData);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws NoSuchObjectException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_drop_partition();
      }
    }

    public void drop_partition_by_name(String db_name, String tbl_name, String part_name, boolean deleteData, AsyncMethodCallback<drop_partition_by_name_call> resultHandler) throws TException {
      checkReady();
      drop_partition_by_name_call method_call = new drop_partition_by_name_call(db_name, tbl_name, part_name, deleteData, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class drop_partition_by_name_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private String part_name;
      private boolean deleteData;
      public drop_partition_by_name_call(String db_name, String tbl_name, String part_name, boolean deleteData, AsyncMethodCallback<drop_partition_by_name_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.part_name = part_name;
        this.deleteData = deleteData;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("drop_partition_by_name", TMessageType.CALL, 0));
        drop_partition_by_name_args args = new drop_partition_by_name_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setPart_name(part_name);
        args.setDeleteData(deleteData);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws NoSuchObjectException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_drop_partition_by_name();
      }
    }

    public void get_partition(String db_name, String tbl_name, List<String> part_vals, AsyncMethodCallback<get_partition_call> resultHandler) throws TException {
      checkReady();
      get_partition_call method_call = new get_partition_call(db_name, tbl_name, part_vals, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_partition_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private List<String> part_vals;
      public get_partition_call(String db_name, String tbl_name, List<String> part_vals, AsyncMethodCallback<get_partition_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.part_vals = part_vals;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_partition", TMessageType.CALL, 0));
        get_partition_args args = new get_partition_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setPart_vals(part_vals);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Partition getResult() throws MetaException, NoSuchObjectException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_partition();
      }
    }

    public void get_partition_by_name(String db_name, String tbl_name, String part_name, AsyncMethodCallback<get_partition_by_name_call> resultHandler) throws TException {
      checkReady();
      get_partition_by_name_call method_call = new get_partition_by_name_call(db_name, tbl_name, part_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_partition_by_name_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private String part_name;
      public get_partition_by_name_call(String db_name, String tbl_name, String part_name, AsyncMethodCallback<get_partition_by_name_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.part_name = part_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_partition_by_name", TMessageType.CALL, 0));
        get_partition_by_name_args args = new get_partition_by_name_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setPart_name(part_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Partition getResult() throws MetaException, NoSuchObjectException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_partition_by_name();
      }
    }

    public void get_partitions(String db_name, String tbl_name, short max_parts, AsyncMethodCallback<get_partitions_call> resultHandler) throws TException {
      checkReady();
      get_partitions_call method_call = new get_partitions_call(db_name, tbl_name, max_parts, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_partitions_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private short max_parts;
      public get_partitions_call(String db_name, String tbl_name, short max_parts, AsyncMethodCallback<get_partitions_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.max_parts = max_parts;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_partitions", TMessageType.CALL, 0));
        get_partitions_args args = new get_partitions_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setMax_parts(max_parts);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Partition> getResult() throws NoSuchObjectException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_partitions();
      }
    }

    public void get_partition_names(String db_name, String tbl_name, short max_parts, AsyncMethodCallback<get_partition_names_call> resultHandler) throws TException {
      checkReady();
      get_partition_names_call method_call = new get_partition_names_call(db_name, tbl_name, max_parts, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_partition_names_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private short max_parts;
      public get_partition_names_call(String db_name, String tbl_name, short max_parts, AsyncMethodCallback<get_partition_names_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.max_parts = max_parts;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_partition_names", TMessageType.CALL, 0));
        get_partition_names_args args = new get_partition_names_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setMax_parts(max_parts);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_partition_names();
      }
    }

    public void get_partitions_ps(String db_name, String tbl_name, List<String> part_vals, short max_parts, AsyncMethodCallback<get_partitions_ps_call> resultHandler) throws TException {
      checkReady();
      get_partitions_ps_call method_call = new get_partitions_ps_call(db_name, tbl_name, part_vals, max_parts, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_partitions_ps_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private List<String> part_vals;
      private short max_parts;
      public get_partitions_ps_call(String db_name, String tbl_name, List<String> part_vals, short max_parts, AsyncMethodCallback<get_partitions_ps_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.part_vals = part_vals;
        this.max_parts = max_parts;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_partitions_ps", TMessageType.CALL, 0));
        get_partitions_ps_args args = new get_partitions_ps_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setPart_vals(part_vals);
        args.setMax_parts(max_parts);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Partition> getResult() throws MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_partitions_ps();
      }
    }

    public void get_partition_names_ps(String db_name, String tbl_name, List<String> part_vals, short max_parts, AsyncMethodCallback<get_partition_names_ps_call> resultHandler) throws TException {
      checkReady();
      get_partition_names_ps_call method_call = new get_partition_names_ps_call(db_name, tbl_name, part_vals, max_parts, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_partition_names_ps_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private List<String> part_vals;
      private short max_parts;
      public get_partition_names_ps_call(String db_name, String tbl_name, List<String> part_vals, short max_parts, AsyncMethodCallback<get_partition_names_ps_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.part_vals = part_vals;
        this.max_parts = max_parts;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_partition_names_ps", TMessageType.CALL, 0));
        get_partition_names_ps_args args = new get_partition_names_ps_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setPart_vals(part_vals);
        args.setMax_parts(max_parts);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_partition_names_ps();
      }
    }

    public void get_partitions_by_filter(String db_name, String tbl_name, String filter, short max_parts, AsyncMethodCallback<get_partitions_by_filter_call> resultHandler) throws TException {
      checkReady();
      get_partitions_by_filter_call method_call = new get_partitions_by_filter_call(db_name, tbl_name, filter, max_parts, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_partitions_by_filter_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private String filter;
      private short max_parts;
      public get_partitions_by_filter_call(String db_name, String tbl_name, String filter, short max_parts, AsyncMethodCallback<get_partitions_by_filter_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.filter = filter;
        this.max_parts = max_parts;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_partitions_by_filter", TMessageType.CALL, 0));
        get_partitions_by_filter_args args = new get_partitions_by_filter_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setFilter(filter);
        args.setMax_parts(max_parts);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Partition> getResult() throws MetaException, NoSuchObjectException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_partitions_by_filter();
      }
    }

    public void alter_partition(String db_name, String tbl_name, Partition new_part, AsyncMethodCallback<alter_partition_call> resultHandler) throws TException {
      checkReady();
      alter_partition_call method_call = new alter_partition_call(db_name, tbl_name, new_part, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class alter_partition_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private Partition new_part;
      public alter_partition_call(String db_name, String tbl_name, Partition new_part, AsyncMethodCallback<alter_partition_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.new_part = new_part;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alter_partition", TMessageType.CALL, 0));
        alter_partition_args args = new alter_partition_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setNew_part(new_part);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws InvalidOperationException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_alter_partition();
      }
    }

    public void get_config_value(String name, String defaultValue, AsyncMethodCallback<get_config_value_call> resultHandler) throws TException {
      checkReady();
      get_config_value_call method_call = new get_config_value_call(name, defaultValue, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_config_value_call extends TAsyncMethodCall {
      private String name;
      private String defaultValue;
      public get_config_value_call(String name, String defaultValue, AsyncMethodCallback<get_config_value_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.name = name;
        this.defaultValue = defaultValue;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_config_value", TMessageType.CALL, 0));
        get_config_value_args args = new get_config_value_args();
        args.setName(name);
        args.setDefaultValue(defaultValue);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws ConfigValSecurityException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_config_value();
      }
    }

    public void partition_name_to_vals(String part_name, AsyncMethodCallback<partition_name_to_vals_call> resultHandler) throws TException {
      checkReady();
      partition_name_to_vals_call method_call = new partition_name_to_vals_call(part_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class partition_name_to_vals_call extends TAsyncMethodCall {
      private String part_name;
      public partition_name_to_vals_call(String part_name, AsyncMethodCallback<partition_name_to_vals_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.part_name = part_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("partition_name_to_vals", TMessageType.CALL, 0));
        partition_name_to_vals_args args = new partition_name_to_vals_args();
        args.setPart_name(part_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_partition_name_to_vals();
      }
    }

    public void partition_name_to_spec(String part_name, AsyncMethodCallback<partition_name_to_spec_call> resultHandler) throws TException {
      checkReady();
      partition_name_to_spec_call method_call = new partition_name_to_spec_call(part_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class partition_name_to_spec_call extends TAsyncMethodCall {
      private String part_name;
      public partition_name_to_spec_call(String part_name, AsyncMethodCallback<partition_name_to_spec_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.part_name = part_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("partition_name_to_spec", TMessageType.CALL, 0));
        partition_name_to_spec_args args = new partition_name_to_spec_args();
        args.setPart_name(part_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Map<String,String> getResult() throws MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_partition_name_to_spec();
      }
    }

    public void add_index(Index new_index, Table index_table, AsyncMethodCallback<add_index_call> resultHandler) throws TException {
      checkReady();
      add_index_call method_call = new add_index_call(new_index, index_table, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class add_index_call extends TAsyncMethodCall {
      private Index new_index;
      private Table index_table;
      public add_index_call(Index new_index, Table index_table, AsyncMethodCallback<add_index_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.new_index = new_index;
        this.index_table = index_table;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("add_index", TMessageType.CALL, 0));
        add_index_args args = new add_index_args();
        args.setNew_index(new_index);
        args.setIndex_table(index_table);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Index getResult() throws InvalidObjectException, AlreadyExistsException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_add_index();
      }
    }

    public void alter_index(String dbname, String base_tbl_name, String idx_name, Index new_idx, AsyncMethodCallback<alter_index_call> resultHandler) throws TException {
      checkReady();
      alter_index_call method_call = new alter_index_call(dbname, base_tbl_name, idx_name, new_idx, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class alter_index_call extends TAsyncMethodCall {
      private String dbname;
      private String base_tbl_name;
      private String idx_name;
      private Index new_idx;
      public alter_index_call(String dbname, String base_tbl_name, String idx_name, Index new_idx, AsyncMethodCallback<alter_index_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.dbname = dbname;
        this.base_tbl_name = base_tbl_name;
        this.idx_name = idx_name;
        this.new_idx = new_idx;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("alter_index", TMessageType.CALL, 0));
        alter_index_args args = new alter_index_args();
        args.setDbname(dbname);
        args.setBase_tbl_name(base_tbl_name);
        args.setIdx_name(idx_name);
        args.setNew_idx(new_idx);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws InvalidOperationException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_alter_index();
      }
    }

    public void drop_index_by_name(String db_name, String tbl_name, String index_name, boolean deleteData, AsyncMethodCallback<drop_index_by_name_call> resultHandler) throws TException {
      checkReady();
      drop_index_by_name_call method_call = new drop_index_by_name_call(db_name, tbl_name, index_name, deleteData, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class drop_index_by_name_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private String index_name;
      private boolean deleteData;
      public drop_index_by_name_call(String db_name, String tbl_name, String index_name, boolean deleteData, AsyncMethodCallback<drop_index_by_name_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.index_name = index_name;
        this.deleteData = deleteData;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("drop_index_by_name", TMessageType.CALL, 0));
        drop_index_by_name_args args = new drop_index_by_name_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setIndex_name(index_name);
        args.setDeleteData(deleteData);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws NoSuchObjectException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_drop_index_by_name();
      }
    }

    public void get_index_by_name(String db_name, String tbl_name, String index_name, AsyncMethodCallback<get_index_by_name_call> resultHandler) throws TException {
      checkReady();
      get_index_by_name_call method_call = new get_index_by_name_call(db_name, tbl_name, index_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_index_by_name_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private String index_name;
      public get_index_by_name_call(String db_name, String tbl_name, String index_name, AsyncMethodCallback<get_index_by_name_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.index_name = index_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_index_by_name", TMessageType.CALL, 0));
        get_index_by_name_args args = new get_index_by_name_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setIndex_name(index_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Index getResult() throws MetaException, NoSuchObjectException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_index_by_name();
      }
    }

    public void get_indexes(String db_name, String tbl_name, short max_indexes, AsyncMethodCallback<get_indexes_call> resultHandler) throws TException {
      checkReady();
      get_indexes_call method_call = new get_indexes_call(db_name, tbl_name, max_indexes, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_indexes_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private short max_indexes;
      public get_indexes_call(String db_name, String tbl_name, short max_indexes, AsyncMethodCallback<get_indexes_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.max_indexes = max_indexes;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_indexes", TMessageType.CALL, 0));
        get_indexes_args args = new get_indexes_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setMax_indexes(max_indexes);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Index> getResult() throws NoSuchObjectException, MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_indexes();
      }
    }

    public void get_index_names(String db_name, String tbl_name, short max_indexes, AsyncMethodCallback<get_index_names_call> resultHandler) throws TException {
      checkReady();
      get_index_names_call method_call = new get_index_names_call(db_name, tbl_name, max_indexes, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_index_names_call extends TAsyncMethodCall {
      private String db_name;
      private String tbl_name;
      private short max_indexes;
      public get_index_names_call(String db_name, String tbl_name, short max_indexes, AsyncMethodCallback<get_index_names_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.db_name = db_name;
        this.tbl_name = tbl_name;
        this.max_indexes = max_indexes;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_index_names", TMessageType.CALL, 0));
        get_index_names_args args = new get_index_names_args();
        args.setDb_name(db_name);
        args.setTbl_name(tbl_name);
        args.setMax_indexes(max_indexes);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws MetaException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_index_names();
      }
    }

  }

  public static class Processor extends com.facebook.fb303.FacebookService.Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      super(iface);
      iface_ = iface;
      processMap_.put("create_database", new create_database());
      processMap_.put("get_database", new get_database());
      processMap_.put("drop_database", new drop_database());
      processMap_.put("get_databases", new get_databases());
      processMap_.put("get_all_databases", new get_all_databases());
      processMap_.put("get_type", new get_type());
      processMap_.put("create_type", new create_type());
      processMap_.put("drop_type", new drop_type());
      processMap_.put("get_type_all", new get_type_all());
      processMap_.put("get_fields", new get_fields());
      processMap_.put("get_schema", new get_schema());
      processMap_.put("create_table", new create_table());
      processMap_.put("drop_table", new drop_table());
      processMap_.put("get_tables", new get_tables());
      processMap_.put("get_all_tables", new get_all_tables());
      processMap_.put("get_table", new get_table());
      processMap_.put("alter_table", new alter_table());
      processMap_.put("add_partition", new add_partition());
      processMap_.put("append_partition", new append_partition());
      processMap_.put("append_partition_by_name", new append_partition_by_name());
      processMap_.put("drop_partition", new drop_partition());
      processMap_.put("drop_partition_by_name", new drop_partition_by_name());
      processMap_.put("get_partition", new get_partition());
      processMap_.put("get_partition_by_name", new get_partition_by_name());
      processMap_.put("get_partitions", new get_partitions());
      processMap_.put("get_partition_names", new get_partition_names());
      processMap_.put("get_partitions_ps", new get_partitions_ps());
      processMap_.put("get_partition_names_ps", new get_partition_names_ps());
      processMap_.put("get_partitions_by_filter", new get_partitions_by_filter());
      processMap_.put("alter_partition", new alter_partition());
      processMap_.put("get_config_value", new get_config_value());
      processMap_.put("partition_name_to_vals", new partition_name_to_vals());
      processMap_.put("partition_name_to_spec", new partition_name_to_spec());
      processMap_.put("add_index", new add_index());
      processMap_.put("alter_index", new alter_index());
      processMap_.put("drop_index_by_name", new drop_index_by_name());
      processMap_.put("get_index_by_name", new get_index_by_name());
      processMap_.put("get_indexes", new get_indexes());
      processMap_.put("get_index_names", new get_index_names());
    }

    private Iface iface_;

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class create_database implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        create_database_args args = new create_database_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("create_database", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        create_database_result result = new create_database_result();
        try {
          iface_.create_database(args.database);
        } catch (AlreadyExistsException o1) {
          result.o1 = o1;
        } catch (InvalidObjectException o2) {
          result.o2 = o2;
        } catch (MetaException o3) {
          result.o3 = o3;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing create_database", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing create_database");
          oprot.writeMessageBegin(new TMessage("create_database", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("create_database", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_database implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_database_args args = new get_database_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_database", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_database_result result = new get_database_result();
        try {
          result.success = iface_.get_database(args.name);
        } catch (NoSuchObjectException o1) {
          result.o1 = o1;
        } catch (MetaException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_database", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_database");
          oprot.writeMessageBegin(new TMessage("get_database", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_database", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class drop_database implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        drop_database_args args = new drop_database_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("drop_database", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        drop_database_result result = new drop_database_result();
        try {
          iface_.drop_database(args.name, args.deleteData);
        } catch (NoSuchObjectException o1) {
          result.o1 = o1;
        } catch (InvalidOperationException o2) {
          result.o2 = o2;
        } catch (MetaException o3) {
          result.o3 = o3;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing drop_database", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing drop_database");
          oprot.writeMessageBegin(new TMessage("drop_database", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("drop_database", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_databases implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_databases_args args = new get_databases_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_databases", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_databases_result result = new get_databases_result();
        try {
          result.success = iface_.get_databases(args.pattern);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_databases", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_databases");
          oprot.writeMessageBegin(new TMessage("get_databases", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_databases", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_all_databases implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_all_databases_args args = new get_all_databases_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_all_databases", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_all_databases_result result = new get_all_databases_result();
        try {
          result.success = iface_.get_all_databases();
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_all_databases", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_all_databases");
          oprot.writeMessageBegin(new TMessage("get_all_databases", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_all_databases", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_type implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_type_args args = new get_type_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_type", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_type_result result = new get_type_result();
        try {
          result.success = iface_.get_type(args.name);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (NoSuchObjectException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_type", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_type");
          oprot.writeMessageBegin(new TMessage("get_type", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_type", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class create_type implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        create_type_args args = new create_type_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("create_type", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        create_type_result result = new create_type_result();
        try {
          result.success = iface_.create_type(args.type);
          result.setSuccessIsSet(true);
        } catch (AlreadyExistsException o1) {
          result.o1 = o1;
        } catch (InvalidObjectException o2) {
          result.o2 = o2;
        } catch (MetaException o3) {
          result.o3 = o3;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing create_type", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing create_type");
          oprot.writeMessageBegin(new TMessage("create_type", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("create_type", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class drop_type implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        drop_type_args args = new drop_type_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("drop_type", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        drop_type_result result = new drop_type_result();
        try {
          result.success = iface_.drop_type(args.type);
          result.setSuccessIsSet(true);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (NoSuchObjectException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing drop_type", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing drop_type");
          oprot.writeMessageBegin(new TMessage("drop_type", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("drop_type", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_type_all implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_type_all_args args = new get_type_all_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_type_all", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_type_all_result result = new get_type_all_result();
        try {
          result.success = iface_.get_type_all(args.name);
        } catch (MetaException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_type_all", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_type_all");
          oprot.writeMessageBegin(new TMessage("get_type_all", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_type_all", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_fields implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_fields_args args = new get_fields_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_fields", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_fields_result result = new get_fields_result();
        try {
          result.success = iface_.get_fields(args.db_name, args.table_name);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (UnknownTableException o2) {
          result.o2 = o2;
        } catch (UnknownDBException o3) {
          result.o3 = o3;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_fields", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_fields");
          oprot.writeMessageBegin(new TMessage("get_fields", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_fields", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_schema implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_schema_args args = new get_schema_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_schema", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_schema_result result = new get_schema_result();
        try {
          result.success = iface_.get_schema(args.db_name, args.table_name);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (UnknownTableException o2) {
          result.o2 = o2;
        } catch (UnknownDBException o3) {
          result.o3 = o3;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_schema", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_schema");
          oprot.writeMessageBegin(new TMessage("get_schema", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_schema", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class create_table implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        create_table_args args = new create_table_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("create_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        create_table_result result = new create_table_result();
        try {
          iface_.create_table(args.tbl);
        } catch (AlreadyExistsException o1) {
          result.o1 = o1;
        } catch (InvalidObjectException o2) {
          result.o2 = o2;
        } catch (MetaException o3) {
          result.o3 = o3;
        } catch (NoSuchObjectException o4) {
          result.o4 = o4;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing create_table", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing create_table");
          oprot.writeMessageBegin(new TMessage("create_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("create_table", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class drop_table implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        drop_table_args args = new drop_table_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("drop_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        drop_table_result result = new drop_table_result();
        try {
          iface_.drop_table(args.dbname, args.name, args.deleteData);
        } catch (NoSuchObjectException o1) {
          result.o1 = o1;
        } catch (MetaException o3) {
          result.o3 = o3;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing drop_table", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing drop_table");
          oprot.writeMessageBegin(new TMessage("drop_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("drop_table", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_tables implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_tables_args args = new get_tables_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_tables", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_tables_result result = new get_tables_result();
        try {
          result.success = iface_.get_tables(args.db_name, args.pattern);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_tables", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_tables");
          oprot.writeMessageBegin(new TMessage("get_tables", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_tables", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_all_tables implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_all_tables_args args = new get_all_tables_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_all_tables", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_all_tables_result result = new get_all_tables_result();
        try {
          result.success = iface_.get_all_tables(args.db_name);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_all_tables", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_all_tables");
          oprot.writeMessageBegin(new TMessage("get_all_tables", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_all_tables", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_table implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_table_args args = new get_table_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_table_result result = new get_table_result();
        try {
          result.success = iface_.get_table(args.dbname, args.tbl_name);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (NoSuchObjectException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_table", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_table");
          oprot.writeMessageBegin(new TMessage("get_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_table", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class alter_table implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        alter_table_args args = new alter_table_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("alter_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        alter_table_result result = new alter_table_result();
        try {
          iface_.alter_table(args.dbname, args.tbl_name, args.new_tbl);
        } catch (InvalidOperationException o1) {
          result.o1 = o1;
        } catch (MetaException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing alter_table", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing alter_table");
          oprot.writeMessageBegin(new TMessage("alter_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("alter_table", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class add_partition implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        add_partition_args args = new add_partition_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("add_partition", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        add_partition_result result = new add_partition_result();
        try {
          result.success = iface_.add_partition(args.new_part);
        } catch (InvalidObjectException o1) {
          result.o1 = o1;
        } catch (AlreadyExistsException o2) {
          result.o2 = o2;
        } catch (MetaException o3) {
          result.o3 = o3;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing add_partition", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing add_partition");
          oprot.writeMessageBegin(new TMessage("add_partition", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("add_partition", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class append_partition implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        append_partition_args args = new append_partition_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("append_partition", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        append_partition_result result = new append_partition_result();
        try {
          result.success = iface_.append_partition(args.db_name, args.tbl_name, args.part_vals);
        } catch (InvalidObjectException o1) {
          result.o1 = o1;
        } catch (AlreadyExistsException o2) {
          result.o2 = o2;
        } catch (MetaException o3) {
          result.o3 = o3;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing append_partition", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing append_partition");
          oprot.writeMessageBegin(new TMessage("append_partition", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("append_partition", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class append_partition_by_name implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        append_partition_by_name_args args = new append_partition_by_name_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("append_partition_by_name", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        append_partition_by_name_result result = new append_partition_by_name_result();
        try {
          result.success = iface_.append_partition_by_name(args.db_name, args.tbl_name, args.part_name);
        } catch (InvalidObjectException o1) {
          result.o1 = o1;
        } catch (AlreadyExistsException o2) {
          result.o2 = o2;
        } catch (MetaException o3) {
          result.o3 = o3;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing append_partition_by_name", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing append_partition_by_name");
          oprot.writeMessageBegin(new TMessage("append_partition_by_name", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("append_partition_by_name", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class drop_partition implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        drop_partition_args args = new drop_partition_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("drop_partition", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        drop_partition_result result = new drop_partition_result();
        try {
          result.success = iface_.drop_partition(args.db_name, args.tbl_name, args.part_vals, args.deleteData);
          result.setSuccessIsSet(true);
        } catch (NoSuchObjectException o1) {
          result.o1 = o1;
        } catch (MetaException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing drop_partition", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing drop_partition");
          oprot.writeMessageBegin(new TMessage("drop_partition", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("drop_partition", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class drop_partition_by_name implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        drop_partition_by_name_args args = new drop_partition_by_name_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("drop_partition_by_name", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        drop_partition_by_name_result result = new drop_partition_by_name_result();
        try {
          result.success = iface_.drop_partition_by_name(args.db_name, args.tbl_name, args.part_name, args.deleteData);
          result.setSuccessIsSet(true);
        } catch (NoSuchObjectException o1) {
          result.o1 = o1;
        } catch (MetaException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing drop_partition_by_name", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing drop_partition_by_name");
          oprot.writeMessageBegin(new TMessage("drop_partition_by_name", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("drop_partition_by_name", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_partition implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_partition_args args = new get_partition_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_partition", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_partition_result result = new get_partition_result();
        try {
          result.success = iface_.get_partition(args.db_name, args.tbl_name, args.part_vals);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (NoSuchObjectException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_partition", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_partition");
          oprot.writeMessageBegin(new TMessage("get_partition", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_partition", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_partition_by_name implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_partition_by_name_args args = new get_partition_by_name_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_partition_by_name", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_partition_by_name_result result = new get_partition_by_name_result();
        try {
          result.success = iface_.get_partition_by_name(args.db_name, args.tbl_name, args.part_name);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (NoSuchObjectException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_partition_by_name", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_partition_by_name");
          oprot.writeMessageBegin(new TMessage("get_partition_by_name", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_partition_by_name", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_partitions implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_partitions_args args = new get_partitions_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_partitions", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_partitions_result result = new get_partitions_result();
        try {
          result.success = iface_.get_partitions(args.db_name, args.tbl_name, args.max_parts);
        } catch (NoSuchObjectException o1) {
          result.o1 = o1;
        } catch (MetaException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_partitions", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_partitions");
          oprot.writeMessageBegin(new TMessage("get_partitions", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_partitions", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_partition_names implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_partition_names_args args = new get_partition_names_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_partition_names", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_partition_names_result result = new get_partition_names_result();
        try {
          result.success = iface_.get_partition_names(args.db_name, args.tbl_name, args.max_parts);
        } catch (MetaException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_partition_names", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_partition_names");
          oprot.writeMessageBegin(new TMessage("get_partition_names", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_partition_names", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_partitions_ps implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_partitions_ps_args args = new get_partitions_ps_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_partitions_ps", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_partitions_ps_result result = new get_partitions_ps_result();
        try {
          result.success = iface_.get_partitions_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_partitions_ps", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_partitions_ps");
          oprot.writeMessageBegin(new TMessage("get_partitions_ps", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_partitions_ps", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_partition_names_ps implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_partition_names_ps_args args = new get_partition_names_ps_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_partition_names_ps", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_partition_names_ps_result result = new get_partition_names_ps_result();
        try {
          result.success = iface_.get_partition_names_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_partition_names_ps", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_partition_names_ps");
          oprot.writeMessageBegin(new TMessage("get_partition_names_ps", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_partition_names_ps", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_partitions_by_filter implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_partitions_by_filter_args args = new get_partitions_by_filter_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_partitions_by_filter", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_partitions_by_filter_result result = new get_partitions_by_filter_result();
        try {
          result.success = iface_.get_partitions_by_filter(args.db_name, args.tbl_name, args.filter, args.max_parts);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (NoSuchObjectException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_partitions_by_filter", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_partitions_by_filter");
          oprot.writeMessageBegin(new TMessage("get_partitions_by_filter", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_partitions_by_filter", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class alter_partition implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        alter_partition_args args = new alter_partition_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("alter_partition", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        alter_partition_result result = new alter_partition_result();
        try {
          iface_.alter_partition(args.db_name, args.tbl_name, args.new_part);
        } catch (InvalidOperationException o1) {
          result.o1 = o1;
        } catch (MetaException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing alter_partition", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing alter_partition");
          oprot.writeMessageBegin(new TMessage("alter_partition", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("alter_partition", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_config_value implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_config_value_args args = new get_config_value_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_config_value", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_config_value_result result = new get_config_value_result();
        try {
          result.success = iface_.get_config_value(args.name, args.defaultValue);
        } catch (ConfigValSecurityException o1) {
          result.o1 = o1;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_config_value", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_config_value");
          oprot.writeMessageBegin(new TMessage("get_config_value", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_config_value", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class partition_name_to_vals implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        partition_name_to_vals_args args = new partition_name_to_vals_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("partition_name_to_vals", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        partition_name_to_vals_result result = new partition_name_to_vals_result();
        try {
          result.success = iface_.partition_name_to_vals(args.part_name);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing partition_name_to_vals", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing partition_name_to_vals");
          oprot.writeMessageBegin(new TMessage("partition_name_to_vals", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("partition_name_to_vals", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class partition_name_to_spec implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        partition_name_to_spec_args args = new partition_name_to_spec_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("partition_name_to_spec", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        partition_name_to_spec_result result = new partition_name_to_spec_result();
        try {
          result.success = iface_.partition_name_to_spec(args.part_name);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing partition_name_to_spec", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing partition_name_to_spec");
          oprot.writeMessageBegin(new TMessage("partition_name_to_spec", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("partition_name_to_spec", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class add_index implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        add_index_args args = new add_index_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("add_index", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        add_index_result result = new add_index_result();
        try {
          result.success = iface_.add_index(args.new_index, args.index_table);
        } catch (InvalidObjectException o1) {
          result.o1 = o1;
        } catch (AlreadyExistsException o2) {
          result.o2 = o2;
        } catch (MetaException o3) {
          result.o3 = o3;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing add_index", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing add_index");
          oprot.writeMessageBegin(new TMessage("add_index", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("add_index", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class alter_index implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        alter_index_args args = new alter_index_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("alter_index", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        alter_index_result result = new alter_index_result();
        try {
          iface_.alter_index(args.dbname, args.base_tbl_name, args.idx_name, args.new_idx);
        } catch (InvalidOperationException o1) {
          result.o1 = o1;
        } catch (MetaException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing alter_index", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing alter_index");
          oprot.writeMessageBegin(new TMessage("alter_index", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("alter_index", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class drop_index_by_name implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        drop_index_by_name_args args = new drop_index_by_name_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("drop_index_by_name", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        drop_index_by_name_result result = new drop_index_by_name_result();
        try {
          result.success = iface_.drop_index_by_name(args.db_name, args.tbl_name, args.index_name, args.deleteData);
          result.setSuccessIsSet(true);
        } catch (NoSuchObjectException o1) {
          result.o1 = o1;
        } catch (MetaException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing drop_index_by_name", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing drop_index_by_name");
          oprot.writeMessageBegin(new TMessage("drop_index_by_name", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("drop_index_by_name", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_index_by_name implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_index_by_name_args args = new get_index_by_name_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_index_by_name", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_index_by_name_result result = new get_index_by_name_result();
        try {
          result.success = iface_.get_index_by_name(args.db_name, args.tbl_name, args.index_name);
        } catch (MetaException o1) {
          result.o1 = o1;
        } catch (NoSuchObjectException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_index_by_name", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_index_by_name");
          oprot.writeMessageBegin(new TMessage("get_index_by_name", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_index_by_name", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_indexes implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_indexes_args args = new get_indexes_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_indexes", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_indexes_result result = new get_indexes_result();
        try {
          result.success = iface_.get_indexes(args.db_name, args.tbl_name, args.max_indexes);
        } catch (NoSuchObjectException o1) {
          result.o1 = o1;
        } catch (MetaException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_indexes", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_indexes");
          oprot.writeMessageBegin(new TMessage("get_indexes", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_indexes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_index_names implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_index_names_args args = new get_index_names_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_index_names", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_index_names_result result = new get_index_names_result();
        try {
          result.success = iface_.get_index_names(args.db_name, args.tbl_name, args.max_indexes);
        } catch (MetaException o2) {
          result.o2 = o2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_index_names", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_index_names");
          oprot.writeMessageBegin(new TMessage("get_index_names", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_index_names", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class create_database_args implements TBase<create_database_args, create_database_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("create_database_args");

    private static final TField DATABASE_FIELD_DESC = new TField("database", TType.STRUCT, (short)1);

    private Database database;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DATABASE((short)1, "database");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DATABASE
            return DATABASE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DATABASE, new FieldMetaData("database", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Database.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(create_database_args.class, metaDataMap);
    }

    public create_database_args() {
    }

    public create_database_args(
      Database database)
    {
      this();
      this.database = database;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public create_database_args(create_database_args other) {
      if (other.isSetDatabase()) {
        this.database = new Database(other.database);
      }
    }

    public create_database_args deepCopy() {
      return new create_database_args(this);
    }

    @Override
    public void clear() {
      this.database = null;
    }

    public Database getDatabase() {
      return this.database;
    }

    public void setDatabase(Database database) {
      this.database = database;
    }

    public void unsetDatabase() {
      this.database = null;
    }

    /** Returns true if field database is set (has been asigned a value) and false otherwise */
    public boolean isSetDatabase() {
      return this.database != null;
    }

    public void setDatabaseIsSet(boolean value) {
      if (!value) {
        this.database = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DATABASE:
        if (value == null) {
          unsetDatabase();
        } else {
          setDatabase((Database)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DATABASE:
        return getDatabase();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DATABASE:
        return isSetDatabase();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof create_database_args)
        return this.equals((create_database_args)that);
      return false;
    }

    public boolean equals(create_database_args that) {
      if (that == null)
        return false;

      boolean this_present_database = true && this.isSetDatabase();
      boolean that_present_database = true && that.isSetDatabase();
      if (this_present_database || that_present_database) {
        if (!(this_present_database && that_present_database))
          return false;
        if (!this.database.equals(that.database))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(create_database_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      create_database_args typedOther = (create_database_args)other;

      lastComparison = Boolean.valueOf(isSetDatabase()).compareTo(typedOther.isSetDatabase());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDatabase()) {
        lastComparison = TBaseHelper.compareTo(this.database, typedOther.database);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DATABASE
            if (field.type == TType.STRUCT) {
              this.database = new Database();
              this.database.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.database != null) {
        oprot.writeFieldBegin(DATABASE_FIELD_DESC);
        this.database.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("create_database_args(");
      boolean first = true;

      sb.append("database:");
      if (this.database == null) {
        sb.append("null");
      } else {
        sb.append(this.database);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class create_database_result implements TBase<create_database_result, create_database_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("create_database_result");

    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);
    private static final TField O3_FIELD_DESC = new TField("o3", TType.STRUCT, (short)3);

    private AlreadyExistsException o1;
    private InvalidObjectException o2;
    private MetaException o3;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      O1((short)1, "o1"),
      O2((short)2, "o2"),
      O3((short)3, "o3");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          case 3: // O3
            return O3;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O3, new FieldMetaData("o3", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(create_database_result.class, metaDataMap);
    }

    public create_database_result() {
    }

    public create_database_result(
      AlreadyExistsException o1,
      InvalidObjectException o2,
      MetaException o3)
    {
      this();
      this.o1 = o1;
      this.o2 = o2;
      this.o3 = o3;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public create_database_result(create_database_result other) {
      if (other.isSetO1()) {
        this.o1 = new AlreadyExistsException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new InvalidObjectException(other.o2);
      }
      if (other.isSetO3()) {
        this.o3 = new MetaException(other.o3);
      }
    }

    public create_database_result deepCopy() {
      return new create_database_result(this);
    }

    @Override
    public void clear() {
      this.o1 = null;
      this.o2 = null;
      this.o3 = null;
    }

    public AlreadyExistsException getO1() {
      return this.o1;
    }

    public void setO1(AlreadyExistsException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public InvalidObjectException getO2() {
      return this.o2;
    }

    public void setO2(InvalidObjectException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public MetaException getO3() {
      return this.o3;
    }

    public void setO3(MetaException o3) {
      this.o3 = o3;
    }

    public void unsetO3() {
      this.o3 = null;
    }

    /** Returns true if field o3 is set (has been asigned a value) and false otherwise */
    public boolean isSetO3() {
      return this.o3 != null;
    }

    public void setO3IsSet(boolean value) {
      if (!value) {
        this.o3 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((AlreadyExistsException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((InvalidObjectException)value);
        }
        break;

      case O3:
        if (value == null) {
          unsetO3();
        } else {
          setO3((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case O1:
        return getO1();

      case O2:
        return getO2();

      case O3:
        return getO3();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      case O3:
        return isSetO3();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof create_database_result)
        return this.equals((create_database_result)that);
      return false;
    }

    public boolean equals(create_database_result that) {
      if (that == null)
        return false;

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      boolean this_present_o3 = true && this.isSetO3();
      boolean that_present_o3 = true && that.isSetO3();
      if (this_present_o3 || that_present_o3) {
        if (!(this_present_o3 && that_present_o3))
          return false;
        if (!this.o3.equals(that.o3))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(create_database_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      create_database_result typedOther = (create_database_result)other;

      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO3()).compareTo(typedOther.isSetO3());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO3()) {
        lastComparison = TBaseHelper.compareTo(this.o3, typedOther.o3);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new AlreadyExistsException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new InvalidObjectException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // O3
            if (field.type == TType.STRUCT) {
              this.o3 = new MetaException();
              this.o3.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO3()) {
        oprot.writeFieldBegin(O3_FIELD_DESC);
        this.o3.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("create_database_result(");
      boolean first = true;

      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o3:");
      if (this.o3 == null) {
        sb.append("null");
      } else {
        sb.append(this.o3);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_database_args implements TBase<get_database_args, get_database_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_database_args");

    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);

    private String name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NAME((short)1, "name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NAME
            return NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_database_args.class, metaDataMap);
    }

    public get_database_args() {
    }

    public get_database_args(
      String name)
    {
      this();
      this.name = name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_database_args(get_database_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
    }

    public get_database_args deepCopy() {
      return new get_database_args(this);
    }

    @Override
    public void clear() {
      this.name = null;
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    /** Returns true if field name is set (has been asigned a value) and false otherwise */
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NAME:
        return getName();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NAME:
        return isSetName();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_database_args)
        return this.equals((get_database_args)that);
      return false;
    }

    public boolean equals(get_database_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_database_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_database_args typedOther = (get_database_args)other;

      lastComparison = Boolean.valueOf(isSetName()).compareTo(typedOther.isSetName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetName()) {
        lastComparison = TBaseHelper.compareTo(this.name, typedOther.name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NAME
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_database_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_database_result implements TBase<get_database_result, get_database_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_database_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private Database success;
    private NoSuchObjectException o1;
    private MetaException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Database.class)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_database_result.class, metaDataMap);
    }

    public get_database_result() {
    }

    public get_database_result(
      Database success,
      NoSuchObjectException o1,
      MetaException o2)
    {
      this();
      this.success = success;
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_database_result(get_database_result other) {
      if (other.isSetSuccess()) {
        this.success = new Database(other.success);
      }
      if (other.isSetO1()) {
        this.o1 = new NoSuchObjectException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new MetaException(other.o2);
      }
    }

    public get_database_result deepCopy() {
      return new get_database_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
      this.o2 = null;
    }

    public Database getSuccess() {
      return this.success;
    }

    public void setSuccess(Database success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public NoSuchObjectException getO1() {
      return this.o1;
    }

    public void setO1(NoSuchObjectException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public MetaException getO2() {
      return this.o2;
    }

    public void setO2(MetaException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Database)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((NoSuchObjectException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_database_result)
        return this.equals((get_database_result)that);
      return false;
    }

    public boolean equals(get_database_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_database_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_database_result typedOther = (get_database_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new Database();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new NoSuchObjectException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new MetaException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_database_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_database_args implements TBase<drop_database_args, drop_database_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_database_args");

    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);
    private static final TField DELETE_DATA_FIELD_DESC = new TField("deleteData", TType.BOOL, (short)2);

    private String name;
    private boolean deleteData;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NAME((short)1, "name"),
      DELETE_DATA((short)2, "deleteData");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NAME
            return NAME;
          case 2: // DELETE_DATA
            return DELETE_DATA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __DELETEDATA_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.DELETE_DATA, new FieldMetaData("deleteData", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_database_args.class, metaDataMap);
    }

    public drop_database_args() {
    }

    public drop_database_args(
      String name,
      boolean deleteData)
    {
      this();
      this.name = name;
      this.deleteData = deleteData;
      setDeleteDataIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_database_args(drop_database_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetName()) {
        this.name = other.name;
      }
      this.deleteData = other.deleteData;
    }

    public drop_database_args deepCopy() {
      return new drop_database_args(this);
    }

    @Override
    public void clear() {
      this.name = null;
      setDeleteDataIsSet(false);
      this.deleteData = false;
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    /** Returns true if field name is set (has been asigned a value) and false otherwise */
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public boolean isDeleteData() {
      return this.deleteData;
    }

    public void setDeleteData(boolean deleteData) {
      this.deleteData = deleteData;
      setDeleteDataIsSet(true);
    }

    public void unsetDeleteData() {
      __isset_bit_vector.clear(__DELETEDATA_ISSET_ID);
    }

    /** Returns true if field deleteData is set (has been asigned a value) and false otherwise */
    public boolean isSetDeleteData() {
      return __isset_bit_vector.get(__DELETEDATA_ISSET_ID);
    }

    public void setDeleteDataIsSet(boolean value) {
      __isset_bit_vector.set(__DELETEDATA_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case DELETE_DATA:
        if (value == null) {
          unsetDeleteData();
        } else {
          setDeleteData((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NAME:
        return getName();

      case DELETE_DATA:
        return new Boolean(isDeleteData());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NAME:
        return isSetName();
      case DELETE_DATA:
        return isSetDeleteData();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_database_args)
        return this.equals((drop_database_args)that);
      return false;
    }

    public boolean equals(drop_database_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_deleteData = true;
      boolean that_present_deleteData = true;
      if (this_present_deleteData || that_present_deleteData) {
        if (!(this_present_deleteData && that_present_deleteData))
          return false;
        if (this.deleteData != that.deleteData)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_database_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_database_args typedOther = (drop_database_args)other;

      lastComparison = Boolean.valueOf(isSetName()).compareTo(typedOther.isSetName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetName()) {
        lastComparison = TBaseHelper.compareTo(this.name, typedOther.name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetDeleteData()).compareTo(typedOther.isSetDeleteData());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDeleteData()) {
        lastComparison = TBaseHelper.compareTo(this.deleteData, typedOther.deleteData);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NAME
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // DELETE_DATA
            if (field.type == TType.BOOL) {
              this.deleteData = iprot.readBool();
              setDeleteDataIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(DELETE_DATA_FIELD_DESC);
      oprot.writeBool(this.deleteData);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_database_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("deleteData:");
      sb.append(this.deleteData);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_database_result implements TBase<drop_database_result, drop_database_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_database_result");

    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);
    private static final TField O3_FIELD_DESC = new TField("o3", TType.STRUCT, (short)3);

    private NoSuchObjectException o1;
    private InvalidOperationException o2;
    private MetaException o3;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      O1((short)1, "o1"),
      O2((short)2, "o2"),
      O3((short)3, "o3");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          case 3: // O3
            return O3;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O3, new FieldMetaData("o3", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_database_result.class, metaDataMap);
    }

    public drop_database_result() {
    }

    public drop_database_result(
      NoSuchObjectException o1,
      InvalidOperationException o2,
      MetaException o3)
    {
      this();
      this.o1 = o1;
      this.o2 = o2;
      this.o3 = o3;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_database_result(drop_database_result other) {
      if (other.isSetO1()) {
        this.o1 = new NoSuchObjectException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new InvalidOperationException(other.o2);
      }
      if (other.isSetO3()) {
        this.o3 = new MetaException(other.o3);
      }
    }

    public drop_database_result deepCopy() {
      return new drop_database_result(this);
    }

    @Override
    public void clear() {
      this.o1 = null;
      this.o2 = null;
      this.o3 = null;
    }

    public NoSuchObjectException getO1() {
      return this.o1;
    }

    public void setO1(NoSuchObjectException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public InvalidOperationException getO2() {
      return this.o2;
    }

    public void setO2(InvalidOperationException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public MetaException getO3() {
      return this.o3;
    }

    public void setO3(MetaException o3) {
      this.o3 = o3;
    }

    public void unsetO3() {
      this.o3 = null;
    }

    /** Returns true if field o3 is set (has been asigned a value) and false otherwise */
    public boolean isSetO3() {
      return this.o3 != null;
    }

    public void setO3IsSet(boolean value) {
      if (!value) {
        this.o3 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((NoSuchObjectException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((InvalidOperationException)value);
        }
        break;

      case O3:
        if (value == null) {
          unsetO3();
        } else {
          setO3((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case O1:
        return getO1();

      case O2:
        return getO2();

      case O3:
        return getO3();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      case O3:
        return isSetO3();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_database_result)
        return this.equals((drop_database_result)that);
      return false;
    }

    public boolean equals(drop_database_result that) {
      if (that == null)
        return false;

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      boolean this_present_o3 = true && this.isSetO3();
      boolean that_present_o3 = true && that.isSetO3();
      if (this_present_o3 || that_present_o3) {
        if (!(this_present_o3 && that_present_o3))
          return false;
        if (!this.o3.equals(that.o3))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_database_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_database_result typedOther = (drop_database_result)other;

      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO3()).compareTo(typedOther.isSetO3());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO3()) {
        lastComparison = TBaseHelper.compareTo(this.o3, typedOther.o3);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new NoSuchObjectException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new InvalidOperationException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // O3
            if (field.type == TType.STRUCT) {
              this.o3 = new MetaException();
              this.o3.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO3()) {
        oprot.writeFieldBegin(O3_FIELD_DESC);
        this.o3.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_database_result(");
      boolean first = true;

      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o3:");
      if (this.o3 == null) {
        sb.append("null");
      } else {
        sb.append(this.o3);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_databases_args implements TBase<get_databases_args, get_databases_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_databases_args");

    private static final TField PATTERN_FIELD_DESC = new TField("pattern", TType.STRING, (short)1);

    private String pattern;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PATTERN((short)1, "pattern");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PATTERN
            return PATTERN;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PATTERN, new FieldMetaData("pattern", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_databases_args.class, metaDataMap);
    }

    public get_databases_args() {
    }

    public get_databases_args(
      String pattern)
    {
      this();
      this.pattern = pattern;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_databases_args(get_databases_args other) {
      if (other.isSetPattern()) {
        this.pattern = other.pattern;
      }
    }

    public get_databases_args deepCopy() {
      return new get_databases_args(this);
    }

    @Override
    public void clear() {
      this.pattern = null;
    }

    public String getPattern() {
      return this.pattern;
    }

    public void setPattern(String pattern) {
      this.pattern = pattern;
    }

    public void unsetPattern() {
      this.pattern = null;
    }

    /** Returns true if field pattern is set (has been asigned a value) and false otherwise */
    public boolean isSetPattern() {
      return this.pattern != null;
    }

    public void setPatternIsSet(boolean value) {
      if (!value) {
        this.pattern = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PATTERN:
        if (value == null) {
          unsetPattern();
        } else {
          setPattern((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PATTERN:
        return getPattern();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PATTERN:
        return isSetPattern();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_databases_args)
        return this.equals((get_databases_args)that);
      return false;
    }

    public boolean equals(get_databases_args that) {
      if (that == null)
        return false;

      boolean this_present_pattern = true && this.isSetPattern();
      boolean that_present_pattern = true && that.isSetPattern();
      if (this_present_pattern || that_present_pattern) {
        if (!(this_present_pattern && that_present_pattern))
          return false;
        if (!this.pattern.equals(that.pattern))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_databases_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_databases_args typedOther = (get_databases_args)other;

      lastComparison = Boolean.valueOf(isSetPattern()).compareTo(typedOther.isSetPattern());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPattern()) {
        lastComparison = TBaseHelper.compareTo(this.pattern, typedOther.pattern);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PATTERN
            if (field.type == TType.STRING) {
              this.pattern = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.pattern != null) {
        oprot.writeFieldBegin(PATTERN_FIELD_DESC);
        oprot.writeString(this.pattern);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_databases_args(");
      boolean first = true;

      sb.append("pattern:");
      if (this.pattern == null) {
        sb.append("null");
      } else {
        sb.append(this.pattern);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_databases_result implements TBase<get_databases_result, get_databases_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_databases_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);

    private List<String> success;
    private MetaException o1;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_databases_result.class, metaDataMap);
    }

    public get_databases_result() {
    }

    public get_databases_result(
      List<String> success,
      MetaException o1)
    {
      this();
      this.success = success;
      this.o1 = o1;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_databases_result(get_databases_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
    }

    public get_databases_result deepCopy() {
      return new get_databases_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<String> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_databases_result)
        return this.equals((get_databases_result)that);
      return false;
    }

    public boolean equals(get_databases_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_databases_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_databases_result typedOther = (get_databases_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list63 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list63.size);
                for (int _i64 = 0; _i64 < _list63.size; ++_i64)
                {
                  String _elem65;
                  _elem65 = iprot.readString();
                  this.success.add(_elem65);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter66 : this.success)
          {
            oprot.writeString(_iter66);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_databases_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_all_databases_args implements TBase<get_all_databases_args, get_all_databases_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_all_databases_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_all_databases_args.class, metaDataMap);
    }

    public get_all_databases_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_all_databases_args(get_all_databases_args other) {
    }

    public get_all_databases_args deepCopy() {
      return new get_all_databases_args(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_all_databases_args)
        return this.equals((get_all_databases_args)that);
      return false;
    }

    public boolean equals(get_all_databases_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_all_databases_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_all_databases_args typedOther = (get_all_databases_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_all_databases_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_all_databases_result implements TBase<get_all_databases_result, get_all_databases_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_all_databases_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);

    private List<String> success;
    private MetaException o1;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_all_databases_result.class, metaDataMap);
    }

    public get_all_databases_result() {
    }

    public get_all_databases_result(
      List<String> success,
      MetaException o1)
    {
      this();
      this.success = success;
      this.o1 = o1;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_all_databases_result(get_all_databases_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
    }

    public get_all_databases_result deepCopy() {
      return new get_all_databases_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<String> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_all_databases_result)
        return this.equals((get_all_databases_result)that);
      return false;
    }

    public boolean equals(get_all_databases_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_all_databases_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_all_databases_result typedOther = (get_all_databases_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list67 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list67.size);
                for (int _i68 = 0; _i68 < _list67.size; ++_i68)
                {
                  String _elem69;
                  _elem69 = iprot.readString();
                  this.success.add(_elem69);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter70 : this.success)
          {
            oprot.writeString(_iter70);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_all_databases_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_type_args implements TBase<get_type_args, get_type_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_type_args");

    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);

    private String name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NAME((short)1, "name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NAME
            return NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_type_args.class, metaDataMap);
    }

    public get_type_args() {
    }

    public get_type_args(
      String name)
    {
      this();
      this.name = name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_type_args(get_type_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
    }

    public get_type_args deepCopy() {
      return new get_type_args(this);
    }

    @Override
    public void clear() {
      this.name = null;
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    /** Returns true if field name is set (has been asigned a value) and false otherwise */
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NAME:
        return getName();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NAME:
        return isSetName();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_type_args)
        return this.equals((get_type_args)that);
      return false;
    }

    public boolean equals(get_type_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_type_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_type_args typedOther = (get_type_args)other;

      lastComparison = Boolean.valueOf(isSetName()).compareTo(typedOther.isSetName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetName()) {
        lastComparison = TBaseHelper.compareTo(this.name, typedOther.name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NAME
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_type_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_type_result implements TBase<get_type_result, get_type_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_type_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private Type success;
    private MetaException o1;
    private NoSuchObjectException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Type.class)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_type_result.class, metaDataMap);
    }

    public get_type_result() {
    }

    public get_type_result(
      Type success,
      MetaException o1,
      NoSuchObjectException o2)
    {
      this();
      this.success = success;
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_type_result(get_type_result other) {
      if (other.isSetSuccess()) {
        this.success = new Type(other.success);
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new NoSuchObjectException(other.o2);
      }
    }

    public get_type_result deepCopy() {
      return new get_type_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
      this.o2 = null;
    }

    public Type getSuccess() {
      return this.success;
    }

    public void setSuccess(Type success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public NoSuchObjectException getO2() {
      return this.o2;
    }

    public void setO2(NoSuchObjectException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Type)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((NoSuchObjectException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_type_result)
        return this.equals((get_type_result)that);
      return false;
    }

    public boolean equals(get_type_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_type_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_type_result typedOther = (get_type_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new Type();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new NoSuchObjectException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_type_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class create_type_args implements TBase<create_type_args, create_type_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("create_type_args");

    private static final TField TYPE_FIELD_DESC = new TField("type", TType.STRUCT, (short)1);

    private Type type;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TYPE((short)1, "type");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TYPE
            return TYPE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TYPE, new FieldMetaData("type", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Type.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(create_type_args.class, metaDataMap);
    }

    public create_type_args() {
    }

    public create_type_args(
      Type type)
    {
      this();
      this.type = type;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public create_type_args(create_type_args other) {
      if (other.isSetType()) {
        this.type = new Type(other.type);
      }
    }

    public create_type_args deepCopy() {
      return new create_type_args(this);
    }

    @Override
    public void clear() {
      this.type = null;
    }

    public Type getType() {
      return this.type;
    }

    public void setType(Type type) {
      this.type = type;
    }

    public void unsetType() {
      this.type = null;
    }

    /** Returns true if field type is set (has been asigned a value) and false otherwise */
    public boolean isSetType() {
      return this.type != null;
    }

    public void setTypeIsSet(boolean value) {
      if (!value) {
        this.type = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TYPE:
        if (value == null) {
          unsetType();
        } else {
          setType((Type)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TYPE:
        return getType();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TYPE:
        return isSetType();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof create_type_args)
        return this.equals((create_type_args)that);
      return false;
    }

    public boolean equals(create_type_args that) {
      if (that == null)
        return false;

      boolean this_present_type = true && this.isSetType();
      boolean that_present_type = true && that.isSetType();
      if (this_present_type || that_present_type) {
        if (!(this_present_type && that_present_type))
          return false;
        if (!this.type.equals(that.type))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(create_type_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      create_type_args typedOther = (create_type_args)other;

      lastComparison = Boolean.valueOf(isSetType()).compareTo(typedOther.isSetType());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetType()) {
        lastComparison = TBaseHelper.compareTo(this.type, typedOther.type);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // TYPE
            if (field.type == TType.STRUCT) {
              this.type = new Type();
              this.type.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.type != null) {
        oprot.writeFieldBegin(TYPE_FIELD_DESC);
        this.type.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("create_type_args(");
      boolean first = true;

      sb.append("type:");
      if (this.type == null) {
        sb.append("null");
      } else {
        sb.append(this.type);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class create_type_result implements TBase<create_type_result, create_type_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("create_type_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);
    private static final TField O3_FIELD_DESC = new TField("o3", TType.STRUCT, (short)3);

    private boolean success;
    private AlreadyExistsException o1;
    private InvalidObjectException o2;
    private MetaException o3;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2"),
      O3((short)3, "o3");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          case 3: // O3
            return O3;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O3, new FieldMetaData("o3", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(create_type_result.class, metaDataMap);
    }

    public create_type_result() {
    }

    public create_type_result(
      boolean success,
      AlreadyExistsException o1,
      InvalidObjectException o2,
      MetaException o3)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.o1 = o1;
      this.o2 = o2;
      this.o3 = o3;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public create_type_result(create_type_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetO1()) {
        this.o1 = new AlreadyExistsException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new InvalidObjectException(other.o2);
      }
      if (other.isSetO3()) {
        this.o3 = new MetaException(other.o3);
      }
    }

    public create_type_result deepCopy() {
      return new create_type_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
      this.o1 = null;
      this.o2 = null;
      this.o3 = null;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public AlreadyExistsException getO1() {
      return this.o1;
    }

    public void setO1(AlreadyExistsException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public InvalidObjectException getO2() {
      return this.o2;
    }

    public void setO2(InvalidObjectException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public MetaException getO3() {
      return this.o3;
    }

    public void setO3(MetaException o3) {
      this.o3 = o3;
    }

    public void unsetO3() {
      this.o3 = null;
    }

    /** Returns true if field o3 is set (has been asigned a value) and false otherwise */
    public boolean isSetO3() {
      return this.o3 != null;
    }

    public void setO3IsSet(boolean value) {
      if (!value) {
        this.o3 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((AlreadyExistsException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((InvalidObjectException)value);
        }
        break;

      case O3:
        if (value == null) {
          unsetO3();
        } else {
          setO3((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case O1:
        return getO1();

      case O2:
        return getO2();

      case O3:
        return getO3();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      case O3:
        return isSetO3();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof create_type_result)
        return this.equals((create_type_result)that);
      return false;
    }

    public boolean equals(create_type_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      boolean this_present_o3 = true && this.isSetO3();
      boolean that_present_o3 = true && that.isSetO3();
      if (this_present_o3 || that_present_o3) {
        if (!(this_present_o3 && that_present_o3))
          return false;
        if (!this.o3.equals(that.o3))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(create_type_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      create_type_result typedOther = (create_type_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO3()).compareTo(typedOther.isSetO3());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO3()) {
        lastComparison = TBaseHelper.compareTo(this.o3, typedOther.o3);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new AlreadyExistsException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new InvalidObjectException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // O3
            if (field.type == TType.STRUCT) {
              this.o3 = new MetaException();
              this.o3.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO3()) {
        oprot.writeFieldBegin(O3_FIELD_DESC);
        this.o3.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("create_type_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o3:");
      if (this.o3 == null) {
        sb.append("null");
      } else {
        sb.append(this.o3);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_type_args implements TBase<drop_type_args, drop_type_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_type_args");

    private static final TField TYPE_FIELD_DESC = new TField("type", TType.STRING, (short)1);

    private String type;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TYPE((short)1, "type");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TYPE
            return TYPE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TYPE, new FieldMetaData("type", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_type_args.class, metaDataMap);
    }

    public drop_type_args() {
    }

    public drop_type_args(
      String type)
    {
      this();
      this.type = type;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_type_args(drop_type_args other) {
      if (other.isSetType()) {
        this.type = other.type;
      }
    }

    public drop_type_args deepCopy() {
      return new drop_type_args(this);
    }

    @Override
    public void clear() {
      this.type = null;
    }

    public String getType() {
      return this.type;
    }

    public void setType(String type) {
      this.type = type;
    }

    public void unsetType() {
      this.type = null;
    }

    /** Returns true if field type is set (has been asigned a value) and false otherwise */
    public boolean isSetType() {
      return this.type != null;
    }

    public void setTypeIsSet(boolean value) {
      if (!value) {
        this.type = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TYPE:
        if (value == null) {
          unsetType();
        } else {
          setType((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TYPE:
        return getType();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TYPE:
        return isSetType();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_type_args)
        return this.equals((drop_type_args)that);
      return false;
    }

    public boolean equals(drop_type_args that) {
      if (that == null)
        return false;

      boolean this_present_type = true && this.isSetType();
      boolean that_present_type = true && that.isSetType();
      if (this_present_type || that_present_type) {
        if (!(this_present_type && that_present_type))
          return false;
        if (!this.type.equals(that.type))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_type_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_type_args typedOther = (drop_type_args)other;

      lastComparison = Boolean.valueOf(isSetType()).compareTo(typedOther.isSetType());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetType()) {
        lastComparison = TBaseHelper.compareTo(this.type, typedOther.type);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // TYPE
            if (field.type == TType.STRING) {
              this.type = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.type != null) {
        oprot.writeFieldBegin(TYPE_FIELD_DESC);
        oprot.writeString(this.type);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_type_args(");
      boolean first = true;

      sb.append("type:");
      if (this.type == null) {
        sb.append("null");
      } else {
        sb.append(this.type);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_type_result implements TBase<drop_type_result, drop_type_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_type_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private boolean success;
    private MetaException o1;
    private NoSuchObjectException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_type_result.class, metaDataMap);
    }

    public drop_type_result() {
    }

    public drop_type_result(
      boolean success,
      MetaException o1,
      NoSuchObjectException o2)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_type_result(drop_type_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new NoSuchObjectException(other.o2);
      }
    }

    public drop_type_result deepCopy() {
      return new drop_type_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
      this.o1 = null;
      this.o2 = null;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public NoSuchObjectException getO2() {
      return this.o2;
    }

    public void setO2(NoSuchObjectException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((NoSuchObjectException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_type_result)
        return this.equals((drop_type_result)that);
      return false;
    }

    public boolean equals(drop_type_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_type_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_type_result typedOther = (drop_type_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new NoSuchObjectException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_type_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_type_all_args implements TBase<get_type_all_args, get_type_all_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_type_all_args");

    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);

    private String name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NAME((short)1, "name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NAME
            return NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_type_all_args.class, metaDataMap);
    }

    public get_type_all_args() {
    }

    public get_type_all_args(
      String name)
    {
      this();
      this.name = name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_type_all_args(get_type_all_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
    }

    public get_type_all_args deepCopy() {
      return new get_type_all_args(this);
    }

    @Override
    public void clear() {
      this.name = null;
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    /** Returns true if field name is set (has been asigned a value) and false otherwise */
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NAME:
        return getName();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NAME:
        return isSetName();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_type_all_args)
        return this.equals((get_type_all_args)that);
      return false;
    }

    public boolean equals(get_type_all_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_type_all_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_type_all_args typedOther = (get_type_all_args)other;

      lastComparison = Boolean.valueOf(isSetName()).compareTo(typedOther.isSetName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetName()) {
        lastComparison = TBaseHelper.compareTo(this.name, typedOther.name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NAME
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_type_all_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_type_all_result implements TBase<get_type_all_result, get_type_all_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_type_all_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)1);

    private Map<String,Type> success;
    private MetaException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O2((short)1, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new StructMetaData(TType.STRUCT, Type.class))));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_type_all_result.class, metaDataMap);
    }

    public get_type_all_result() {
    }

    public get_type_all_result(
      Map<String,Type> success,
      MetaException o2)
    {
      this();
      this.success = success;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_type_all_result(get_type_all_result other) {
      if (other.isSetSuccess()) {
        Map<String,Type> __this__success = new HashMap<String,Type>();
        for (Map.Entry<String, Type> other_element : other.success.entrySet()) {

          String other_element_key = other_element.getKey();
          Type other_element_value = other_element.getValue();

          String __this__success_copy_key = other_element_key;

          Type __this__success_copy_value = new Type(other_element_value);

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
      if (other.isSetO2()) {
        this.o2 = new MetaException(other.o2);
      }
    }

    public get_type_all_result deepCopy() {
      return new get_type_all_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o2 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(String key, Type val) {
      if (this.success == null) {
        this.success = new HashMap<String,Type>();
      }
      this.success.put(key, val);
    }

    public Map<String,Type> getSuccess() {
      return this.success;
    }

    public void setSuccess(Map<String,Type> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO2() {
      return this.o2;
    }

    public void setO2(MetaException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<String,Type>)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_type_all_result)
        return this.equals((get_type_all_result)that);
      return false;
    }

    public boolean equals(get_type_all_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_type_all_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_type_all_result typedOther = (get_type_all_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.MAP) {
              {
                TMap _map71 = iprot.readMapBegin();
                this.success = new HashMap<String,Type>(2*_map71.size);
                for (int _i72 = 0; _i72 < _map71.size; ++_i72)
                {
                  String _key73;
                  Type _val74;
                  _key73 = iprot.readString();
                  _val74 = new Type();
                  _val74.read(iprot);
                  this.success.put(_key73, _val74);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new MetaException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.size()));
          for (Map.Entry<String, Type> _iter75 : this.success.entrySet())
          {
            oprot.writeString(_iter75.getKey());
            _iter75.getValue().write(oprot);
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_type_all_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_fields_args implements TBase<get_fields_args, get_fields_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_fields_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);

    private String db_name;
    private String table_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TABLE_NAME((short)2, "table_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_fields_args.class, metaDataMap);
    }

    public get_fields_args() {
    }

    public get_fields_args(
      String db_name,
      String table_name)
    {
      this();
      this.db_name = db_name;
      this.table_name = table_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_fields_args(get_fields_args other) {
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
    }

    public get_fields_args deepCopy() {
      return new get_fields_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.table_name = null;
    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTable_name() {
      return this.table_name;
    }

    public void setTable_name(String table_name) {
      this.table_name = table_name;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TABLE_NAME:
        return getTable_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TABLE_NAME:
        return isSetTable_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_fields_args)
        return this.equals((get_fields_args)that);
      return false;
    }

    public boolean equals(get_fields_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_fields_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_fields_args typedOther = (get_fields_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_fields_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_fields_result implements TBase<get_fields_result, get_fields_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_fields_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);
    private static final TField O3_FIELD_DESC = new TField("o3", TType.STRUCT, (short)3);

    private List<FieldSchema> success;
    private MetaException o1;
    private UnknownTableException o2;
    private UnknownDBException o3;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2"),
      O3((short)3, "o3");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          case 3: // O3
            return O3;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, FieldSchema.class))));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O3, new FieldMetaData("o3", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_fields_result.class, metaDataMap);
    }

    public get_fields_result() {
    }

    public get_fields_result(
      List<FieldSchema> success,
      MetaException o1,
      UnknownTableException o2,
      UnknownDBException o3)
    {
      this();
      this.success = success;
      this.o1 = o1;
      this.o2 = o2;
      this.o3 = o3;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_fields_result(get_fields_result other) {
      if (other.isSetSuccess()) {
        List<FieldSchema> __this__success = new ArrayList<FieldSchema>();
        for (FieldSchema other_element : other.success) {
          __this__success.add(new FieldSchema(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new UnknownTableException(other.o2);
      }
      if (other.isSetO3()) {
        this.o3 = new UnknownDBException(other.o3);
      }
    }

    public get_fields_result deepCopy() {
      return new get_fields_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
      this.o2 = null;
      this.o3 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<FieldSchema> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(FieldSchema elem) {
      if (this.success == null) {
        this.success = new ArrayList<FieldSchema>();
      }
      this.success.add(elem);
    }

    public List<FieldSchema> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<FieldSchema> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public UnknownTableException getO2() {
      return this.o2;
    }

    public void setO2(UnknownTableException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public UnknownDBException getO3() {
      return this.o3;
    }

    public void setO3(UnknownDBException o3) {
      this.o3 = o3;
    }

    public void unsetO3() {
      this.o3 = null;
    }

    /** Returns true if field o3 is set (has been asigned a value) and false otherwise */
    public boolean isSetO3() {
      return this.o3 != null;
    }

    public void setO3IsSet(boolean value) {
      if (!value) {
        this.o3 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<FieldSchema>)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((UnknownTableException)value);
        }
        break;

      case O3:
        if (value == null) {
          unsetO3();
        } else {
          setO3((UnknownDBException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      case O2:
        return getO2();

      case O3:
        return getO3();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      case O3:
        return isSetO3();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_fields_result)
        return this.equals((get_fields_result)that);
      return false;
    }

    public boolean equals(get_fields_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      boolean this_present_o3 = true && this.isSetO3();
      boolean that_present_o3 = true && that.isSetO3();
      if (this_present_o3 || that_present_o3) {
        if (!(this_present_o3 && that_present_o3))
          return false;
        if (!this.o3.equals(that.o3))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_fields_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_fields_result typedOther = (get_fields_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO3()).compareTo(typedOther.isSetO3());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO3()) {
        lastComparison = TBaseHelper.compareTo(this.o3, typedOther.o3);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list76 = iprot.readListBegin();
                this.success = new ArrayList<FieldSchema>(_list76.size);
                for (int _i77 = 0; _i77 < _list76.size; ++_i77)
                {
                  FieldSchema _elem78;
                  _elem78 = new FieldSchema();
                  _elem78.read(iprot);
                  this.success.add(_elem78);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new UnknownTableException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // O3
            if (field.type == TType.STRUCT) {
              this.o3 = new UnknownDBException();
              this.o3.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (FieldSchema _iter79 : this.success)
          {
            _iter79.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO3()) {
        oprot.writeFieldBegin(O3_FIELD_DESC);
        this.o3.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_fields_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o3:");
      if (this.o3 == null) {
        sb.append("null");
      } else {
        sb.append(this.o3);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_schema_args implements TBase<get_schema_args, get_schema_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_schema_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);

    private String db_name;
    private String table_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TABLE_NAME((short)2, "table_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_schema_args.class, metaDataMap);
    }

    public get_schema_args() {
    }

    public get_schema_args(
      String db_name,
      String table_name)
    {
      this();
      this.db_name = db_name;
      this.table_name = table_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_schema_args(get_schema_args other) {
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
    }

    public get_schema_args deepCopy() {
      return new get_schema_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.table_name = null;
    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTable_name() {
      return this.table_name;
    }

    public void setTable_name(String table_name) {
      this.table_name = table_name;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TABLE_NAME:
        return getTable_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TABLE_NAME:
        return isSetTable_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_schema_args)
        return this.equals((get_schema_args)that);
      return false;
    }

    public boolean equals(get_schema_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_schema_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_schema_args typedOther = (get_schema_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_schema_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_schema_result implements TBase<get_schema_result, get_schema_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_schema_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);
    private static final TField O3_FIELD_DESC = new TField("o3", TType.STRUCT, (short)3);

    private List<FieldSchema> success;
    private MetaException o1;
    private UnknownTableException o2;
    private UnknownDBException o3;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2"),
      O3((short)3, "o3");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          case 3: // O3
            return O3;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, FieldSchema.class))));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O3, new FieldMetaData("o3", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_schema_result.class, metaDataMap);
    }

    public get_schema_result() {
    }

    public get_schema_result(
      List<FieldSchema> success,
      MetaException o1,
      UnknownTableException o2,
      UnknownDBException o3)
    {
      this();
      this.success = success;
      this.o1 = o1;
      this.o2 = o2;
      this.o3 = o3;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_schema_result(get_schema_result other) {
      if (other.isSetSuccess()) {
        List<FieldSchema> __this__success = new ArrayList<FieldSchema>();
        for (FieldSchema other_element : other.success) {
          __this__success.add(new FieldSchema(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new UnknownTableException(other.o2);
      }
      if (other.isSetO3()) {
        this.o3 = new UnknownDBException(other.o3);
      }
    }

    public get_schema_result deepCopy() {
      return new get_schema_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
      this.o2 = null;
      this.o3 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<FieldSchema> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(FieldSchema elem) {
      if (this.success == null) {
        this.success = new ArrayList<FieldSchema>();
      }
      this.success.add(elem);
    }

    public List<FieldSchema> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<FieldSchema> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public UnknownTableException getO2() {
      return this.o2;
    }

    public void setO2(UnknownTableException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public UnknownDBException getO3() {
      return this.o3;
    }

    public void setO3(UnknownDBException o3) {
      this.o3 = o3;
    }

    public void unsetO3() {
      this.o3 = null;
    }

    /** Returns true if field o3 is set (has been asigned a value) and false otherwise */
    public boolean isSetO3() {
      return this.o3 != null;
    }

    public void setO3IsSet(boolean value) {
      if (!value) {
        this.o3 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<FieldSchema>)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((UnknownTableException)value);
        }
        break;

      case O3:
        if (value == null) {
          unsetO3();
        } else {
          setO3((UnknownDBException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      case O2:
        return getO2();

      case O3:
        return getO3();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      case O3:
        return isSetO3();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_schema_result)
        return this.equals((get_schema_result)that);
      return false;
    }

    public boolean equals(get_schema_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      boolean this_present_o3 = true && this.isSetO3();
      boolean that_present_o3 = true && that.isSetO3();
      if (this_present_o3 || that_present_o3) {
        if (!(this_present_o3 && that_present_o3))
          return false;
        if (!this.o3.equals(that.o3))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_schema_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_schema_result typedOther = (get_schema_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO3()).compareTo(typedOther.isSetO3());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO3()) {
        lastComparison = TBaseHelper.compareTo(this.o3, typedOther.o3);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list80 = iprot.readListBegin();
                this.success = new ArrayList<FieldSchema>(_list80.size);
                for (int _i81 = 0; _i81 < _list80.size; ++_i81)
                {
                  FieldSchema _elem82;
                  _elem82 = new FieldSchema();
                  _elem82.read(iprot);
                  this.success.add(_elem82);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new UnknownTableException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // O3
            if (field.type == TType.STRUCT) {
              this.o3 = new UnknownDBException();
              this.o3.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (FieldSchema _iter83 : this.success)
          {
            _iter83.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO3()) {
        oprot.writeFieldBegin(O3_FIELD_DESC);
        this.o3.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_schema_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o3:");
      if (this.o3 == null) {
        sb.append("null");
      } else {
        sb.append(this.o3);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class create_table_args implements TBase<create_table_args, create_table_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("create_table_args");

    private static final TField TBL_FIELD_DESC = new TField("tbl", TType.STRUCT, (short)1);

    private Table tbl;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TBL((short)1, "tbl");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TBL
            return TBL;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TBL, new FieldMetaData("tbl", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Table.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(create_table_args.class, metaDataMap);
    }

    public create_table_args() {
    }

    public create_table_args(
      Table tbl)
    {
      this();
      this.tbl = tbl;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public create_table_args(create_table_args other) {
      if (other.isSetTbl()) {
        this.tbl = new Table(other.tbl);
      }
    }

    public create_table_args deepCopy() {
      return new create_table_args(this);
    }

    @Override
    public void clear() {
      this.tbl = null;
    }

    public Table getTbl() {
      return this.tbl;
    }

    public void setTbl(Table tbl) {
      this.tbl = tbl;
    }

    public void unsetTbl() {
      this.tbl = null;
    }

    /** Returns true if field tbl is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl() {
      return this.tbl != null;
    }

    public void setTblIsSet(boolean value) {
      if (!value) {
        this.tbl = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TBL:
        if (value == null) {
          unsetTbl();
        } else {
          setTbl((Table)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TBL:
        return getTbl();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TBL:
        return isSetTbl();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof create_table_args)
        return this.equals((create_table_args)that);
      return false;
    }

    public boolean equals(create_table_args that) {
      if (that == null)
        return false;

      boolean this_present_tbl = true && this.isSetTbl();
      boolean that_present_tbl = true && that.isSetTbl();
      if (this_present_tbl || that_present_tbl) {
        if (!(this_present_tbl && that_present_tbl))
          return false;
        if (!this.tbl.equals(that.tbl))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(create_table_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      create_table_args typedOther = (create_table_args)other;

      lastComparison = Boolean.valueOf(isSetTbl()).compareTo(typedOther.isSetTbl());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl()) {
        lastComparison = TBaseHelper.compareTo(this.tbl, typedOther.tbl);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // TBL
            if (field.type == TType.STRUCT) {
              this.tbl = new Table();
              this.tbl.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tbl != null) {
        oprot.writeFieldBegin(TBL_FIELD_DESC);
        this.tbl.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("create_table_args(");
      boolean first = true;

      sb.append("tbl:");
      if (this.tbl == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class create_table_result implements TBase<create_table_result, create_table_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("create_table_result");

    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);
    private static final TField O3_FIELD_DESC = new TField("o3", TType.STRUCT, (short)3);
    private static final TField O4_FIELD_DESC = new TField("o4", TType.STRUCT, (short)4);

    private AlreadyExistsException o1;
    private InvalidObjectException o2;
    private MetaException o3;
    private NoSuchObjectException o4;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      O1((short)1, "o1"),
      O2((short)2, "o2"),
      O3((short)3, "o3"),
      O4((short)4, "o4");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          case 3: // O3
            return O3;
          case 4: // O4
            return O4;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O3, new FieldMetaData("o3", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O4, new FieldMetaData("o4", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(create_table_result.class, metaDataMap);
    }

    public create_table_result() {
    }

    public create_table_result(
      AlreadyExistsException o1,
      InvalidObjectException o2,
      MetaException o3,
      NoSuchObjectException o4)
    {
      this();
      this.o1 = o1;
      this.o2 = o2;
      this.o3 = o3;
      this.o4 = o4;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public create_table_result(create_table_result other) {
      if (other.isSetO1()) {
        this.o1 = new AlreadyExistsException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new InvalidObjectException(other.o2);
      }
      if (other.isSetO3()) {
        this.o3 = new MetaException(other.o3);
      }
      if (other.isSetO4()) {
        this.o4 = new NoSuchObjectException(other.o4);
      }
    }

    public create_table_result deepCopy() {
      return new create_table_result(this);
    }

    @Override
    public void clear() {
      this.o1 = null;
      this.o2 = null;
      this.o3 = null;
      this.o4 = null;
    }

    public AlreadyExistsException getO1() {
      return this.o1;
    }

    public void setO1(AlreadyExistsException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public InvalidObjectException getO2() {
      return this.o2;
    }

    public void setO2(InvalidObjectException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public MetaException getO3() {
      return this.o3;
    }

    public void setO3(MetaException o3) {
      this.o3 = o3;
    }

    public void unsetO3() {
      this.o3 = null;
    }

    /** Returns true if field o3 is set (has been asigned a value) and false otherwise */
    public boolean isSetO3() {
      return this.o3 != null;
    }

    public void setO3IsSet(boolean value) {
      if (!value) {
        this.o3 = null;
      }
    }

    public NoSuchObjectException getO4() {
      return this.o4;
    }

    public void setO4(NoSuchObjectException o4) {
      this.o4 = o4;
    }

    public void unsetO4() {
      this.o4 = null;
    }

    /** Returns true if field o4 is set (has been asigned a value) and false otherwise */
    public boolean isSetO4() {
      return this.o4 != null;
    }

    public void setO4IsSet(boolean value) {
      if (!value) {
        this.o4 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((AlreadyExistsException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((InvalidObjectException)value);
        }
        break;

      case O3:
        if (value == null) {
          unsetO3();
        } else {
          setO3((MetaException)value);
        }
        break;

      case O4:
        if (value == null) {
          unsetO4();
        } else {
          setO4((NoSuchObjectException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case O1:
        return getO1();

      case O2:
        return getO2();

      case O3:
        return getO3();

      case O4:
        return getO4();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      case O3:
        return isSetO3();
      case O4:
        return isSetO4();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof create_table_result)
        return this.equals((create_table_result)that);
      return false;
    }

    public boolean equals(create_table_result that) {
      if (that == null)
        return false;

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      boolean this_present_o3 = true && this.isSetO3();
      boolean that_present_o3 = true && that.isSetO3();
      if (this_present_o3 || that_present_o3) {
        if (!(this_present_o3 && that_present_o3))
          return false;
        if (!this.o3.equals(that.o3))
          return false;
      }

      boolean this_present_o4 = true && this.isSetO4();
      boolean that_present_o4 = true && that.isSetO4();
      if (this_present_o4 || that_present_o4) {
        if (!(this_present_o4 && that_present_o4))
          return false;
        if (!this.o4.equals(that.o4))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(create_table_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      create_table_result typedOther = (create_table_result)other;

      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO3()).compareTo(typedOther.isSetO3());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO3()) {
        lastComparison = TBaseHelper.compareTo(this.o3, typedOther.o3);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO4()).compareTo(typedOther.isSetO4());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO4()) {
        lastComparison = TBaseHelper.compareTo(this.o4, typedOther.o4);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new AlreadyExistsException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new InvalidObjectException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // O3
            if (field.type == TType.STRUCT) {
              this.o3 = new MetaException();
              this.o3.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // O4
            if (field.type == TType.STRUCT) {
              this.o4 = new NoSuchObjectException();
              this.o4.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO3()) {
        oprot.writeFieldBegin(O3_FIELD_DESC);
        this.o3.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO4()) {
        oprot.writeFieldBegin(O4_FIELD_DESC);
        this.o4.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("create_table_result(");
      boolean first = true;

      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o3:");
      if (this.o3 == null) {
        sb.append("null");
      } else {
        sb.append(this.o3);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o4:");
      if (this.o4 == null) {
        sb.append("null");
      } else {
        sb.append(this.o4);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_table_args implements TBase<drop_table_args, drop_table_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_table_args");

    private static final TField DBNAME_FIELD_DESC = new TField("dbname", TType.STRING, (short)1);
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)2);
    private static final TField DELETE_DATA_FIELD_DESC = new TField("deleteData", TType.BOOL, (short)3);

    private String dbname;
    private String name;
    private boolean deleteData;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DBNAME((short)1, "dbname"),
      NAME((short)2, "name"),
      DELETE_DATA((short)3, "deleteData");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DBNAME
            return DBNAME;
          case 2: // NAME
            return NAME;
          case 3: // DELETE_DATA
            return DELETE_DATA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __DELETEDATA_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DBNAME, new FieldMetaData("dbname", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.DELETE_DATA, new FieldMetaData("deleteData", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_table_args.class, metaDataMap);
    }

    public drop_table_args() {
    }

    public drop_table_args(
      String dbname,
      String name,
      boolean deleteData)
    {
      this();
      this.dbname = dbname;
      this.name = name;
      this.deleteData = deleteData;
      setDeleteDataIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_table_args(drop_table_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetDbname()) {
        this.dbname = other.dbname;
      }
      if (other.isSetName()) {
        this.name = other.name;
      }
      this.deleteData = other.deleteData;
    }

    public drop_table_args deepCopy() {
      return new drop_table_args(this);
    }

    @Override
    public void clear() {
      this.dbname = null;
      this.name = null;
      setDeleteDataIsSet(false);
      this.deleteData = false;
    }

    public String getDbname() {
      return this.dbname;
    }

    public void setDbname(String dbname) {
      this.dbname = dbname;
    }

    public void unsetDbname() {
      this.dbname = null;
    }

    /** Returns true if field dbname is set (has been asigned a value) and false otherwise */
    public boolean isSetDbname() {
      return this.dbname != null;
    }

    public void setDbnameIsSet(boolean value) {
      if (!value) {
        this.dbname = null;
      }
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    /** Returns true if field name is set (has been asigned a value) and false otherwise */
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public boolean isDeleteData() {
      return this.deleteData;
    }

    public void setDeleteData(boolean deleteData) {
      this.deleteData = deleteData;
      setDeleteDataIsSet(true);
    }

    public void unsetDeleteData() {
      __isset_bit_vector.clear(__DELETEDATA_ISSET_ID);
    }

    /** Returns true if field deleteData is set (has been asigned a value) and false otherwise */
    public boolean isSetDeleteData() {
      return __isset_bit_vector.get(__DELETEDATA_ISSET_ID);
    }

    public void setDeleteDataIsSet(boolean value) {
      __isset_bit_vector.set(__DELETEDATA_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DBNAME:
        if (value == null) {
          unsetDbname();
        } else {
          setDbname((String)value);
        }
        break;

      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case DELETE_DATA:
        if (value == null) {
          unsetDeleteData();
        } else {
          setDeleteData((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DBNAME:
        return getDbname();

      case NAME:
        return getName();

      case DELETE_DATA:
        return new Boolean(isDeleteData());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DBNAME:
        return isSetDbname();
      case NAME:
        return isSetName();
      case DELETE_DATA:
        return isSetDeleteData();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_table_args)
        return this.equals((drop_table_args)that);
      return false;
    }

    public boolean equals(drop_table_args that) {
      if (that == null)
        return false;

      boolean this_present_dbname = true && this.isSetDbname();
      boolean that_present_dbname = true && that.isSetDbname();
      if (this_present_dbname || that_present_dbname) {
        if (!(this_present_dbname && that_present_dbname))
          return false;
        if (!this.dbname.equals(that.dbname))
          return false;
      }

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_deleteData = true;
      boolean that_present_deleteData = true;
      if (this_present_deleteData || that_present_deleteData) {
        if (!(this_present_deleteData && that_present_deleteData))
          return false;
        if (this.deleteData != that.deleteData)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_table_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_table_args typedOther = (drop_table_args)other;

      lastComparison = Boolean.valueOf(isSetDbname()).compareTo(typedOther.isSetDbname());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDbname()) {
        lastComparison = TBaseHelper.compareTo(this.dbname, typedOther.dbname);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetName()).compareTo(typedOther.isSetName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetName()) {
        lastComparison = TBaseHelper.compareTo(this.name, typedOther.name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetDeleteData()).compareTo(typedOther.isSetDeleteData());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDeleteData()) {
        lastComparison = TBaseHelper.compareTo(this.deleteData, typedOther.deleteData);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DBNAME
            if (field.type == TType.STRING) {
              this.dbname = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // NAME
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // DELETE_DATA
            if (field.type == TType.BOOL) {
              this.deleteData = iprot.readBool();
              setDeleteDataIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.dbname != null) {
        oprot.writeFieldBegin(DBNAME_FIELD_DESC);
        oprot.writeString(this.dbname);
        oprot.writeFieldEnd();
      }
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(DELETE_DATA_FIELD_DESC);
      oprot.writeBool(this.deleteData);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_table_args(");
      boolean first = true;

      sb.append("dbname:");
      if (this.dbname == null) {
        sb.append("null");
      } else {
        sb.append(this.dbname);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("deleteData:");
      sb.append(this.deleteData);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_table_result implements TBase<drop_table_result, drop_table_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_table_result");

    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O3_FIELD_DESC = new TField("o3", TType.STRUCT, (short)2);

    private NoSuchObjectException o1;
    private MetaException o3;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      O1((short)1, "o1"),
      O3((short)2, "o3");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // O1
            return O1;
          case 2: // O3
            return O3;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O3, new FieldMetaData("o3", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_table_result.class, metaDataMap);
    }

    public drop_table_result() {
    }

    public drop_table_result(
      NoSuchObjectException o1,
      MetaException o3)
    {
      this();
      this.o1 = o1;
      this.o3 = o3;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_table_result(drop_table_result other) {
      if (other.isSetO1()) {
        this.o1 = new NoSuchObjectException(other.o1);
      }
      if (other.isSetO3()) {
        this.o3 = new MetaException(other.o3);
      }
    }

    public drop_table_result deepCopy() {
      return new drop_table_result(this);
    }

    @Override
    public void clear() {
      this.o1 = null;
      this.o3 = null;
    }

    public NoSuchObjectException getO1() {
      return this.o1;
    }

    public void setO1(NoSuchObjectException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public MetaException getO3() {
      return this.o3;
    }

    public void setO3(MetaException o3) {
      this.o3 = o3;
    }

    public void unsetO3() {
      this.o3 = null;
    }

    /** Returns true if field o3 is set (has been asigned a value) and false otherwise */
    public boolean isSetO3() {
      return this.o3 != null;
    }

    public void setO3IsSet(boolean value) {
      if (!value) {
        this.o3 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((NoSuchObjectException)value);
        }
        break;

      case O3:
        if (value == null) {
          unsetO3();
        } else {
          setO3((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case O1:
        return getO1();

      case O3:
        return getO3();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case O1:
        return isSetO1();
      case O3:
        return isSetO3();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_table_result)
        return this.equals((drop_table_result)that);
      return false;
    }

    public boolean equals(drop_table_result that) {
      if (that == null)
        return false;

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o3 = true && this.isSetO3();
      boolean that_present_o3 = true && that.isSetO3();
      if (this_present_o3 || that_present_o3) {
        if (!(this_present_o3 && that_present_o3))
          return false;
        if (!this.o3.equals(that.o3))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_table_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_table_result typedOther = (drop_table_result)other;

      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO3()).compareTo(typedOther.isSetO3());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO3()) {
        lastComparison = TBaseHelper.compareTo(this.o3, typedOther.o3);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new NoSuchObjectException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O3
            if (field.type == TType.STRUCT) {
              this.o3 = new MetaException();
              this.o3.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO3()) {
        oprot.writeFieldBegin(O3_FIELD_DESC);
        this.o3.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_table_result(");
      boolean first = true;

      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o3:");
      if (this.o3 == null) {
        sb.append("null");
      } else {
        sb.append(this.o3);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_tables_args implements TBase<get_tables_args, get_tables_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_tables_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField PATTERN_FIELD_DESC = new TField("pattern", TType.STRING, (short)2);

    private String db_name;
    private String pattern;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      PATTERN((short)2, "pattern");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // PATTERN
            return PATTERN;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.PATTERN, new FieldMetaData("pattern", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_tables_args.class, metaDataMap);
    }

    public get_tables_args() {
    }

    public get_tables_args(
      String db_name,
      String pattern)
    {
      this();
      this.db_name = db_name;
      this.pattern = pattern;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_tables_args(get_tables_args other) {
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetPattern()) {
        this.pattern = other.pattern;
      }
    }

    public get_tables_args deepCopy() {
      return new get_tables_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.pattern = null;
    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getPattern() {
      return this.pattern;
    }

    public void setPattern(String pattern) {
      this.pattern = pattern;
    }

    public void unsetPattern() {
      this.pattern = null;
    }

    /** Returns true if field pattern is set (has been asigned a value) and false otherwise */
    public boolean isSetPattern() {
      return this.pattern != null;
    }

    public void setPatternIsSet(boolean value) {
      if (!value) {
        this.pattern = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case PATTERN:
        if (value == null) {
          unsetPattern();
        } else {
          setPattern((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case PATTERN:
        return getPattern();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case PATTERN:
        return isSetPattern();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_tables_args)
        return this.equals((get_tables_args)that);
      return false;
    }

    public boolean equals(get_tables_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_pattern = true && this.isSetPattern();
      boolean that_present_pattern = true && that.isSetPattern();
      if (this_present_pattern || that_present_pattern) {
        if (!(this_present_pattern && that_present_pattern))
          return false;
        if (!this.pattern.equals(that.pattern))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_tables_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_tables_args typedOther = (get_tables_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPattern()).compareTo(typedOther.isSetPattern());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPattern()) {
        lastComparison = TBaseHelper.compareTo(this.pattern, typedOther.pattern);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // PATTERN
            if (field.type == TType.STRING) {
              this.pattern = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.pattern != null) {
        oprot.writeFieldBegin(PATTERN_FIELD_DESC);
        oprot.writeString(this.pattern);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_tables_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("pattern:");
      if (this.pattern == null) {
        sb.append("null");
      } else {
        sb.append(this.pattern);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_tables_result implements TBase<get_tables_result, get_tables_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_tables_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);

    private List<String> success;
    private MetaException o1;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_tables_result.class, metaDataMap);
    }

    public get_tables_result() {
    }

    public get_tables_result(
      List<String> success,
      MetaException o1)
    {
      this();
      this.success = success;
      this.o1 = o1;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_tables_result(get_tables_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
    }

    public get_tables_result deepCopy() {
      return new get_tables_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<String> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_tables_result)
        return this.equals((get_tables_result)that);
      return false;
    }

    public boolean equals(get_tables_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_tables_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_tables_result typedOther = (get_tables_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list84 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list84.size);
                for (int _i85 = 0; _i85 < _list84.size; ++_i85)
                {
                  String _elem86;
                  _elem86 = iprot.readString();
                  this.success.add(_elem86);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter87 : this.success)
          {
            oprot.writeString(_iter87);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_tables_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_all_tables_args implements TBase<get_all_tables_args, get_all_tables_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_all_tables_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);

    private String db_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_all_tables_args.class, metaDataMap);
    }

    public get_all_tables_args() {
    }

    public get_all_tables_args(
      String db_name)
    {
      this();
      this.db_name = db_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_all_tables_args(get_all_tables_args other) {
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
    }

    public get_all_tables_args deepCopy() {
      return new get_all_tables_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_all_tables_args)
        return this.equals((get_all_tables_args)that);
      return false;
    }

    public boolean equals(get_all_tables_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_all_tables_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_all_tables_args typedOther = (get_all_tables_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_all_tables_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_all_tables_result implements TBase<get_all_tables_result, get_all_tables_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_all_tables_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);

    private List<String> success;
    private MetaException o1;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_all_tables_result.class, metaDataMap);
    }

    public get_all_tables_result() {
    }

    public get_all_tables_result(
      List<String> success,
      MetaException o1)
    {
      this();
      this.success = success;
      this.o1 = o1;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_all_tables_result(get_all_tables_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
    }

    public get_all_tables_result deepCopy() {
      return new get_all_tables_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<String> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_all_tables_result)
        return this.equals((get_all_tables_result)that);
      return false;
    }

    public boolean equals(get_all_tables_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_all_tables_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_all_tables_result typedOther = (get_all_tables_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list88 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list88.size);
                for (int _i89 = 0; _i89 < _list88.size; ++_i89)
                {
                  String _elem90;
                  _elem90 = iprot.readString();
                  this.success.add(_elem90);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter91 : this.success)
          {
            oprot.writeString(_iter91);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_all_tables_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_table_args implements TBase<get_table_args, get_table_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_table_args");

    private static final TField DBNAME_FIELD_DESC = new TField("dbname", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);

    private String dbname;
    private String tbl_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DBNAME((short)1, "dbname"),
      TBL_NAME((short)2, "tbl_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DBNAME
            return DBNAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DBNAME, new FieldMetaData("dbname", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_table_args.class, metaDataMap);
    }

    public get_table_args() {
    }

    public get_table_args(
      String dbname,
      String tbl_name)
    {
      this();
      this.dbname = dbname;
      this.tbl_name = tbl_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_table_args(get_table_args other) {
      if (other.isSetDbname()) {
        this.dbname = other.dbname;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
    }

    public get_table_args deepCopy() {
      return new get_table_args(this);
    }

    @Override
    public void clear() {
      this.dbname = null;
      this.tbl_name = null;
    }

    public String getDbname() {
      return this.dbname;
    }

    public void setDbname(String dbname) {
      this.dbname = dbname;
    }

    public void unsetDbname() {
      this.dbname = null;
    }

    /** Returns true if field dbname is set (has been asigned a value) and false otherwise */
    public boolean isSetDbname() {
      return this.dbname != null;
    }

    public void setDbnameIsSet(boolean value) {
      if (!value) {
        this.dbname = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DBNAME:
        if (value == null) {
          unsetDbname();
        } else {
          setDbname((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DBNAME:
        return getDbname();

      case TBL_NAME:
        return getTbl_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DBNAME:
        return isSetDbname();
      case TBL_NAME:
        return isSetTbl_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_table_args)
        return this.equals((get_table_args)that);
      return false;
    }

    public boolean equals(get_table_args that) {
      if (that == null)
        return false;

      boolean this_present_dbname = true && this.isSetDbname();
      boolean that_present_dbname = true && that.isSetDbname();
      if (this_present_dbname || that_present_dbname) {
        if (!(this_present_dbname && that_present_dbname))
          return false;
        if (!this.dbname.equals(that.dbname))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_table_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_table_args typedOther = (get_table_args)other;

      lastComparison = Boolean.valueOf(isSetDbname()).compareTo(typedOther.isSetDbname());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDbname()) {
        lastComparison = TBaseHelper.compareTo(this.dbname, typedOther.dbname);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DBNAME
            if (field.type == TType.STRING) {
              this.dbname = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.dbname != null) {
        oprot.writeFieldBegin(DBNAME_FIELD_DESC);
        oprot.writeString(this.dbname);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_table_args(");
      boolean first = true;

      sb.append("dbname:");
      if (this.dbname == null) {
        sb.append("null");
      } else {
        sb.append(this.dbname);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_table_result implements TBase<get_table_result, get_table_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_table_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private Table success;
    private MetaException o1;
    private NoSuchObjectException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Table.class)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_table_result.class, metaDataMap);
    }

    public get_table_result() {
    }

    public get_table_result(
      Table success,
      MetaException o1,
      NoSuchObjectException o2)
    {
      this();
      this.success = success;
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_table_result(get_table_result other) {
      if (other.isSetSuccess()) {
        this.success = new Table(other.success);
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new NoSuchObjectException(other.o2);
      }
    }

    public get_table_result deepCopy() {
      return new get_table_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
      this.o2 = null;
    }

    public Table getSuccess() {
      return this.success;
    }

    public void setSuccess(Table success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public NoSuchObjectException getO2() {
      return this.o2;
    }

    public void setO2(NoSuchObjectException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Table)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((NoSuchObjectException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_table_result)
        return this.equals((get_table_result)that);
      return false;
    }

    public boolean equals(get_table_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_table_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_table_result typedOther = (get_table_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new Table();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new NoSuchObjectException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_table_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alter_table_args implements TBase<alter_table_args, alter_table_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("alter_table_args");

    private static final TField DBNAME_FIELD_DESC = new TField("dbname", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField NEW_TBL_FIELD_DESC = new TField("new_tbl", TType.STRUCT, (short)3);

    private String dbname;
    private String tbl_name;
    private Table new_tbl;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DBNAME((short)1, "dbname"),
      TBL_NAME((short)2, "tbl_name"),
      NEW_TBL((short)3, "new_tbl");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DBNAME
            return DBNAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // NEW_TBL
            return NEW_TBL;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DBNAME, new FieldMetaData("dbname", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.NEW_TBL, new FieldMetaData("new_tbl", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Table.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(alter_table_args.class, metaDataMap);
    }

    public alter_table_args() {
    }

    public alter_table_args(
      String dbname,
      String tbl_name,
      Table new_tbl)
    {
      this();
      this.dbname = dbname;
      this.tbl_name = tbl_name;
      this.new_tbl = new_tbl;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alter_table_args(alter_table_args other) {
      if (other.isSetDbname()) {
        this.dbname = other.dbname;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      if (other.isSetNew_tbl()) {
        this.new_tbl = new Table(other.new_tbl);
      }
    }

    public alter_table_args deepCopy() {
      return new alter_table_args(this);
    }

    @Override
    public void clear() {
      this.dbname = null;
      this.tbl_name = null;
      this.new_tbl = null;
    }

    public String getDbname() {
      return this.dbname;
    }

    public void setDbname(String dbname) {
      this.dbname = dbname;
    }

    public void unsetDbname() {
      this.dbname = null;
    }

    /** Returns true if field dbname is set (has been asigned a value) and false otherwise */
    public boolean isSetDbname() {
      return this.dbname != null;
    }

    public void setDbnameIsSet(boolean value) {
      if (!value) {
        this.dbname = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public Table getNew_tbl() {
      return this.new_tbl;
    }

    public void setNew_tbl(Table new_tbl) {
      this.new_tbl = new_tbl;
    }

    public void unsetNew_tbl() {
      this.new_tbl = null;
    }

    /** Returns true if field new_tbl is set (has been asigned a value) and false otherwise */
    public boolean isSetNew_tbl() {
      return this.new_tbl != null;
    }

    public void setNew_tblIsSet(boolean value) {
      if (!value) {
        this.new_tbl = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DBNAME:
        if (value == null) {
          unsetDbname();
        } else {
          setDbname((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case NEW_TBL:
        if (value == null) {
          unsetNew_tbl();
        } else {
          setNew_tbl((Table)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DBNAME:
        return getDbname();

      case TBL_NAME:
        return getTbl_name();

      case NEW_TBL:
        return getNew_tbl();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DBNAME:
        return isSetDbname();
      case TBL_NAME:
        return isSetTbl_name();
      case NEW_TBL:
        return isSetNew_tbl();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alter_table_args)
        return this.equals((alter_table_args)that);
      return false;
    }

    public boolean equals(alter_table_args that) {
      if (that == null)
        return false;

      boolean this_present_dbname = true && this.isSetDbname();
      boolean that_present_dbname = true && that.isSetDbname();
      if (this_present_dbname || that_present_dbname) {
        if (!(this_present_dbname && that_present_dbname))
          return false;
        if (!this.dbname.equals(that.dbname))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_new_tbl = true && this.isSetNew_tbl();
      boolean that_present_new_tbl = true && that.isSetNew_tbl();
      if (this_present_new_tbl || that_present_new_tbl) {
        if (!(this_present_new_tbl && that_present_new_tbl))
          return false;
        if (!this.new_tbl.equals(that.new_tbl))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(alter_table_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      alter_table_args typedOther = (alter_table_args)other;

      lastComparison = Boolean.valueOf(isSetDbname()).compareTo(typedOther.isSetDbname());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDbname()) {
        lastComparison = TBaseHelper.compareTo(this.dbname, typedOther.dbname);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetNew_tbl()).compareTo(typedOther.isSetNew_tbl());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNew_tbl()) {
        lastComparison = TBaseHelper.compareTo(this.new_tbl, typedOther.new_tbl);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DBNAME
            if (field.type == TType.STRING) {
              this.dbname = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // NEW_TBL
            if (field.type == TType.STRUCT) {
              this.new_tbl = new Table();
              this.new_tbl.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.dbname != null) {
        oprot.writeFieldBegin(DBNAME_FIELD_DESC);
        oprot.writeString(this.dbname);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      if (this.new_tbl != null) {
        oprot.writeFieldBegin(NEW_TBL_FIELD_DESC);
        this.new_tbl.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("alter_table_args(");
      boolean first = true;

      sb.append("dbname:");
      if (this.dbname == null) {
        sb.append("null");
      } else {
        sb.append(this.dbname);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("new_tbl:");
      if (this.new_tbl == null) {
        sb.append("null");
      } else {
        sb.append(this.new_tbl);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alter_table_result implements TBase<alter_table_result, alter_table_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("alter_table_result");

    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private InvalidOperationException o1;
    private MetaException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(alter_table_result.class, metaDataMap);
    }

    public alter_table_result() {
    }

    public alter_table_result(
      InvalidOperationException o1,
      MetaException o2)
    {
      this();
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alter_table_result(alter_table_result other) {
      if (other.isSetO1()) {
        this.o1 = new InvalidOperationException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new MetaException(other.o2);
      }
    }

    public alter_table_result deepCopy() {
      return new alter_table_result(this);
    }

    @Override
    public void clear() {
      this.o1 = null;
      this.o2 = null;
    }

    public InvalidOperationException getO1() {
      return this.o1;
    }

    public void setO1(InvalidOperationException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public MetaException getO2() {
      return this.o2;
    }

    public void setO2(MetaException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((InvalidOperationException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alter_table_result)
        return this.equals((alter_table_result)that);
      return false;
    }

    public boolean equals(alter_table_result that) {
      if (that == null)
        return false;

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(alter_table_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      alter_table_result typedOther = (alter_table_result)other;

      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new InvalidOperationException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new MetaException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("alter_table_result(");
      boolean first = true;

      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class add_partition_args implements TBase<add_partition_args, add_partition_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("add_partition_args");

    private static final TField NEW_PART_FIELD_DESC = new TField("new_part", TType.STRUCT, (short)1);

    private Partition new_part;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NEW_PART((short)1, "new_part");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NEW_PART
            return NEW_PART;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NEW_PART, new FieldMetaData("new_part", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Partition.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(add_partition_args.class, metaDataMap);
    }

    public add_partition_args() {
    }

    public add_partition_args(
      Partition new_part)
    {
      this();
      this.new_part = new_part;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public add_partition_args(add_partition_args other) {
      if (other.isSetNew_part()) {
        this.new_part = new Partition(other.new_part);
      }
    }

    public add_partition_args deepCopy() {
      return new add_partition_args(this);
    }

    @Override
    public void clear() {
      this.new_part = null;
    }

    public Partition getNew_part() {
      return this.new_part;
    }

    public void setNew_part(Partition new_part) {
      this.new_part = new_part;
    }

    public void unsetNew_part() {
      this.new_part = null;
    }

    /** Returns true if field new_part is set (has been asigned a value) and false otherwise */
    public boolean isSetNew_part() {
      return this.new_part != null;
    }

    public void setNew_partIsSet(boolean value) {
      if (!value) {
        this.new_part = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NEW_PART:
        if (value == null) {
          unsetNew_part();
        } else {
          setNew_part((Partition)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NEW_PART:
        return getNew_part();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NEW_PART:
        return isSetNew_part();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof add_partition_args)
        return this.equals((add_partition_args)that);
      return false;
    }

    public boolean equals(add_partition_args that) {
      if (that == null)
        return false;

      boolean this_present_new_part = true && this.isSetNew_part();
      boolean that_present_new_part = true && that.isSetNew_part();
      if (this_present_new_part || that_present_new_part) {
        if (!(this_present_new_part && that_present_new_part))
          return false;
        if (!this.new_part.equals(that.new_part))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(add_partition_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      add_partition_args typedOther = (add_partition_args)other;

      lastComparison = Boolean.valueOf(isSetNew_part()).compareTo(typedOther.isSetNew_part());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNew_part()) {
        lastComparison = TBaseHelper.compareTo(this.new_part, typedOther.new_part);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NEW_PART
            if (field.type == TType.STRUCT) {
              this.new_part = new Partition();
              this.new_part.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.new_part != null) {
        oprot.writeFieldBegin(NEW_PART_FIELD_DESC);
        this.new_part.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("add_partition_args(");
      boolean first = true;

      sb.append("new_part:");
      if (this.new_part == null) {
        sb.append("null");
      } else {
        sb.append(this.new_part);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class add_partition_result implements TBase<add_partition_result, add_partition_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("add_partition_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);
    private static final TField O3_FIELD_DESC = new TField("o3", TType.STRUCT, (short)3);

    private Partition success;
    private InvalidObjectException o1;
    private AlreadyExistsException o2;
    private MetaException o3;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2"),
      O3((short)3, "o3");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          case 3: // O3
            return O3;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Partition.class)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O3, new FieldMetaData("o3", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(add_partition_result.class, metaDataMap);
    }

    public add_partition_result() {
    }

    public add_partition_result(
      Partition success,
      InvalidObjectException o1,
      AlreadyExistsException o2,
      MetaException o3)
    {
      this();
      this.success = success;
      this.o1 = o1;
      this.o2 = o2;
      this.o3 = o3;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public add_partition_result(add_partition_result other) {
      if (other.isSetSuccess()) {
        this.success = new Partition(other.success);
      }
      if (other.isSetO1()) {
        this.o1 = new InvalidObjectException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new AlreadyExistsException(other.o2);
      }
      if (other.isSetO3()) {
        this.o3 = new MetaException(other.o3);
      }
    }

    public add_partition_result deepCopy() {
      return new add_partition_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
      this.o2 = null;
      this.o3 = null;
    }

    public Partition getSuccess() {
      return this.success;
    }

    public void setSuccess(Partition success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidObjectException getO1() {
      return this.o1;
    }

    public void setO1(InvalidObjectException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public AlreadyExistsException getO2() {
      return this.o2;
    }

    public void setO2(AlreadyExistsException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public MetaException getO3() {
      return this.o3;
    }

    public void setO3(MetaException o3) {
      this.o3 = o3;
    }

    public void unsetO3() {
      this.o3 = null;
    }

    /** Returns true if field o3 is set (has been asigned a value) and false otherwise */
    public boolean isSetO3() {
      return this.o3 != null;
    }

    public void setO3IsSet(boolean value) {
      if (!value) {
        this.o3 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Partition)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((InvalidObjectException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((AlreadyExistsException)value);
        }
        break;

      case O3:
        if (value == null) {
          unsetO3();
        } else {
          setO3((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      case O2:
        return getO2();

      case O3:
        return getO3();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      case O3:
        return isSetO3();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof add_partition_result)
        return this.equals((add_partition_result)that);
      return false;
    }

    public boolean equals(add_partition_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      boolean this_present_o3 = true && this.isSetO3();
      boolean that_present_o3 = true && that.isSetO3();
      if (this_present_o3 || that_present_o3) {
        if (!(this_present_o3 && that_present_o3))
          return false;
        if (!this.o3.equals(that.o3))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(add_partition_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      add_partition_result typedOther = (add_partition_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO3()).compareTo(typedOther.isSetO3());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO3()) {
        lastComparison = TBaseHelper.compareTo(this.o3, typedOther.o3);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new Partition();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new InvalidObjectException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new AlreadyExistsException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // O3
            if (field.type == TType.STRUCT) {
              this.o3 = new MetaException();
              this.o3.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO3()) {
        oprot.writeFieldBegin(O3_FIELD_DESC);
        this.o3.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("add_partition_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o3:");
      if (this.o3 == null) {
        sb.append("null");
      } else {
        sb.append(this.o3);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class append_partition_args implements TBase<append_partition_args, append_partition_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("append_partition_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField PART_VALS_FIELD_DESC = new TField("part_vals", TType.LIST, (short)3);

    private String db_name;
    private String tbl_name;
    private List<String> part_vals;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      PART_VALS((short)3, "part_vals");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // PART_VALS
            return PART_VALS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.PART_VALS, new FieldMetaData("part_vals", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(append_partition_args.class, metaDataMap);
    }

    public append_partition_args() {
    }

    public append_partition_args(
      String db_name,
      String tbl_name,
      List<String> part_vals)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.part_vals = part_vals;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public append_partition_args(append_partition_args other) {
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      if (other.isSetPart_vals()) {
        List<String> __this__part_vals = new ArrayList<String>();
        for (String other_element : other.part_vals) {
          __this__part_vals.add(other_element);
        }
        this.part_vals = __this__part_vals;
      }
    }

    public append_partition_args deepCopy() {
      return new append_partition_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.part_vals = null;
    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public int getPart_valsSize() {
      return (this.part_vals == null) ? 0 : this.part_vals.size();
    }

    public java.util.Iterator<String> getPart_valsIterator() {
      return (this.part_vals == null) ? null : this.part_vals.iterator();
    }

    public void addToPart_vals(String elem) {
      if (this.part_vals == null) {
        this.part_vals = new ArrayList<String>();
      }
      this.part_vals.add(elem);
    }

    public List<String> getPart_vals() {
      return this.part_vals;
    }

    public void setPart_vals(List<String> part_vals) {
      this.part_vals = part_vals;
    }

    public void unsetPart_vals() {
      this.part_vals = null;
    }

    /** Returns true if field part_vals is set (has been asigned a value) and false otherwise */
    public boolean isSetPart_vals() {
      return this.part_vals != null;
    }

    public void setPart_valsIsSet(boolean value) {
      if (!value) {
        this.part_vals = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case PART_VALS:
        if (value == null) {
          unsetPart_vals();
        } else {
          setPart_vals((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case PART_VALS:
        return getPart_vals();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case PART_VALS:
        return isSetPart_vals();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof append_partition_args)
        return this.equals((append_partition_args)that);
      return false;
    }

    public boolean equals(append_partition_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_part_vals = true && this.isSetPart_vals();
      boolean that_present_part_vals = true && that.isSetPart_vals();
      if (this_present_part_vals || that_present_part_vals) {
        if (!(this_present_part_vals && that_present_part_vals))
          return false;
        if (!this.part_vals.equals(that.part_vals))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(append_partition_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      append_partition_args typedOther = (append_partition_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPart_vals()).compareTo(typedOther.isSetPart_vals());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPart_vals()) {
        lastComparison = TBaseHelper.compareTo(this.part_vals, typedOther.part_vals);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // PART_VALS
            if (field.type == TType.LIST) {
              {
                TList _list92 = iprot.readListBegin();
                this.part_vals = new ArrayList<String>(_list92.size);
                for (int _i93 = 0; _i93 < _list92.size; ++_i93)
                {
                  String _elem94;
                  _elem94 = iprot.readString();
                  this.part_vals.add(_elem94);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      if (this.part_vals != null) {
        oprot.writeFieldBegin(PART_VALS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.part_vals.size()));
          for (String _iter95 : this.part_vals)
          {
            oprot.writeString(_iter95);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("append_partition_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("part_vals:");
      if (this.part_vals == null) {
        sb.append("null");
      } else {
        sb.append(this.part_vals);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class append_partition_result implements TBase<append_partition_result, append_partition_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("append_partition_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);
    private static final TField O3_FIELD_DESC = new TField("o3", TType.STRUCT, (short)3);

    private Partition success;
    private InvalidObjectException o1;
    private AlreadyExistsException o2;
    private MetaException o3;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2"),
      O3((short)3, "o3");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          case 3: // O3
            return O3;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Partition.class)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O3, new FieldMetaData("o3", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(append_partition_result.class, metaDataMap);
    }

    public append_partition_result() {
    }

    public append_partition_result(
      Partition success,
      InvalidObjectException o1,
      AlreadyExistsException o2,
      MetaException o3)
    {
      this();
      this.success = success;
      this.o1 = o1;
      this.o2 = o2;
      this.o3 = o3;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public append_partition_result(append_partition_result other) {
      if (other.isSetSuccess()) {
        this.success = new Partition(other.success);
      }
      if (other.isSetO1()) {
        this.o1 = new InvalidObjectException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new AlreadyExistsException(other.o2);
      }
      if (other.isSetO3()) {
        this.o3 = new MetaException(other.o3);
      }
    }

    public append_partition_result deepCopy() {
      return new append_partition_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
      this.o2 = null;
      this.o3 = null;
    }

    public Partition getSuccess() {
      return this.success;
    }

    public void setSuccess(Partition success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidObjectException getO1() {
      return this.o1;
    }

    public void setO1(InvalidObjectException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public AlreadyExistsException getO2() {
      return this.o2;
    }

    public void setO2(AlreadyExistsException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public MetaException getO3() {
      return this.o3;
    }

    public void setO3(MetaException o3) {
      this.o3 = o3;
    }

    public void unsetO3() {
      this.o3 = null;
    }

    /** Returns true if field o3 is set (has been asigned a value) and false otherwise */
    public boolean isSetO3() {
      return this.o3 != null;
    }

    public void setO3IsSet(boolean value) {
      if (!value) {
        this.o3 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Partition)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((InvalidObjectException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((AlreadyExistsException)value);
        }
        break;

      case O3:
        if (value == null) {
          unsetO3();
        } else {
          setO3((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      case O2:
        return getO2();

      case O3:
        return getO3();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      case O3:
        return isSetO3();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof append_partition_result)
        return this.equals((append_partition_result)that);
      return false;
    }

    public boolean equals(append_partition_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      boolean this_present_o3 = true && this.isSetO3();
      boolean that_present_o3 = true && that.isSetO3();
      if (this_present_o3 || that_present_o3) {
        if (!(this_present_o3 && that_present_o3))
          return false;
        if (!this.o3.equals(that.o3))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(append_partition_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      append_partition_result typedOther = (append_partition_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO3()).compareTo(typedOther.isSetO3());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO3()) {
        lastComparison = TBaseHelper.compareTo(this.o3, typedOther.o3);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new Partition();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new InvalidObjectException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new AlreadyExistsException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // O3
            if (field.type == TType.STRUCT) {
              this.o3 = new MetaException();
              this.o3.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO3()) {
        oprot.writeFieldBegin(O3_FIELD_DESC);
        this.o3.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("append_partition_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o3:");
      if (this.o3 == null) {
        sb.append("null");
      } else {
        sb.append(this.o3);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class append_partition_by_name_args implements TBase<append_partition_by_name_args, append_partition_by_name_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("append_partition_by_name_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField PART_NAME_FIELD_DESC = new TField("part_name", TType.STRING, (short)3);

    private String db_name;
    private String tbl_name;
    private String part_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      PART_NAME((short)3, "part_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // PART_NAME
            return PART_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.PART_NAME, new FieldMetaData("part_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(append_partition_by_name_args.class, metaDataMap);
    }

    public append_partition_by_name_args() {
    }

    public append_partition_by_name_args(
      String db_name,
      String tbl_name,
      String part_name)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.part_name = part_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public append_partition_by_name_args(append_partition_by_name_args other) {
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      if (other.isSetPart_name()) {
        this.part_name = other.part_name;
      }
    }

    public append_partition_by_name_args deepCopy() {
      return new append_partition_by_name_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.part_name = null;
    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public String getPart_name() {
      return this.part_name;
    }

    public void setPart_name(String part_name) {
      this.part_name = part_name;
    }

    public void unsetPart_name() {
      this.part_name = null;
    }

    /** Returns true if field part_name is set (has been asigned a value) and false otherwise */
    public boolean isSetPart_name() {
      return this.part_name != null;
    }

    public void setPart_nameIsSet(boolean value) {
      if (!value) {
        this.part_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case PART_NAME:
        if (value == null) {
          unsetPart_name();
        } else {
          setPart_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case PART_NAME:
        return getPart_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case PART_NAME:
        return isSetPart_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof append_partition_by_name_args)
        return this.equals((append_partition_by_name_args)that);
      return false;
    }

    public boolean equals(append_partition_by_name_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_part_name = true && this.isSetPart_name();
      boolean that_present_part_name = true && that.isSetPart_name();
      if (this_present_part_name || that_present_part_name) {
        if (!(this_present_part_name && that_present_part_name))
          return false;
        if (!this.part_name.equals(that.part_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(append_partition_by_name_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      append_partition_by_name_args typedOther = (append_partition_by_name_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPart_name()).compareTo(typedOther.isSetPart_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPart_name()) {
        lastComparison = TBaseHelper.compareTo(this.part_name, typedOther.part_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // PART_NAME
            if (field.type == TType.STRING) {
              this.part_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      if (this.part_name != null) {
        oprot.writeFieldBegin(PART_NAME_FIELD_DESC);
        oprot.writeString(this.part_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("append_partition_by_name_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("part_name:");
      if (this.part_name == null) {
        sb.append("null");
      } else {
        sb.append(this.part_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class append_partition_by_name_result implements TBase<append_partition_by_name_result, append_partition_by_name_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("append_partition_by_name_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);
    private static final TField O3_FIELD_DESC = new TField("o3", TType.STRUCT, (short)3);

    private Partition success;
    private InvalidObjectException o1;
    private AlreadyExistsException o2;
    private MetaException o3;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2"),
      O3((short)3, "o3");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          case 3: // O3
            return O3;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Partition.class)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O3, new FieldMetaData("o3", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(append_partition_by_name_result.class, metaDataMap);
    }

    public append_partition_by_name_result() {
    }

    public append_partition_by_name_result(
      Partition success,
      InvalidObjectException o1,
      AlreadyExistsException o2,
      MetaException o3)
    {
      this();
      this.success = success;
      this.o1 = o1;
      this.o2 = o2;
      this.o3 = o3;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public append_partition_by_name_result(append_partition_by_name_result other) {
      if (other.isSetSuccess()) {
        this.success = new Partition(other.success);
      }
      if (other.isSetO1()) {
        this.o1 = new InvalidObjectException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new AlreadyExistsException(other.o2);
      }
      if (other.isSetO3()) {
        this.o3 = new MetaException(other.o3);
      }
    }

    public append_partition_by_name_result deepCopy() {
      return new append_partition_by_name_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
      this.o2 = null;
      this.o3 = null;
    }

    public Partition getSuccess() {
      return this.success;
    }

    public void setSuccess(Partition success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidObjectException getO1() {
      return this.o1;
    }

    public void setO1(InvalidObjectException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public AlreadyExistsException getO2() {
      return this.o2;
    }

    public void setO2(AlreadyExistsException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public MetaException getO3() {
      return this.o3;
    }

    public void setO3(MetaException o3) {
      this.o3 = o3;
    }

    public void unsetO3() {
      this.o3 = null;
    }

    /** Returns true if field o3 is set (has been asigned a value) and false otherwise */
    public boolean isSetO3() {
      return this.o3 != null;
    }

    public void setO3IsSet(boolean value) {
      if (!value) {
        this.o3 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Partition)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((InvalidObjectException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((AlreadyExistsException)value);
        }
        break;

      case O3:
        if (value == null) {
          unsetO3();
        } else {
          setO3((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      case O2:
        return getO2();

      case O3:
        return getO3();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      case O3:
        return isSetO3();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof append_partition_by_name_result)
        return this.equals((append_partition_by_name_result)that);
      return false;
    }

    public boolean equals(append_partition_by_name_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      boolean this_present_o3 = true && this.isSetO3();
      boolean that_present_o3 = true && that.isSetO3();
      if (this_present_o3 || that_present_o3) {
        if (!(this_present_o3 && that_present_o3))
          return false;
        if (!this.o3.equals(that.o3))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(append_partition_by_name_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      append_partition_by_name_result typedOther = (append_partition_by_name_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO3()).compareTo(typedOther.isSetO3());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO3()) {
        lastComparison = TBaseHelper.compareTo(this.o3, typedOther.o3);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new Partition();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new InvalidObjectException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new AlreadyExistsException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // O3
            if (field.type == TType.STRUCT) {
              this.o3 = new MetaException();
              this.o3.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO3()) {
        oprot.writeFieldBegin(O3_FIELD_DESC);
        this.o3.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("append_partition_by_name_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o3:");
      if (this.o3 == null) {
        sb.append("null");
      } else {
        sb.append(this.o3);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_partition_args implements TBase<drop_partition_args, drop_partition_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_partition_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField PART_VALS_FIELD_DESC = new TField("part_vals", TType.LIST, (short)3);
    private static final TField DELETE_DATA_FIELD_DESC = new TField("deleteData", TType.BOOL, (short)4);

    private String db_name;
    private String tbl_name;
    private List<String> part_vals;
    private boolean deleteData;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      PART_VALS((short)3, "part_vals"),
      DELETE_DATA((short)4, "deleteData");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // PART_VALS
            return PART_VALS;
          case 4: // DELETE_DATA
            return DELETE_DATA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __DELETEDATA_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.PART_VALS, new FieldMetaData("part_vals", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.DELETE_DATA, new FieldMetaData("deleteData", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_partition_args.class, metaDataMap);
    }

    public drop_partition_args() {
    }

    public drop_partition_args(
      String db_name,
      String tbl_name,
      List<String> part_vals,
      boolean deleteData)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.part_vals = part_vals;
      this.deleteData = deleteData;
      setDeleteDataIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_partition_args(drop_partition_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      if (other.isSetPart_vals()) {
        List<String> __this__part_vals = new ArrayList<String>();
        for (String other_element : other.part_vals) {
          __this__part_vals.add(other_element);
        }
        this.part_vals = __this__part_vals;
      }
      this.deleteData = other.deleteData;
    }

    public drop_partition_args deepCopy() {
      return new drop_partition_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.part_vals = null;
      setDeleteDataIsSet(false);
      this.deleteData = false;
    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public int getPart_valsSize() {
      return (this.part_vals == null) ? 0 : this.part_vals.size();
    }

    public java.util.Iterator<String> getPart_valsIterator() {
      return (this.part_vals == null) ? null : this.part_vals.iterator();
    }

    public void addToPart_vals(String elem) {
      if (this.part_vals == null) {
        this.part_vals = new ArrayList<String>();
      }
      this.part_vals.add(elem);
    }

    public List<String> getPart_vals() {
      return this.part_vals;
    }

    public void setPart_vals(List<String> part_vals) {
      this.part_vals = part_vals;
    }

    public void unsetPart_vals() {
      this.part_vals = null;
    }

    /** Returns true if field part_vals is set (has been asigned a value) and false otherwise */
    public boolean isSetPart_vals() {
      return this.part_vals != null;
    }

    public void setPart_valsIsSet(boolean value) {
      if (!value) {
        this.part_vals = null;
      }
    }

    public boolean isDeleteData() {
      return this.deleteData;
    }

    public void setDeleteData(boolean deleteData) {
      this.deleteData = deleteData;
      setDeleteDataIsSet(true);
    }

    public void unsetDeleteData() {
      __isset_bit_vector.clear(__DELETEDATA_ISSET_ID);
    }

    /** Returns true if field deleteData is set (has been asigned a value) and false otherwise */
    public boolean isSetDeleteData() {
      return __isset_bit_vector.get(__DELETEDATA_ISSET_ID);
    }

    public void setDeleteDataIsSet(boolean value) {
      __isset_bit_vector.set(__DELETEDATA_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case PART_VALS:
        if (value == null) {
          unsetPart_vals();
        } else {
          setPart_vals((List<String>)value);
        }
        break;

      case DELETE_DATA:
        if (value == null) {
          unsetDeleteData();
        } else {
          setDeleteData((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case PART_VALS:
        return getPart_vals();

      case DELETE_DATA:
        return new Boolean(isDeleteData());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case PART_VALS:
        return isSetPart_vals();
      case DELETE_DATA:
        return isSetDeleteData();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_partition_args)
        return this.equals((drop_partition_args)that);
      return false;
    }

    public boolean equals(drop_partition_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_part_vals = true && this.isSetPart_vals();
      boolean that_present_part_vals = true && that.isSetPart_vals();
      if (this_present_part_vals || that_present_part_vals) {
        if (!(this_present_part_vals && that_present_part_vals))
          return false;
        if (!this.part_vals.equals(that.part_vals))
          return false;
      }

      boolean this_present_deleteData = true;
      boolean that_present_deleteData = true;
      if (this_present_deleteData || that_present_deleteData) {
        if (!(this_present_deleteData && that_present_deleteData))
          return false;
        if (this.deleteData != that.deleteData)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_partition_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_partition_args typedOther = (drop_partition_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPart_vals()).compareTo(typedOther.isSetPart_vals());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPart_vals()) {
        lastComparison = TBaseHelper.compareTo(this.part_vals, typedOther.part_vals);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetDeleteData()).compareTo(typedOther.isSetDeleteData());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDeleteData()) {
        lastComparison = TBaseHelper.compareTo(this.deleteData, typedOther.deleteData);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // PART_VALS
            if (field.type == TType.LIST) {
              {
                TList _list96 = iprot.readListBegin();
                this.part_vals = new ArrayList<String>(_list96.size);
                for (int _i97 = 0; _i97 < _list96.size; ++_i97)
                {
                  String _elem98;
                  _elem98 = iprot.readString();
                  this.part_vals.add(_elem98);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // DELETE_DATA
            if (field.type == TType.BOOL) {
              this.deleteData = iprot.readBool();
              setDeleteDataIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      if (this.part_vals != null) {
        oprot.writeFieldBegin(PART_VALS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.part_vals.size()));
          for (String _iter99 : this.part_vals)
          {
            oprot.writeString(_iter99);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(DELETE_DATA_FIELD_DESC);
      oprot.writeBool(this.deleteData);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_partition_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("part_vals:");
      if (this.part_vals == null) {
        sb.append("null");
      } else {
        sb.append(this.part_vals);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("deleteData:");
      sb.append(this.deleteData);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_partition_result implements TBase<drop_partition_result, drop_partition_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_partition_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private boolean success;
    private NoSuchObjectException o1;
    private MetaException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_partition_result.class, metaDataMap);
    }

    public drop_partition_result() {
    }

    public drop_partition_result(
      boolean success,
      NoSuchObjectException o1,
      MetaException o2)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_partition_result(drop_partition_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetO1()) {
        this.o1 = new NoSuchObjectException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new MetaException(other.o2);
      }
    }

    public drop_partition_result deepCopy() {
      return new drop_partition_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
      this.o1 = null;
      this.o2 = null;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public NoSuchObjectException getO1() {
      return this.o1;
    }

    public void setO1(NoSuchObjectException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public MetaException getO2() {
      return this.o2;
    }

    public void setO2(MetaException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((NoSuchObjectException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_partition_result)
        return this.equals((drop_partition_result)that);
      return false;
    }

    public boolean equals(drop_partition_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_partition_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_partition_result typedOther = (drop_partition_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new NoSuchObjectException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new MetaException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_partition_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_partition_by_name_args implements TBase<drop_partition_by_name_args, drop_partition_by_name_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_partition_by_name_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField PART_NAME_FIELD_DESC = new TField("part_name", TType.STRING, (short)3);
    private static final TField DELETE_DATA_FIELD_DESC = new TField("deleteData", TType.BOOL, (short)4);

    private String db_name;
    private String tbl_name;
    private String part_name;
    private boolean deleteData;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      PART_NAME((short)3, "part_name"),
      DELETE_DATA((short)4, "deleteData");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // PART_NAME
            return PART_NAME;
          case 4: // DELETE_DATA
            return DELETE_DATA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __DELETEDATA_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.PART_NAME, new FieldMetaData("part_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.DELETE_DATA, new FieldMetaData("deleteData", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_partition_by_name_args.class, metaDataMap);
    }

    public drop_partition_by_name_args() {
    }

    public drop_partition_by_name_args(
      String db_name,
      String tbl_name,
      String part_name,
      boolean deleteData)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.part_name = part_name;
      this.deleteData = deleteData;
      setDeleteDataIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_partition_by_name_args(drop_partition_by_name_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      if (other.isSetPart_name()) {
        this.part_name = other.part_name;
      }
      this.deleteData = other.deleteData;
    }

    public drop_partition_by_name_args deepCopy() {
      return new drop_partition_by_name_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.part_name = null;
      setDeleteDataIsSet(false);
      this.deleteData = false;
    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public String getPart_name() {
      return this.part_name;
    }

    public void setPart_name(String part_name) {
      this.part_name = part_name;
    }

    public void unsetPart_name() {
      this.part_name = null;
    }

    /** Returns true if field part_name is set (has been asigned a value) and false otherwise */
    public boolean isSetPart_name() {
      return this.part_name != null;
    }

    public void setPart_nameIsSet(boolean value) {
      if (!value) {
        this.part_name = null;
      }
    }

    public boolean isDeleteData() {
      return this.deleteData;
    }

    public void setDeleteData(boolean deleteData) {
      this.deleteData = deleteData;
      setDeleteDataIsSet(true);
    }

    public void unsetDeleteData() {
      __isset_bit_vector.clear(__DELETEDATA_ISSET_ID);
    }

    /** Returns true if field deleteData is set (has been asigned a value) and false otherwise */
    public boolean isSetDeleteData() {
      return __isset_bit_vector.get(__DELETEDATA_ISSET_ID);
    }

    public void setDeleteDataIsSet(boolean value) {
      __isset_bit_vector.set(__DELETEDATA_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case PART_NAME:
        if (value == null) {
          unsetPart_name();
        } else {
          setPart_name((String)value);
        }
        break;

      case DELETE_DATA:
        if (value == null) {
          unsetDeleteData();
        } else {
          setDeleteData((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case PART_NAME:
        return getPart_name();

      case DELETE_DATA:
        return new Boolean(isDeleteData());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case PART_NAME:
        return isSetPart_name();
      case DELETE_DATA:
        return isSetDeleteData();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_partition_by_name_args)
        return this.equals((drop_partition_by_name_args)that);
      return false;
    }

    public boolean equals(drop_partition_by_name_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_part_name = true && this.isSetPart_name();
      boolean that_present_part_name = true && that.isSetPart_name();
      if (this_present_part_name || that_present_part_name) {
        if (!(this_present_part_name && that_present_part_name))
          return false;
        if (!this.part_name.equals(that.part_name))
          return false;
      }

      boolean this_present_deleteData = true;
      boolean that_present_deleteData = true;
      if (this_present_deleteData || that_present_deleteData) {
        if (!(this_present_deleteData && that_present_deleteData))
          return false;
        if (this.deleteData != that.deleteData)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_partition_by_name_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_partition_by_name_args typedOther = (drop_partition_by_name_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPart_name()).compareTo(typedOther.isSetPart_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPart_name()) {
        lastComparison = TBaseHelper.compareTo(this.part_name, typedOther.part_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetDeleteData()).compareTo(typedOther.isSetDeleteData());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDeleteData()) {
        lastComparison = TBaseHelper.compareTo(this.deleteData, typedOther.deleteData);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // PART_NAME
            if (field.type == TType.STRING) {
              this.part_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // DELETE_DATA
            if (field.type == TType.BOOL) {
              this.deleteData = iprot.readBool();
              setDeleteDataIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      if (this.part_name != null) {
        oprot.writeFieldBegin(PART_NAME_FIELD_DESC);
        oprot.writeString(this.part_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(DELETE_DATA_FIELD_DESC);
      oprot.writeBool(this.deleteData);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_partition_by_name_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("part_name:");
      if (this.part_name == null) {
        sb.append("null");
      } else {
        sb.append(this.part_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("deleteData:");
      sb.append(this.deleteData);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_partition_by_name_result implements TBase<drop_partition_by_name_result, drop_partition_by_name_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_partition_by_name_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private boolean success;
    private NoSuchObjectException o1;
    private MetaException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_partition_by_name_result.class, metaDataMap);
    }

    public drop_partition_by_name_result() {
    }

    public drop_partition_by_name_result(
      boolean success,
      NoSuchObjectException o1,
      MetaException o2)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_partition_by_name_result(drop_partition_by_name_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetO1()) {
        this.o1 = new NoSuchObjectException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new MetaException(other.o2);
      }
    }

    public drop_partition_by_name_result deepCopy() {
      return new drop_partition_by_name_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
      this.o1 = null;
      this.o2 = null;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public NoSuchObjectException getO1() {
      return this.o1;
    }

    public void setO1(NoSuchObjectException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public MetaException getO2() {
      return this.o2;
    }

    public void setO2(MetaException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((NoSuchObjectException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_partition_by_name_result)
        return this.equals((drop_partition_by_name_result)that);
      return false;
    }

    public boolean equals(drop_partition_by_name_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_partition_by_name_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_partition_by_name_result typedOther = (drop_partition_by_name_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new NoSuchObjectException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new MetaException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_partition_by_name_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_partition_args implements TBase<get_partition_args, get_partition_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_partition_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField PART_VALS_FIELD_DESC = new TField("part_vals", TType.LIST, (short)3);

    private String db_name;
    private String tbl_name;
    private List<String> part_vals;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      PART_VALS((short)3, "part_vals");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // PART_VALS
            return PART_VALS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.PART_VALS, new FieldMetaData("part_vals", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_partition_args.class, metaDataMap);
    }

    public get_partition_args() {
    }

    public get_partition_args(
      String db_name,
      String tbl_name,
      List<String> part_vals)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.part_vals = part_vals;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_partition_args(get_partition_args other) {
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      if (other.isSetPart_vals()) {
        List<String> __this__part_vals = new ArrayList<String>();
        for (String other_element : other.part_vals) {
          __this__part_vals.add(other_element);
        }
        this.part_vals = __this__part_vals;
      }
    }

    public get_partition_args deepCopy() {
      return new get_partition_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.part_vals = null;
    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public int getPart_valsSize() {
      return (this.part_vals == null) ? 0 : this.part_vals.size();
    }

    public java.util.Iterator<String> getPart_valsIterator() {
      return (this.part_vals == null) ? null : this.part_vals.iterator();
    }

    public void addToPart_vals(String elem) {
      if (this.part_vals == null) {
        this.part_vals = new ArrayList<String>();
      }
      this.part_vals.add(elem);
    }

    public List<String> getPart_vals() {
      return this.part_vals;
    }

    public void setPart_vals(List<String> part_vals) {
      this.part_vals = part_vals;
    }

    public void unsetPart_vals() {
      this.part_vals = null;
    }

    /** Returns true if field part_vals is set (has been asigned a value) and false otherwise */
    public boolean isSetPart_vals() {
      return this.part_vals != null;
    }

    public void setPart_valsIsSet(boolean value) {
      if (!value) {
        this.part_vals = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case PART_VALS:
        if (value == null) {
          unsetPart_vals();
        } else {
          setPart_vals((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case PART_VALS:
        return getPart_vals();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case PART_VALS:
        return isSetPart_vals();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_partition_args)
        return this.equals((get_partition_args)that);
      return false;
    }

    public boolean equals(get_partition_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_part_vals = true && this.isSetPart_vals();
      boolean that_present_part_vals = true && that.isSetPart_vals();
      if (this_present_part_vals || that_present_part_vals) {
        if (!(this_present_part_vals && that_present_part_vals))
          return false;
        if (!this.part_vals.equals(that.part_vals))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_partition_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_partition_args typedOther = (get_partition_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPart_vals()).compareTo(typedOther.isSetPart_vals());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPart_vals()) {
        lastComparison = TBaseHelper.compareTo(this.part_vals, typedOther.part_vals);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // PART_VALS
            if (field.type == TType.LIST) {
              {
                TList _list100 = iprot.readListBegin();
                this.part_vals = new ArrayList<String>(_list100.size);
                for (int _i101 = 0; _i101 < _list100.size; ++_i101)
                {
                  String _elem102;
                  _elem102 = iprot.readString();
                  this.part_vals.add(_elem102);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      if (this.part_vals != null) {
        oprot.writeFieldBegin(PART_VALS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.part_vals.size()));
          for (String _iter103 : this.part_vals)
          {
            oprot.writeString(_iter103);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_partition_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("part_vals:");
      if (this.part_vals == null) {
        sb.append("null");
      } else {
        sb.append(this.part_vals);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_partition_result implements TBase<get_partition_result, get_partition_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_partition_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private Partition success;
    private MetaException o1;
    private NoSuchObjectException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Partition.class)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_partition_result.class, metaDataMap);
    }

    public get_partition_result() {
    }

    public get_partition_result(
      Partition success,
      MetaException o1,
      NoSuchObjectException o2)
    {
      this();
      this.success = success;
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_partition_result(get_partition_result other) {
      if (other.isSetSuccess()) {
        this.success = new Partition(other.success);
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new NoSuchObjectException(other.o2);
      }
    }

    public get_partition_result deepCopy() {
      return new get_partition_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
      this.o2 = null;
    }

    public Partition getSuccess() {
      return this.success;
    }

    public void setSuccess(Partition success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public NoSuchObjectException getO2() {
      return this.o2;
    }

    public void setO2(NoSuchObjectException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Partition)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((NoSuchObjectException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_partition_result)
        return this.equals((get_partition_result)that);
      return false;
    }

    public boolean equals(get_partition_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_partition_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_partition_result typedOther = (get_partition_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new Partition();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new NoSuchObjectException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_partition_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_partition_by_name_args implements TBase<get_partition_by_name_args, get_partition_by_name_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_partition_by_name_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField PART_NAME_FIELD_DESC = new TField("part_name", TType.STRING, (short)3);

    private String db_name;
    private String tbl_name;
    private String part_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      PART_NAME((short)3, "part_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // PART_NAME
            return PART_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.PART_NAME, new FieldMetaData("part_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_partition_by_name_args.class, metaDataMap);
    }

    public get_partition_by_name_args() {
    }

    public get_partition_by_name_args(
      String db_name,
      String tbl_name,
      String part_name)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.part_name = part_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_partition_by_name_args(get_partition_by_name_args other) {
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      if (other.isSetPart_name()) {
        this.part_name = other.part_name;
      }
    }

    public get_partition_by_name_args deepCopy() {
      return new get_partition_by_name_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.part_name = null;
    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public String getPart_name() {
      return this.part_name;
    }

    public void setPart_name(String part_name) {
      this.part_name = part_name;
    }

    public void unsetPart_name() {
      this.part_name = null;
    }

    /** Returns true if field part_name is set (has been asigned a value) and false otherwise */
    public boolean isSetPart_name() {
      return this.part_name != null;
    }

    public void setPart_nameIsSet(boolean value) {
      if (!value) {
        this.part_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case PART_NAME:
        if (value == null) {
          unsetPart_name();
        } else {
          setPart_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case PART_NAME:
        return getPart_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case PART_NAME:
        return isSetPart_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_partition_by_name_args)
        return this.equals((get_partition_by_name_args)that);
      return false;
    }

    public boolean equals(get_partition_by_name_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_part_name = true && this.isSetPart_name();
      boolean that_present_part_name = true && that.isSetPart_name();
      if (this_present_part_name || that_present_part_name) {
        if (!(this_present_part_name && that_present_part_name))
          return false;
        if (!this.part_name.equals(that.part_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_partition_by_name_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_partition_by_name_args typedOther = (get_partition_by_name_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPart_name()).compareTo(typedOther.isSetPart_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPart_name()) {
        lastComparison = TBaseHelper.compareTo(this.part_name, typedOther.part_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // PART_NAME
            if (field.type == TType.STRING) {
              this.part_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      if (this.part_name != null) {
        oprot.writeFieldBegin(PART_NAME_FIELD_DESC);
        oprot.writeString(this.part_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_partition_by_name_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("part_name:");
      if (this.part_name == null) {
        sb.append("null");
      } else {
        sb.append(this.part_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_partition_by_name_result implements TBase<get_partition_by_name_result, get_partition_by_name_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_partition_by_name_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private Partition success;
    private MetaException o1;
    private NoSuchObjectException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Partition.class)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_partition_by_name_result.class, metaDataMap);
    }

    public get_partition_by_name_result() {
    }

    public get_partition_by_name_result(
      Partition success,
      MetaException o1,
      NoSuchObjectException o2)
    {
      this();
      this.success = success;
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_partition_by_name_result(get_partition_by_name_result other) {
      if (other.isSetSuccess()) {
        this.success = new Partition(other.success);
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new NoSuchObjectException(other.o2);
      }
    }

    public get_partition_by_name_result deepCopy() {
      return new get_partition_by_name_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
      this.o2 = null;
    }

    public Partition getSuccess() {
      return this.success;
    }

    public void setSuccess(Partition success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public NoSuchObjectException getO2() {
      return this.o2;
    }

    public void setO2(NoSuchObjectException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Partition)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((NoSuchObjectException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_partition_by_name_result)
        return this.equals((get_partition_by_name_result)that);
      return false;
    }

    public boolean equals(get_partition_by_name_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_partition_by_name_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_partition_by_name_result typedOther = (get_partition_by_name_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new Partition();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new NoSuchObjectException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_partition_by_name_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_partitions_args implements TBase<get_partitions_args, get_partitions_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_partitions_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField MAX_PARTS_FIELD_DESC = new TField("max_parts", TType.I16, (short)3);

    private String db_name;
    private String tbl_name;
    private short max_parts;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      MAX_PARTS((short)3, "max_parts");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // MAX_PARTS
            return MAX_PARTS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __MAX_PARTS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.MAX_PARTS, new FieldMetaData("max_parts", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_partitions_args.class, metaDataMap);
    }

    public get_partitions_args() {
      this.max_parts = (short)-1;

    }

    public get_partitions_args(
      String db_name,
      String tbl_name,
      short max_parts)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.max_parts = max_parts;
      setMax_partsIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_partitions_args(get_partitions_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      this.max_parts = other.max_parts;
    }

    public get_partitions_args deepCopy() {
      return new get_partitions_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.max_parts = (short)-1;

    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public short getMax_parts() {
      return this.max_parts;
    }

    public void setMax_parts(short max_parts) {
      this.max_parts = max_parts;
      setMax_partsIsSet(true);
    }

    public void unsetMax_parts() {
      __isset_bit_vector.clear(__MAX_PARTS_ISSET_ID);
    }

    /** Returns true if field max_parts is set (has been asigned a value) and false otherwise */
    public boolean isSetMax_parts() {
      return __isset_bit_vector.get(__MAX_PARTS_ISSET_ID);
    }

    public void setMax_partsIsSet(boolean value) {
      __isset_bit_vector.set(__MAX_PARTS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case MAX_PARTS:
        if (value == null) {
          unsetMax_parts();
        } else {
          setMax_parts((Short)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case MAX_PARTS:
        return new Short(getMax_parts());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case MAX_PARTS:
        return isSetMax_parts();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_partitions_args)
        return this.equals((get_partitions_args)that);
      return false;
    }

    public boolean equals(get_partitions_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_max_parts = true;
      boolean that_present_max_parts = true;
      if (this_present_max_parts || that_present_max_parts) {
        if (!(this_present_max_parts && that_present_max_parts))
          return false;
        if (this.max_parts != that.max_parts)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_partitions_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_partitions_args typedOther = (get_partitions_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMax_parts()).compareTo(typedOther.isSetMax_parts());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMax_parts()) {
        lastComparison = TBaseHelper.compareTo(this.max_parts, typedOther.max_parts);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // MAX_PARTS
            if (field.type == TType.I16) {
              this.max_parts = iprot.readI16();
              setMax_partsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(MAX_PARTS_FIELD_DESC);
      oprot.writeI16(this.max_parts);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_partitions_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("max_parts:");
      sb.append(this.max_parts);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_partitions_result implements TBase<get_partitions_result, get_partitions_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_partitions_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private List<Partition> success;
    private NoSuchObjectException o1;
    private MetaException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Partition.class))));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_partitions_result.class, metaDataMap);
    }

    public get_partitions_result() {
    }

    public get_partitions_result(
      List<Partition> success,
      NoSuchObjectException o1,
      MetaException o2)
    {
      this();
      this.success = success;
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_partitions_result(get_partitions_result other) {
      if (other.isSetSuccess()) {
        List<Partition> __this__success = new ArrayList<Partition>();
        for (Partition other_element : other.success) {
          __this__success.add(new Partition(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetO1()) {
        this.o1 = new NoSuchObjectException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new MetaException(other.o2);
      }
    }

    public get_partitions_result deepCopy() {
      return new get_partitions_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
      this.o2 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Partition> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Partition elem) {
      if (this.success == null) {
        this.success = new ArrayList<Partition>();
      }
      this.success.add(elem);
    }

    public List<Partition> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<Partition> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public NoSuchObjectException getO1() {
      return this.o1;
    }

    public void setO1(NoSuchObjectException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public MetaException getO2() {
      return this.o2;
    }

    public void setO2(MetaException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Partition>)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((NoSuchObjectException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_partitions_result)
        return this.equals((get_partitions_result)that);
      return false;
    }

    public boolean equals(get_partitions_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_partitions_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_partitions_result typedOther = (get_partitions_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list104 = iprot.readListBegin();
                this.success = new ArrayList<Partition>(_list104.size);
                for (int _i105 = 0; _i105 < _list104.size; ++_i105)
                {
                  Partition _elem106;
                  _elem106 = new Partition();
                  _elem106.read(iprot);
                  this.success.add(_elem106);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new NoSuchObjectException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new MetaException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Partition _iter107 : this.success)
          {
            _iter107.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_partitions_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_partition_names_args implements TBase<get_partition_names_args, get_partition_names_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_partition_names_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField MAX_PARTS_FIELD_DESC = new TField("max_parts", TType.I16, (short)3);

    private String db_name;
    private String tbl_name;
    private short max_parts;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      MAX_PARTS((short)3, "max_parts");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // MAX_PARTS
            return MAX_PARTS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __MAX_PARTS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.MAX_PARTS, new FieldMetaData("max_parts", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_partition_names_args.class, metaDataMap);
    }

    public get_partition_names_args() {
      this.max_parts = (short)-1;

    }

    public get_partition_names_args(
      String db_name,
      String tbl_name,
      short max_parts)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.max_parts = max_parts;
      setMax_partsIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_partition_names_args(get_partition_names_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      this.max_parts = other.max_parts;
    }

    public get_partition_names_args deepCopy() {
      return new get_partition_names_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.max_parts = (short)-1;

    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public short getMax_parts() {
      return this.max_parts;
    }

    public void setMax_parts(short max_parts) {
      this.max_parts = max_parts;
      setMax_partsIsSet(true);
    }

    public void unsetMax_parts() {
      __isset_bit_vector.clear(__MAX_PARTS_ISSET_ID);
    }

    /** Returns true if field max_parts is set (has been asigned a value) and false otherwise */
    public boolean isSetMax_parts() {
      return __isset_bit_vector.get(__MAX_PARTS_ISSET_ID);
    }

    public void setMax_partsIsSet(boolean value) {
      __isset_bit_vector.set(__MAX_PARTS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case MAX_PARTS:
        if (value == null) {
          unsetMax_parts();
        } else {
          setMax_parts((Short)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case MAX_PARTS:
        return new Short(getMax_parts());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case MAX_PARTS:
        return isSetMax_parts();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_partition_names_args)
        return this.equals((get_partition_names_args)that);
      return false;
    }

    public boolean equals(get_partition_names_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_max_parts = true;
      boolean that_present_max_parts = true;
      if (this_present_max_parts || that_present_max_parts) {
        if (!(this_present_max_parts && that_present_max_parts))
          return false;
        if (this.max_parts != that.max_parts)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_partition_names_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_partition_names_args typedOther = (get_partition_names_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMax_parts()).compareTo(typedOther.isSetMax_parts());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMax_parts()) {
        lastComparison = TBaseHelper.compareTo(this.max_parts, typedOther.max_parts);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // MAX_PARTS
            if (field.type == TType.I16) {
              this.max_parts = iprot.readI16();
              setMax_partsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(MAX_PARTS_FIELD_DESC);
      oprot.writeI16(this.max_parts);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_partition_names_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("max_parts:");
      sb.append(this.max_parts);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_partition_names_result implements TBase<get_partition_names_result, get_partition_names_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_partition_names_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)1);

    private List<String> success;
    private MetaException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O2((short)1, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_partition_names_result.class, metaDataMap);
    }

    public get_partition_names_result() {
    }

    public get_partition_names_result(
      List<String> success,
      MetaException o2)
    {
      this();
      this.success = success;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_partition_names_result(get_partition_names_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetO2()) {
        this.o2 = new MetaException(other.o2);
      }
    }

    public get_partition_names_result deepCopy() {
      return new get_partition_names_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o2 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<String> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO2() {
      return this.o2;
    }

    public void setO2(MetaException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_partition_names_result)
        return this.equals((get_partition_names_result)that);
      return false;
    }

    public boolean equals(get_partition_names_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_partition_names_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_partition_names_result typedOther = (get_partition_names_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list108 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list108.size);
                for (int _i109 = 0; _i109 < _list108.size; ++_i109)
                {
                  String _elem110;
                  _elem110 = iprot.readString();
                  this.success.add(_elem110);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new MetaException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter111 : this.success)
          {
            oprot.writeString(_iter111);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_partition_names_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_partitions_ps_args implements TBase<get_partitions_ps_args, get_partitions_ps_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_partitions_ps_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField PART_VALS_FIELD_DESC = new TField("part_vals", TType.LIST, (short)3);
    private static final TField MAX_PARTS_FIELD_DESC = new TField("max_parts", TType.I16, (short)4);

    private String db_name;
    private String tbl_name;
    private List<String> part_vals;
    private short max_parts;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      PART_VALS((short)3, "part_vals"),
      MAX_PARTS((short)4, "max_parts");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // PART_VALS
            return PART_VALS;
          case 4: // MAX_PARTS
            return MAX_PARTS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __MAX_PARTS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.PART_VALS, new FieldMetaData("part_vals", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.MAX_PARTS, new FieldMetaData("max_parts", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_partitions_ps_args.class, metaDataMap);
    }

    public get_partitions_ps_args() {
      this.max_parts = (short)-1;

    }

    public get_partitions_ps_args(
      String db_name,
      String tbl_name,
      List<String> part_vals,
      short max_parts)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.part_vals = part_vals;
      this.max_parts = max_parts;
      setMax_partsIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_partitions_ps_args(get_partitions_ps_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      if (other.isSetPart_vals()) {
        List<String> __this__part_vals = new ArrayList<String>();
        for (String other_element : other.part_vals) {
          __this__part_vals.add(other_element);
        }
        this.part_vals = __this__part_vals;
      }
      this.max_parts = other.max_parts;
    }

    public get_partitions_ps_args deepCopy() {
      return new get_partitions_ps_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.part_vals = null;
      this.max_parts = (short)-1;

    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public int getPart_valsSize() {
      return (this.part_vals == null) ? 0 : this.part_vals.size();
    }

    public java.util.Iterator<String> getPart_valsIterator() {
      return (this.part_vals == null) ? null : this.part_vals.iterator();
    }

    public void addToPart_vals(String elem) {
      if (this.part_vals == null) {
        this.part_vals = new ArrayList<String>();
      }
      this.part_vals.add(elem);
    }

    public List<String> getPart_vals() {
      return this.part_vals;
    }

    public void setPart_vals(List<String> part_vals) {
      this.part_vals = part_vals;
    }

    public void unsetPart_vals() {
      this.part_vals = null;
    }

    /** Returns true if field part_vals is set (has been asigned a value) and false otherwise */
    public boolean isSetPart_vals() {
      return this.part_vals != null;
    }

    public void setPart_valsIsSet(boolean value) {
      if (!value) {
        this.part_vals = null;
      }
    }

    public short getMax_parts() {
      return this.max_parts;
    }

    public void setMax_parts(short max_parts) {
      this.max_parts = max_parts;
      setMax_partsIsSet(true);
    }

    public void unsetMax_parts() {
      __isset_bit_vector.clear(__MAX_PARTS_ISSET_ID);
    }

    /** Returns true if field max_parts is set (has been asigned a value) and false otherwise */
    public boolean isSetMax_parts() {
      return __isset_bit_vector.get(__MAX_PARTS_ISSET_ID);
    }

    public void setMax_partsIsSet(boolean value) {
      __isset_bit_vector.set(__MAX_PARTS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case PART_VALS:
        if (value == null) {
          unsetPart_vals();
        } else {
          setPart_vals((List<String>)value);
        }
        break;

      case MAX_PARTS:
        if (value == null) {
          unsetMax_parts();
        } else {
          setMax_parts((Short)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case PART_VALS:
        return getPart_vals();

      case MAX_PARTS:
        return new Short(getMax_parts());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case PART_VALS:
        return isSetPart_vals();
      case MAX_PARTS:
        return isSetMax_parts();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_partitions_ps_args)
        return this.equals((get_partitions_ps_args)that);
      return false;
    }

    public boolean equals(get_partitions_ps_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_part_vals = true && this.isSetPart_vals();
      boolean that_present_part_vals = true && that.isSetPart_vals();
      if (this_present_part_vals || that_present_part_vals) {
        if (!(this_present_part_vals && that_present_part_vals))
          return false;
        if (!this.part_vals.equals(that.part_vals))
          return false;
      }

      boolean this_present_max_parts = true;
      boolean that_present_max_parts = true;
      if (this_present_max_parts || that_present_max_parts) {
        if (!(this_present_max_parts && that_present_max_parts))
          return false;
        if (this.max_parts != that.max_parts)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_partitions_ps_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_partitions_ps_args typedOther = (get_partitions_ps_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPart_vals()).compareTo(typedOther.isSetPart_vals());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPart_vals()) {
        lastComparison = TBaseHelper.compareTo(this.part_vals, typedOther.part_vals);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMax_parts()).compareTo(typedOther.isSetMax_parts());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMax_parts()) {
        lastComparison = TBaseHelper.compareTo(this.max_parts, typedOther.max_parts);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // PART_VALS
            if (field.type == TType.LIST) {
              {
                TList _list112 = iprot.readListBegin();
                this.part_vals = new ArrayList<String>(_list112.size);
                for (int _i113 = 0; _i113 < _list112.size; ++_i113)
                {
                  String _elem114;
                  _elem114 = iprot.readString();
                  this.part_vals.add(_elem114);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // MAX_PARTS
            if (field.type == TType.I16) {
              this.max_parts = iprot.readI16();
              setMax_partsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      if (this.part_vals != null) {
        oprot.writeFieldBegin(PART_VALS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.part_vals.size()));
          for (String _iter115 : this.part_vals)
          {
            oprot.writeString(_iter115);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(MAX_PARTS_FIELD_DESC);
      oprot.writeI16(this.max_parts);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_partitions_ps_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("part_vals:");
      if (this.part_vals == null) {
        sb.append("null");
      } else {
        sb.append(this.part_vals);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("max_parts:");
      sb.append(this.max_parts);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_partitions_ps_result implements TBase<get_partitions_ps_result, get_partitions_ps_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_partitions_ps_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);

    private List<Partition> success;
    private MetaException o1;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Partition.class))));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_partitions_ps_result.class, metaDataMap);
    }

    public get_partitions_ps_result() {
    }

    public get_partitions_ps_result(
      List<Partition> success,
      MetaException o1)
    {
      this();
      this.success = success;
      this.o1 = o1;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_partitions_ps_result(get_partitions_ps_result other) {
      if (other.isSetSuccess()) {
        List<Partition> __this__success = new ArrayList<Partition>();
        for (Partition other_element : other.success) {
          __this__success.add(new Partition(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
    }

    public get_partitions_ps_result deepCopy() {
      return new get_partitions_ps_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Partition> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Partition elem) {
      if (this.success == null) {
        this.success = new ArrayList<Partition>();
      }
      this.success.add(elem);
    }

    public List<Partition> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<Partition> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Partition>)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_partitions_ps_result)
        return this.equals((get_partitions_ps_result)that);
      return false;
    }

    public boolean equals(get_partitions_ps_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_partitions_ps_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_partitions_ps_result typedOther = (get_partitions_ps_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list116 = iprot.readListBegin();
                this.success = new ArrayList<Partition>(_list116.size);
                for (int _i117 = 0; _i117 < _list116.size; ++_i117)
                {
                  Partition _elem118;
                  _elem118 = new Partition();
                  _elem118.read(iprot);
                  this.success.add(_elem118);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Partition _iter119 : this.success)
          {
            _iter119.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_partitions_ps_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_partition_names_ps_args implements TBase<get_partition_names_ps_args, get_partition_names_ps_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_partition_names_ps_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField PART_VALS_FIELD_DESC = new TField("part_vals", TType.LIST, (short)3);
    private static final TField MAX_PARTS_FIELD_DESC = new TField("max_parts", TType.I16, (short)4);

    private String db_name;
    private String tbl_name;
    private List<String> part_vals;
    private short max_parts;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      PART_VALS((short)3, "part_vals"),
      MAX_PARTS((short)4, "max_parts");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // PART_VALS
            return PART_VALS;
          case 4: // MAX_PARTS
            return MAX_PARTS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __MAX_PARTS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.PART_VALS, new FieldMetaData("part_vals", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.MAX_PARTS, new FieldMetaData("max_parts", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_partition_names_ps_args.class, metaDataMap);
    }

    public get_partition_names_ps_args() {
      this.max_parts = (short)-1;

    }

    public get_partition_names_ps_args(
      String db_name,
      String tbl_name,
      List<String> part_vals,
      short max_parts)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.part_vals = part_vals;
      this.max_parts = max_parts;
      setMax_partsIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_partition_names_ps_args(get_partition_names_ps_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      if (other.isSetPart_vals()) {
        List<String> __this__part_vals = new ArrayList<String>();
        for (String other_element : other.part_vals) {
          __this__part_vals.add(other_element);
        }
        this.part_vals = __this__part_vals;
      }
      this.max_parts = other.max_parts;
    }

    public get_partition_names_ps_args deepCopy() {
      return new get_partition_names_ps_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.part_vals = null;
      this.max_parts = (short)-1;

    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public int getPart_valsSize() {
      return (this.part_vals == null) ? 0 : this.part_vals.size();
    }

    public java.util.Iterator<String> getPart_valsIterator() {
      return (this.part_vals == null) ? null : this.part_vals.iterator();
    }

    public void addToPart_vals(String elem) {
      if (this.part_vals == null) {
        this.part_vals = new ArrayList<String>();
      }
      this.part_vals.add(elem);
    }

    public List<String> getPart_vals() {
      return this.part_vals;
    }

    public void setPart_vals(List<String> part_vals) {
      this.part_vals = part_vals;
    }

    public void unsetPart_vals() {
      this.part_vals = null;
    }

    /** Returns true if field part_vals is set (has been asigned a value) and false otherwise */
    public boolean isSetPart_vals() {
      return this.part_vals != null;
    }

    public void setPart_valsIsSet(boolean value) {
      if (!value) {
        this.part_vals = null;
      }
    }

    public short getMax_parts() {
      return this.max_parts;
    }

    public void setMax_parts(short max_parts) {
      this.max_parts = max_parts;
      setMax_partsIsSet(true);
    }

    public void unsetMax_parts() {
      __isset_bit_vector.clear(__MAX_PARTS_ISSET_ID);
    }

    /** Returns true if field max_parts is set (has been asigned a value) and false otherwise */
    public boolean isSetMax_parts() {
      return __isset_bit_vector.get(__MAX_PARTS_ISSET_ID);
    }

    public void setMax_partsIsSet(boolean value) {
      __isset_bit_vector.set(__MAX_PARTS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case PART_VALS:
        if (value == null) {
          unsetPart_vals();
        } else {
          setPart_vals((List<String>)value);
        }
        break;

      case MAX_PARTS:
        if (value == null) {
          unsetMax_parts();
        } else {
          setMax_parts((Short)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case PART_VALS:
        return getPart_vals();

      case MAX_PARTS:
        return new Short(getMax_parts());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case PART_VALS:
        return isSetPart_vals();
      case MAX_PARTS:
        return isSetMax_parts();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_partition_names_ps_args)
        return this.equals((get_partition_names_ps_args)that);
      return false;
    }

    public boolean equals(get_partition_names_ps_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_part_vals = true && this.isSetPart_vals();
      boolean that_present_part_vals = true && that.isSetPart_vals();
      if (this_present_part_vals || that_present_part_vals) {
        if (!(this_present_part_vals && that_present_part_vals))
          return false;
        if (!this.part_vals.equals(that.part_vals))
          return false;
      }

      boolean this_present_max_parts = true;
      boolean that_present_max_parts = true;
      if (this_present_max_parts || that_present_max_parts) {
        if (!(this_present_max_parts && that_present_max_parts))
          return false;
        if (this.max_parts != that.max_parts)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_partition_names_ps_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_partition_names_ps_args typedOther = (get_partition_names_ps_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPart_vals()).compareTo(typedOther.isSetPart_vals());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPart_vals()) {
        lastComparison = TBaseHelper.compareTo(this.part_vals, typedOther.part_vals);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMax_parts()).compareTo(typedOther.isSetMax_parts());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMax_parts()) {
        lastComparison = TBaseHelper.compareTo(this.max_parts, typedOther.max_parts);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // PART_VALS
            if (field.type == TType.LIST) {
              {
                TList _list120 = iprot.readListBegin();
                this.part_vals = new ArrayList<String>(_list120.size);
                for (int _i121 = 0; _i121 < _list120.size; ++_i121)
                {
                  String _elem122;
                  _elem122 = iprot.readString();
                  this.part_vals.add(_elem122);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // MAX_PARTS
            if (field.type == TType.I16) {
              this.max_parts = iprot.readI16();
              setMax_partsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      if (this.part_vals != null) {
        oprot.writeFieldBegin(PART_VALS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.part_vals.size()));
          for (String _iter123 : this.part_vals)
          {
            oprot.writeString(_iter123);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(MAX_PARTS_FIELD_DESC);
      oprot.writeI16(this.max_parts);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_partition_names_ps_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("part_vals:");
      if (this.part_vals == null) {
        sb.append("null");
      } else {
        sb.append(this.part_vals);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("max_parts:");
      sb.append(this.max_parts);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_partition_names_ps_result implements TBase<get_partition_names_ps_result, get_partition_names_ps_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_partition_names_ps_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);

    private List<String> success;
    private MetaException o1;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_partition_names_ps_result.class, metaDataMap);
    }

    public get_partition_names_ps_result() {
    }

    public get_partition_names_ps_result(
      List<String> success,
      MetaException o1)
    {
      this();
      this.success = success;
      this.o1 = o1;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_partition_names_ps_result(get_partition_names_ps_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
    }

    public get_partition_names_ps_result deepCopy() {
      return new get_partition_names_ps_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<String> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_partition_names_ps_result)
        return this.equals((get_partition_names_ps_result)that);
      return false;
    }

    public boolean equals(get_partition_names_ps_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_partition_names_ps_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_partition_names_ps_result typedOther = (get_partition_names_ps_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list124 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list124.size);
                for (int _i125 = 0; _i125 < _list124.size; ++_i125)
                {
                  String _elem126;
                  _elem126 = iprot.readString();
                  this.success.add(_elem126);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter127 : this.success)
          {
            oprot.writeString(_iter127);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_partition_names_ps_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_partitions_by_filter_args implements TBase<get_partitions_by_filter_args, get_partitions_by_filter_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_partitions_by_filter_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField FILTER_FIELD_DESC = new TField("filter", TType.STRING, (short)3);
    private static final TField MAX_PARTS_FIELD_DESC = new TField("max_parts", TType.I16, (short)4);

    private String db_name;
    private String tbl_name;
    private String filter;
    private short max_parts;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      FILTER((short)3, "filter"),
      MAX_PARTS((short)4, "max_parts");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // FILTER
            return FILTER;
          case 4: // MAX_PARTS
            return MAX_PARTS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __MAX_PARTS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.FILTER, new FieldMetaData("filter", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.MAX_PARTS, new FieldMetaData("max_parts", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_partitions_by_filter_args.class, metaDataMap);
    }

    public get_partitions_by_filter_args() {
      this.max_parts = (short)-1;

    }

    public get_partitions_by_filter_args(
      String db_name,
      String tbl_name,
      String filter,
      short max_parts)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.filter = filter;
      this.max_parts = max_parts;
      setMax_partsIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_partitions_by_filter_args(get_partitions_by_filter_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      if (other.isSetFilter()) {
        this.filter = other.filter;
      }
      this.max_parts = other.max_parts;
    }

    public get_partitions_by_filter_args deepCopy() {
      return new get_partitions_by_filter_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.filter = null;
      this.max_parts = (short)-1;

    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public String getFilter() {
      return this.filter;
    }

    public void setFilter(String filter) {
      this.filter = filter;
    }

    public void unsetFilter() {
      this.filter = null;
    }

    /** Returns true if field filter is set (has been asigned a value) and false otherwise */
    public boolean isSetFilter() {
      return this.filter != null;
    }

    public void setFilterIsSet(boolean value) {
      if (!value) {
        this.filter = null;
      }
    }

    public short getMax_parts() {
      return this.max_parts;
    }

    public void setMax_parts(short max_parts) {
      this.max_parts = max_parts;
      setMax_partsIsSet(true);
    }

    public void unsetMax_parts() {
      __isset_bit_vector.clear(__MAX_PARTS_ISSET_ID);
    }

    /** Returns true if field max_parts is set (has been asigned a value) and false otherwise */
    public boolean isSetMax_parts() {
      return __isset_bit_vector.get(__MAX_PARTS_ISSET_ID);
    }

    public void setMax_partsIsSet(boolean value) {
      __isset_bit_vector.set(__MAX_PARTS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case FILTER:
        if (value == null) {
          unsetFilter();
        } else {
          setFilter((String)value);
        }
        break;

      case MAX_PARTS:
        if (value == null) {
          unsetMax_parts();
        } else {
          setMax_parts((Short)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case FILTER:
        return getFilter();

      case MAX_PARTS:
        return new Short(getMax_parts());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case FILTER:
        return isSetFilter();
      case MAX_PARTS:
        return isSetMax_parts();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_partitions_by_filter_args)
        return this.equals((get_partitions_by_filter_args)that);
      return false;
    }

    public boolean equals(get_partitions_by_filter_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_filter = true && this.isSetFilter();
      boolean that_present_filter = true && that.isSetFilter();
      if (this_present_filter || that_present_filter) {
        if (!(this_present_filter && that_present_filter))
          return false;
        if (!this.filter.equals(that.filter))
          return false;
      }

      boolean this_present_max_parts = true;
      boolean that_present_max_parts = true;
      if (this_present_max_parts || that_present_max_parts) {
        if (!(this_present_max_parts && that_present_max_parts))
          return false;
        if (this.max_parts != that.max_parts)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_partitions_by_filter_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_partitions_by_filter_args typedOther = (get_partitions_by_filter_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetFilter()).compareTo(typedOther.isSetFilter());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFilter()) {
        lastComparison = TBaseHelper.compareTo(this.filter, typedOther.filter);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMax_parts()).compareTo(typedOther.isSetMax_parts());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMax_parts()) {
        lastComparison = TBaseHelper.compareTo(this.max_parts, typedOther.max_parts);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // FILTER
            if (field.type == TType.STRING) {
              this.filter = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // MAX_PARTS
            if (field.type == TType.I16) {
              this.max_parts = iprot.readI16();
              setMax_partsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      if (this.filter != null) {
        oprot.writeFieldBegin(FILTER_FIELD_DESC);
        oprot.writeString(this.filter);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(MAX_PARTS_FIELD_DESC);
      oprot.writeI16(this.max_parts);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_partitions_by_filter_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("filter:");
      if (this.filter == null) {
        sb.append("null");
      } else {
        sb.append(this.filter);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("max_parts:");
      sb.append(this.max_parts);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_partitions_by_filter_result implements TBase<get_partitions_by_filter_result, get_partitions_by_filter_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_partitions_by_filter_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private List<Partition> success;
    private MetaException o1;
    private NoSuchObjectException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Partition.class))));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_partitions_by_filter_result.class, metaDataMap);
    }

    public get_partitions_by_filter_result() {
    }

    public get_partitions_by_filter_result(
      List<Partition> success,
      MetaException o1,
      NoSuchObjectException o2)
    {
      this();
      this.success = success;
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_partitions_by_filter_result(get_partitions_by_filter_result other) {
      if (other.isSetSuccess()) {
        List<Partition> __this__success = new ArrayList<Partition>();
        for (Partition other_element : other.success) {
          __this__success.add(new Partition(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new NoSuchObjectException(other.o2);
      }
    }

    public get_partitions_by_filter_result deepCopy() {
      return new get_partitions_by_filter_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
      this.o2 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Partition> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Partition elem) {
      if (this.success == null) {
        this.success = new ArrayList<Partition>();
      }
      this.success.add(elem);
    }

    public List<Partition> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<Partition> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public NoSuchObjectException getO2() {
      return this.o2;
    }

    public void setO2(NoSuchObjectException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Partition>)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((NoSuchObjectException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_partitions_by_filter_result)
        return this.equals((get_partitions_by_filter_result)that);
      return false;
    }

    public boolean equals(get_partitions_by_filter_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_partitions_by_filter_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_partitions_by_filter_result typedOther = (get_partitions_by_filter_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list128 = iprot.readListBegin();
                this.success = new ArrayList<Partition>(_list128.size);
                for (int _i129 = 0; _i129 < _list128.size; ++_i129)
                {
                  Partition _elem130;
                  _elem130 = new Partition();
                  _elem130.read(iprot);
                  this.success.add(_elem130);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new NoSuchObjectException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Partition _iter131 : this.success)
          {
            _iter131.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_partitions_by_filter_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alter_partition_args implements TBase<alter_partition_args, alter_partition_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("alter_partition_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField NEW_PART_FIELD_DESC = new TField("new_part", TType.STRUCT, (short)3);

    private String db_name;
    private String tbl_name;
    private Partition new_part;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      NEW_PART((short)3, "new_part");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // NEW_PART
            return NEW_PART;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.NEW_PART, new FieldMetaData("new_part", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Partition.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(alter_partition_args.class, metaDataMap);
    }

    public alter_partition_args() {
    }

    public alter_partition_args(
      String db_name,
      String tbl_name,
      Partition new_part)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.new_part = new_part;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alter_partition_args(alter_partition_args other) {
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      if (other.isSetNew_part()) {
        this.new_part = new Partition(other.new_part);
      }
    }

    public alter_partition_args deepCopy() {
      return new alter_partition_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.new_part = null;
    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public Partition getNew_part() {
      return this.new_part;
    }

    public void setNew_part(Partition new_part) {
      this.new_part = new_part;
    }

    public void unsetNew_part() {
      this.new_part = null;
    }

    /** Returns true if field new_part is set (has been asigned a value) and false otherwise */
    public boolean isSetNew_part() {
      return this.new_part != null;
    }

    public void setNew_partIsSet(boolean value) {
      if (!value) {
        this.new_part = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case NEW_PART:
        if (value == null) {
          unsetNew_part();
        } else {
          setNew_part((Partition)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case NEW_PART:
        return getNew_part();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case NEW_PART:
        return isSetNew_part();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alter_partition_args)
        return this.equals((alter_partition_args)that);
      return false;
    }

    public boolean equals(alter_partition_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_new_part = true && this.isSetNew_part();
      boolean that_present_new_part = true && that.isSetNew_part();
      if (this_present_new_part || that_present_new_part) {
        if (!(this_present_new_part && that_present_new_part))
          return false;
        if (!this.new_part.equals(that.new_part))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(alter_partition_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      alter_partition_args typedOther = (alter_partition_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetNew_part()).compareTo(typedOther.isSetNew_part());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNew_part()) {
        lastComparison = TBaseHelper.compareTo(this.new_part, typedOther.new_part);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // NEW_PART
            if (field.type == TType.STRUCT) {
              this.new_part = new Partition();
              this.new_part.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      if (this.new_part != null) {
        oprot.writeFieldBegin(NEW_PART_FIELD_DESC);
        this.new_part.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("alter_partition_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("new_part:");
      if (this.new_part == null) {
        sb.append("null");
      } else {
        sb.append(this.new_part);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alter_partition_result implements TBase<alter_partition_result, alter_partition_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("alter_partition_result");

    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private InvalidOperationException o1;
    private MetaException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(alter_partition_result.class, metaDataMap);
    }

    public alter_partition_result() {
    }

    public alter_partition_result(
      InvalidOperationException o1,
      MetaException o2)
    {
      this();
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alter_partition_result(alter_partition_result other) {
      if (other.isSetO1()) {
        this.o1 = new InvalidOperationException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new MetaException(other.o2);
      }
    }

    public alter_partition_result deepCopy() {
      return new alter_partition_result(this);
    }

    @Override
    public void clear() {
      this.o1 = null;
      this.o2 = null;
    }

    public InvalidOperationException getO1() {
      return this.o1;
    }

    public void setO1(InvalidOperationException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public MetaException getO2() {
      return this.o2;
    }

    public void setO2(MetaException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((InvalidOperationException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alter_partition_result)
        return this.equals((alter_partition_result)that);
      return false;
    }

    public boolean equals(alter_partition_result that) {
      if (that == null)
        return false;

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(alter_partition_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      alter_partition_result typedOther = (alter_partition_result)other;

      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new InvalidOperationException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new MetaException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("alter_partition_result(");
      boolean first = true;

      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_config_value_args implements TBase<get_config_value_args, get_config_value_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_config_value_args");

    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);
    private static final TField DEFAULT_VALUE_FIELD_DESC = new TField("defaultValue", TType.STRING, (short)2);

    private String name;
    private String defaultValue;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NAME((short)1, "name"),
      DEFAULT_VALUE((short)2, "defaultValue");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NAME
            return NAME;
          case 2: // DEFAULT_VALUE
            return DEFAULT_VALUE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.DEFAULT_VALUE, new FieldMetaData("defaultValue", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_config_value_args.class, metaDataMap);
    }

    public get_config_value_args() {
    }

    public get_config_value_args(
      String name,
      String defaultValue)
    {
      this();
      this.name = name;
      this.defaultValue = defaultValue;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_config_value_args(get_config_value_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
      if (other.isSetDefaultValue()) {
        this.defaultValue = other.defaultValue;
      }
    }

    public get_config_value_args deepCopy() {
      return new get_config_value_args(this);
    }

    @Override
    public void clear() {
      this.name = null;
      this.defaultValue = null;
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    /** Returns true if field name is set (has been asigned a value) and false otherwise */
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public String getDefaultValue() {
      return this.defaultValue;
    }

    public void setDefaultValue(String defaultValue) {
      this.defaultValue = defaultValue;
    }

    public void unsetDefaultValue() {
      this.defaultValue = null;
    }

    /** Returns true if field defaultValue is set (has been asigned a value) and false otherwise */
    public boolean isSetDefaultValue() {
      return this.defaultValue != null;
    }

    public void setDefaultValueIsSet(boolean value) {
      if (!value) {
        this.defaultValue = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case DEFAULT_VALUE:
        if (value == null) {
          unsetDefaultValue();
        } else {
          setDefaultValue((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NAME:
        return getName();

      case DEFAULT_VALUE:
        return getDefaultValue();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NAME:
        return isSetName();
      case DEFAULT_VALUE:
        return isSetDefaultValue();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_config_value_args)
        return this.equals((get_config_value_args)that);
      return false;
    }

    public boolean equals(get_config_value_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_defaultValue = true && this.isSetDefaultValue();
      boolean that_present_defaultValue = true && that.isSetDefaultValue();
      if (this_present_defaultValue || that_present_defaultValue) {
        if (!(this_present_defaultValue && that_present_defaultValue))
          return false;
        if (!this.defaultValue.equals(that.defaultValue))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_config_value_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_config_value_args typedOther = (get_config_value_args)other;

      lastComparison = Boolean.valueOf(isSetName()).compareTo(typedOther.isSetName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetName()) {
        lastComparison = TBaseHelper.compareTo(this.name, typedOther.name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetDefaultValue()).compareTo(typedOther.isSetDefaultValue());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDefaultValue()) {
        lastComparison = TBaseHelper.compareTo(this.defaultValue, typedOther.defaultValue);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NAME
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // DEFAULT_VALUE
            if (field.type == TType.STRING) {
              this.defaultValue = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      if (this.defaultValue != null) {
        oprot.writeFieldBegin(DEFAULT_VALUE_FIELD_DESC);
        oprot.writeString(this.defaultValue);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_config_value_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("defaultValue:");
      if (this.defaultValue == null) {
        sb.append("null");
      } else {
        sb.append(this.defaultValue);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_config_value_result implements TBase<get_config_value_result, get_config_value_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_config_value_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);

    private String success;
    private ConfigValSecurityException o1;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_config_value_result.class, metaDataMap);
    }

    public get_config_value_result() {
    }

    public get_config_value_result(
      String success,
      ConfigValSecurityException o1)
    {
      this();
      this.success = success;
      this.o1 = o1;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_config_value_result(get_config_value_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetO1()) {
        this.o1 = new ConfigValSecurityException(other.o1);
      }
    }

    public get_config_value_result deepCopy() {
      return new get_config_value_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public void setSuccess(String success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ConfigValSecurityException getO1() {
      return this.o1;
    }

    public void setO1(ConfigValSecurityException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((ConfigValSecurityException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_config_value_result)
        return this.equals((get_config_value_result)that);
      return false;
    }

    public boolean equals(get_config_value_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_config_value_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_config_value_result typedOther = (get_config_value_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new ConfigValSecurityException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_config_value_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class partition_name_to_vals_args implements TBase<partition_name_to_vals_args, partition_name_to_vals_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("partition_name_to_vals_args");

    private static final TField PART_NAME_FIELD_DESC = new TField("part_name", TType.STRING, (short)1);

    private String part_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PART_NAME((short)1, "part_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PART_NAME
            return PART_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PART_NAME, new FieldMetaData("part_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(partition_name_to_vals_args.class, metaDataMap);
    }

    public partition_name_to_vals_args() {
    }

    public partition_name_to_vals_args(
      String part_name)
    {
      this();
      this.part_name = part_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public partition_name_to_vals_args(partition_name_to_vals_args other) {
      if (other.isSetPart_name()) {
        this.part_name = other.part_name;
      }
    }

    public partition_name_to_vals_args deepCopy() {
      return new partition_name_to_vals_args(this);
    }

    @Override
    public void clear() {
      this.part_name = null;
    }

    public String getPart_name() {
      return this.part_name;
    }

    public void setPart_name(String part_name) {
      this.part_name = part_name;
    }

    public void unsetPart_name() {
      this.part_name = null;
    }

    /** Returns true if field part_name is set (has been asigned a value) and false otherwise */
    public boolean isSetPart_name() {
      return this.part_name != null;
    }

    public void setPart_nameIsSet(boolean value) {
      if (!value) {
        this.part_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PART_NAME:
        if (value == null) {
          unsetPart_name();
        } else {
          setPart_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PART_NAME:
        return getPart_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PART_NAME:
        return isSetPart_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof partition_name_to_vals_args)
        return this.equals((partition_name_to_vals_args)that);
      return false;
    }

    public boolean equals(partition_name_to_vals_args that) {
      if (that == null)
        return false;

      boolean this_present_part_name = true && this.isSetPart_name();
      boolean that_present_part_name = true && that.isSetPart_name();
      if (this_present_part_name || that_present_part_name) {
        if (!(this_present_part_name && that_present_part_name))
          return false;
        if (!this.part_name.equals(that.part_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(partition_name_to_vals_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      partition_name_to_vals_args typedOther = (partition_name_to_vals_args)other;

      lastComparison = Boolean.valueOf(isSetPart_name()).compareTo(typedOther.isSetPart_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPart_name()) {
        lastComparison = TBaseHelper.compareTo(this.part_name, typedOther.part_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PART_NAME
            if (field.type == TType.STRING) {
              this.part_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.part_name != null) {
        oprot.writeFieldBegin(PART_NAME_FIELD_DESC);
        oprot.writeString(this.part_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("partition_name_to_vals_args(");
      boolean first = true;

      sb.append("part_name:");
      if (this.part_name == null) {
        sb.append("null");
      } else {
        sb.append(this.part_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class partition_name_to_vals_result implements TBase<partition_name_to_vals_result, partition_name_to_vals_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("partition_name_to_vals_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);

    private List<String> success;
    private MetaException o1;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(partition_name_to_vals_result.class, metaDataMap);
    }

    public partition_name_to_vals_result() {
    }

    public partition_name_to_vals_result(
      List<String> success,
      MetaException o1)
    {
      this();
      this.success = success;
      this.o1 = o1;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public partition_name_to_vals_result(partition_name_to_vals_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
    }

    public partition_name_to_vals_result deepCopy() {
      return new partition_name_to_vals_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<String> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof partition_name_to_vals_result)
        return this.equals((partition_name_to_vals_result)that);
      return false;
    }

    public boolean equals(partition_name_to_vals_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(partition_name_to_vals_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      partition_name_to_vals_result typedOther = (partition_name_to_vals_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list132 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list132.size);
                for (int _i133 = 0; _i133 < _list132.size; ++_i133)
                {
                  String _elem134;
                  _elem134 = iprot.readString();
                  this.success.add(_elem134);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter135 : this.success)
          {
            oprot.writeString(_iter135);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("partition_name_to_vals_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class partition_name_to_spec_args implements TBase<partition_name_to_spec_args, partition_name_to_spec_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("partition_name_to_spec_args");

    private static final TField PART_NAME_FIELD_DESC = new TField("part_name", TType.STRING, (short)1);

    private String part_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PART_NAME((short)1, "part_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PART_NAME
            return PART_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PART_NAME, new FieldMetaData("part_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(partition_name_to_spec_args.class, metaDataMap);
    }

    public partition_name_to_spec_args() {
    }

    public partition_name_to_spec_args(
      String part_name)
    {
      this();
      this.part_name = part_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public partition_name_to_spec_args(partition_name_to_spec_args other) {
      if (other.isSetPart_name()) {
        this.part_name = other.part_name;
      }
    }

    public partition_name_to_spec_args deepCopy() {
      return new partition_name_to_spec_args(this);
    }

    @Override
    public void clear() {
      this.part_name = null;
    }

    public String getPart_name() {
      return this.part_name;
    }

    public void setPart_name(String part_name) {
      this.part_name = part_name;
    }

    public void unsetPart_name() {
      this.part_name = null;
    }

    /** Returns true if field part_name is set (has been asigned a value) and false otherwise */
    public boolean isSetPart_name() {
      return this.part_name != null;
    }

    public void setPart_nameIsSet(boolean value) {
      if (!value) {
        this.part_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PART_NAME:
        if (value == null) {
          unsetPart_name();
        } else {
          setPart_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PART_NAME:
        return getPart_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PART_NAME:
        return isSetPart_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof partition_name_to_spec_args)
        return this.equals((partition_name_to_spec_args)that);
      return false;
    }

    public boolean equals(partition_name_to_spec_args that) {
      if (that == null)
        return false;

      boolean this_present_part_name = true && this.isSetPart_name();
      boolean that_present_part_name = true && that.isSetPart_name();
      if (this_present_part_name || that_present_part_name) {
        if (!(this_present_part_name && that_present_part_name))
          return false;
        if (!this.part_name.equals(that.part_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(partition_name_to_spec_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      partition_name_to_spec_args typedOther = (partition_name_to_spec_args)other;

      lastComparison = Boolean.valueOf(isSetPart_name()).compareTo(typedOther.isSetPart_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPart_name()) {
        lastComparison = TBaseHelper.compareTo(this.part_name, typedOther.part_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PART_NAME
            if (field.type == TType.STRING) {
              this.part_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.part_name != null) {
        oprot.writeFieldBegin(PART_NAME_FIELD_DESC);
        oprot.writeString(this.part_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("partition_name_to_spec_args(");
      boolean first = true;

      sb.append("part_name:");
      if (this.part_name == null) {
        sb.append("null");
      } else {
        sb.append(this.part_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class partition_name_to_spec_result implements TBase<partition_name_to_spec_result, partition_name_to_spec_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("partition_name_to_spec_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);

    private Map<String,String> success;
    private MetaException o1;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(partition_name_to_spec_result.class, metaDataMap);
    }

    public partition_name_to_spec_result() {
    }

    public partition_name_to_spec_result(
      Map<String,String> success,
      MetaException o1)
    {
      this();
      this.success = success;
      this.o1 = o1;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public partition_name_to_spec_result(partition_name_to_spec_result other) {
      if (other.isSetSuccess()) {
        Map<String,String> __this__success = new HashMap<String,String>();
        for (Map.Entry<String, String> other_element : other.success.entrySet()) {

          String other_element_key = other_element.getKey();
          String other_element_value = other_element.getValue();

          String __this__success_copy_key = other_element_key;

          String __this__success_copy_value = other_element_value;

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
    }

    public partition_name_to_spec_result deepCopy() {
      return new partition_name_to_spec_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(String key, String val) {
      if (this.success == null) {
        this.success = new HashMap<String,String>();
      }
      this.success.put(key, val);
    }

    public Map<String,String> getSuccess() {
      return this.success;
    }

    public void setSuccess(Map<String,String> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<String,String>)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof partition_name_to_spec_result)
        return this.equals((partition_name_to_spec_result)that);
      return false;
    }

    public boolean equals(partition_name_to_spec_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(partition_name_to_spec_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      partition_name_to_spec_result typedOther = (partition_name_to_spec_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.MAP) {
              {
                TMap _map136 = iprot.readMapBegin();
                this.success = new HashMap<String,String>(2*_map136.size);
                for (int _i137 = 0; _i137 < _map136.size; ++_i137)
                {
                  String _key138;
                  String _val139;
                  _key138 = iprot.readString();
                  _val139 = iprot.readString();
                  this.success.put(_key138, _val139);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.success.size()));
          for (Map.Entry<String, String> _iter140 : this.success.entrySet())
          {
            oprot.writeString(_iter140.getKey());
            oprot.writeString(_iter140.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("partition_name_to_spec_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class add_index_args implements TBase<add_index_args, add_index_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("add_index_args");

    private static final TField NEW_INDEX_FIELD_DESC = new TField("new_index", TType.STRUCT, (short)1);
    private static final TField INDEX_TABLE_FIELD_DESC = new TField("index_table", TType.STRUCT, (short)2);

    private Index new_index;
    private Table index_table;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NEW_INDEX((short)1, "new_index"),
      INDEX_TABLE((short)2, "index_table");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NEW_INDEX
            return NEW_INDEX;
          case 2: // INDEX_TABLE
            return INDEX_TABLE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NEW_INDEX, new FieldMetaData("new_index", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Index.class)));
      tmpMap.put(_Fields.INDEX_TABLE, new FieldMetaData("index_table", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Table.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(add_index_args.class, metaDataMap);
    }

    public add_index_args() {
    }

    public add_index_args(
      Index new_index,
      Table index_table)
    {
      this();
      this.new_index = new_index;
      this.index_table = index_table;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public add_index_args(add_index_args other) {
      if (other.isSetNew_index()) {
        this.new_index = new Index(other.new_index);
      }
      if (other.isSetIndex_table()) {
        this.index_table = new Table(other.index_table);
      }
    }

    public add_index_args deepCopy() {
      return new add_index_args(this);
    }

    @Override
    public void clear() {
      this.new_index = null;
      this.index_table = null;
    }

    public Index getNew_index() {
      return this.new_index;
    }

    public void setNew_index(Index new_index) {
      this.new_index = new_index;
    }

    public void unsetNew_index() {
      this.new_index = null;
    }

    /** Returns true if field new_index is set (has been asigned a value) and false otherwise */
    public boolean isSetNew_index() {
      return this.new_index != null;
    }

    public void setNew_indexIsSet(boolean value) {
      if (!value) {
        this.new_index = null;
      }
    }

    public Table getIndex_table() {
      return this.index_table;
    }

    public void setIndex_table(Table index_table) {
      this.index_table = index_table;
    }

    public void unsetIndex_table() {
      this.index_table = null;
    }

    /** Returns true if field index_table is set (has been asigned a value) and false otherwise */
    public boolean isSetIndex_table() {
      return this.index_table != null;
    }

    public void setIndex_tableIsSet(boolean value) {
      if (!value) {
        this.index_table = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NEW_INDEX:
        if (value == null) {
          unsetNew_index();
        } else {
          setNew_index((Index)value);
        }
        break;

      case INDEX_TABLE:
        if (value == null) {
          unsetIndex_table();
        } else {
          setIndex_table((Table)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NEW_INDEX:
        return getNew_index();

      case INDEX_TABLE:
        return getIndex_table();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NEW_INDEX:
        return isSetNew_index();
      case INDEX_TABLE:
        return isSetIndex_table();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof add_index_args)
        return this.equals((add_index_args)that);
      return false;
    }

    public boolean equals(add_index_args that) {
      if (that == null)
        return false;

      boolean this_present_new_index = true && this.isSetNew_index();
      boolean that_present_new_index = true && that.isSetNew_index();
      if (this_present_new_index || that_present_new_index) {
        if (!(this_present_new_index && that_present_new_index))
          return false;
        if (!this.new_index.equals(that.new_index))
          return false;
      }

      boolean this_present_index_table = true && this.isSetIndex_table();
      boolean that_present_index_table = true && that.isSetIndex_table();
      if (this_present_index_table || that_present_index_table) {
        if (!(this_present_index_table && that_present_index_table))
          return false;
        if (!this.index_table.equals(that.index_table))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(add_index_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      add_index_args typedOther = (add_index_args)other;

      lastComparison = Boolean.valueOf(isSetNew_index()).compareTo(typedOther.isSetNew_index());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNew_index()) {
        lastComparison = TBaseHelper.compareTo(this.new_index, typedOther.new_index);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIndex_table()).compareTo(typedOther.isSetIndex_table());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIndex_table()) {
        lastComparison = TBaseHelper.compareTo(this.index_table, typedOther.index_table);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NEW_INDEX
            if (field.type == TType.STRUCT) {
              this.new_index = new Index();
              this.new_index.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // INDEX_TABLE
            if (field.type == TType.STRUCT) {
              this.index_table = new Table();
              this.index_table.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.new_index != null) {
        oprot.writeFieldBegin(NEW_INDEX_FIELD_DESC);
        this.new_index.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.index_table != null) {
        oprot.writeFieldBegin(INDEX_TABLE_FIELD_DESC);
        this.index_table.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("add_index_args(");
      boolean first = true;

      sb.append("new_index:");
      if (this.new_index == null) {
        sb.append("null");
      } else {
        sb.append(this.new_index);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("index_table:");
      if (this.index_table == null) {
        sb.append("null");
      } else {
        sb.append(this.index_table);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class add_index_result implements TBase<add_index_result, add_index_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("add_index_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);
    private static final TField O3_FIELD_DESC = new TField("o3", TType.STRUCT, (short)3);

    private Index success;
    private InvalidObjectException o1;
    private AlreadyExistsException o2;
    private MetaException o3;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2"),
      O3((short)3, "o3");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          case 3: // O3
            return O3;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Index.class)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O3, new FieldMetaData("o3", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(add_index_result.class, metaDataMap);
    }

    public add_index_result() {
    }

    public add_index_result(
      Index success,
      InvalidObjectException o1,
      AlreadyExistsException o2,
      MetaException o3)
    {
      this();
      this.success = success;
      this.o1 = o1;
      this.o2 = o2;
      this.o3 = o3;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public add_index_result(add_index_result other) {
      if (other.isSetSuccess()) {
        this.success = new Index(other.success);
      }
      if (other.isSetO1()) {
        this.o1 = new InvalidObjectException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new AlreadyExistsException(other.o2);
      }
      if (other.isSetO3()) {
        this.o3 = new MetaException(other.o3);
      }
    }

    public add_index_result deepCopy() {
      return new add_index_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
      this.o2 = null;
      this.o3 = null;
    }

    public Index getSuccess() {
      return this.success;
    }

    public void setSuccess(Index success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidObjectException getO1() {
      return this.o1;
    }

    public void setO1(InvalidObjectException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public AlreadyExistsException getO2() {
      return this.o2;
    }

    public void setO2(AlreadyExistsException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public MetaException getO3() {
      return this.o3;
    }

    public void setO3(MetaException o3) {
      this.o3 = o3;
    }

    public void unsetO3() {
      this.o3 = null;
    }

    /** Returns true if field o3 is set (has been asigned a value) and false otherwise */
    public boolean isSetO3() {
      return this.o3 != null;
    }

    public void setO3IsSet(boolean value) {
      if (!value) {
        this.o3 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Index)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((InvalidObjectException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((AlreadyExistsException)value);
        }
        break;

      case O3:
        if (value == null) {
          unsetO3();
        } else {
          setO3((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      case O2:
        return getO2();

      case O3:
        return getO3();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      case O3:
        return isSetO3();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof add_index_result)
        return this.equals((add_index_result)that);
      return false;
    }

    public boolean equals(add_index_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      boolean this_present_o3 = true && this.isSetO3();
      boolean that_present_o3 = true && that.isSetO3();
      if (this_present_o3 || that_present_o3) {
        if (!(this_present_o3 && that_present_o3))
          return false;
        if (!this.o3.equals(that.o3))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(add_index_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      add_index_result typedOther = (add_index_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO3()).compareTo(typedOther.isSetO3());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO3()) {
        lastComparison = TBaseHelper.compareTo(this.o3, typedOther.o3);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new Index();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new InvalidObjectException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new AlreadyExistsException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // O3
            if (field.type == TType.STRUCT) {
              this.o3 = new MetaException();
              this.o3.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO3()) {
        oprot.writeFieldBegin(O3_FIELD_DESC);
        this.o3.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("add_index_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o3:");
      if (this.o3 == null) {
        sb.append("null");
      } else {
        sb.append(this.o3);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alter_index_args implements TBase<alter_index_args, alter_index_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("alter_index_args");

    private static final TField DBNAME_FIELD_DESC = new TField("dbname", TType.STRING, (short)1);
    private static final TField BASE_TBL_NAME_FIELD_DESC = new TField("base_tbl_name", TType.STRING, (short)2);
    private static final TField IDX_NAME_FIELD_DESC = new TField("idx_name", TType.STRING, (short)3);
    private static final TField NEW_IDX_FIELD_DESC = new TField("new_idx", TType.STRUCT, (short)4);

    private String dbname;
    private String base_tbl_name;
    private String idx_name;
    private Index new_idx;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DBNAME((short)1, "dbname"),
      BASE_TBL_NAME((short)2, "base_tbl_name"),
      IDX_NAME((short)3, "idx_name"),
      NEW_IDX((short)4, "new_idx");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DBNAME
            return DBNAME;
          case 2: // BASE_TBL_NAME
            return BASE_TBL_NAME;
          case 3: // IDX_NAME
            return IDX_NAME;
          case 4: // NEW_IDX
            return NEW_IDX;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DBNAME, new FieldMetaData("dbname", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.BASE_TBL_NAME, new FieldMetaData("base_tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.IDX_NAME, new FieldMetaData("idx_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.NEW_IDX, new FieldMetaData("new_idx", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Index.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(alter_index_args.class, metaDataMap);
    }

    public alter_index_args() {
    }

    public alter_index_args(
      String dbname,
      String base_tbl_name,
      String idx_name,
      Index new_idx)
    {
      this();
      this.dbname = dbname;
      this.base_tbl_name = base_tbl_name;
      this.idx_name = idx_name;
      this.new_idx = new_idx;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alter_index_args(alter_index_args other) {
      if (other.isSetDbname()) {
        this.dbname = other.dbname;
      }
      if (other.isSetBase_tbl_name()) {
        this.base_tbl_name = other.base_tbl_name;
      }
      if (other.isSetIdx_name()) {
        this.idx_name = other.idx_name;
      }
      if (other.isSetNew_idx()) {
        this.new_idx = new Index(other.new_idx);
      }
    }

    public alter_index_args deepCopy() {
      return new alter_index_args(this);
    }

    @Override
    public void clear() {
      this.dbname = null;
      this.base_tbl_name = null;
      this.idx_name = null;
      this.new_idx = null;
    }

    public String getDbname() {
      return this.dbname;
    }

    public void setDbname(String dbname) {
      this.dbname = dbname;
    }

    public void unsetDbname() {
      this.dbname = null;
    }

    /** Returns true if field dbname is set (has been asigned a value) and false otherwise */
    public boolean isSetDbname() {
      return this.dbname != null;
    }

    public void setDbnameIsSet(boolean value) {
      if (!value) {
        this.dbname = null;
      }
    }

    public String getBase_tbl_name() {
      return this.base_tbl_name;
    }

    public void setBase_tbl_name(String base_tbl_name) {
      this.base_tbl_name = base_tbl_name;
    }

    public void unsetBase_tbl_name() {
      this.base_tbl_name = null;
    }

    /** Returns true if field base_tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetBase_tbl_name() {
      return this.base_tbl_name != null;
    }

    public void setBase_tbl_nameIsSet(boolean value) {
      if (!value) {
        this.base_tbl_name = null;
      }
    }

    public String getIdx_name() {
      return this.idx_name;
    }

    public void setIdx_name(String idx_name) {
      this.idx_name = idx_name;
    }

    public void unsetIdx_name() {
      this.idx_name = null;
    }

    /** Returns true if field idx_name is set (has been asigned a value) and false otherwise */
    public boolean isSetIdx_name() {
      return this.idx_name != null;
    }

    public void setIdx_nameIsSet(boolean value) {
      if (!value) {
        this.idx_name = null;
      }
    }

    public Index getNew_idx() {
      return this.new_idx;
    }

    public void setNew_idx(Index new_idx) {
      this.new_idx = new_idx;
    }

    public void unsetNew_idx() {
      this.new_idx = null;
    }

    /** Returns true if field new_idx is set (has been asigned a value) and false otherwise */
    public boolean isSetNew_idx() {
      return this.new_idx != null;
    }

    public void setNew_idxIsSet(boolean value) {
      if (!value) {
        this.new_idx = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DBNAME:
        if (value == null) {
          unsetDbname();
        } else {
          setDbname((String)value);
        }
        break;

      case BASE_TBL_NAME:
        if (value == null) {
          unsetBase_tbl_name();
        } else {
          setBase_tbl_name((String)value);
        }
        break;

      case IDX_NAME:
        if (value == null) {
          unsetIdx_name();
        } else {
          setIdx_name((String)value);
        }
        break;

      case NEW_IDX:
        if (value == null) {
          unsetNew_idx();
        } else {
          setNew_idx((Index)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DBNAME:
        return getDbname();

      case BASE_TBL_NAME:
        return getBase_tbl_name();

      case IDX_NAME:
        return getIdx_name();

      case NEW_IDX:
        return getNew_idx();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DBNAME:
        return isSetDbname();
      case BASE_TBL_NAME:
        return isSetBase_tbl_name();
      case IDX_NAME:
        return isSetIdx_name();
      case NEW_IDX:
        return isSetNew_idx();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alter_index_args)
        return this.equals((alter_index_args)that);
      return false;
    }

    public boolean equals(alter_index_args that) {
      if (that == null)
        return false;

      boolean this_present_dbname = true && this.isSetDbname();
      boolean that_present_dbname = true && that.isSetDbname();
      if (this_present_dbname || that_present_dbname) {
        if (!(this_present_dbname && that_present_dbname))
          return false;
        if (!this.dbname.equals(that.dbname))
          return false;
      }

      boolean this_present_base_tbl_name = true && this.isSetBase_tbl_name();
      boolean that_present_base_tbl_name = true && that.isSetBase_tbl_name();
      if (this_present_base_tbl_name || that_present_base_tbl_name) {
        if (!(this_present_base_tbl_name && that_present_base_tbl_name))
          return false;
        if (!this.base_tbl_name.equals(that.base_tbl_name))
          return false;
      }

      boolean this_present_idx_name = true && this.isSetIdx_name();
      boolean that_present_idx_name = true && that.isSetIdx_name();
      if (this_present_idx_name || that_present_idx_name) {
        if (!(this_present_idx_name && that_present_idx_name))
          return false;
        if (!this.idx_name.equals(that.idx_name))
          return false;
      }

      boolean this_present_new_idx = true && this.isSetNew_idx();
      boolean that_present_new_idx = true && that.isSetNew_idx();
      if (this_present_new_idx || that_present_new_idx) {
        if (!(this_present_new_idx && that_present_new_idx))
          return false;
        if (!this.new_idx.equals(that.new_idx))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(alter_index_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      alter_index_args typedOther = (alter_index_args)other;

      lastComparison = Boolean.valueOf(isSetDbname()).compareTo(typedOther.isSetDbname());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDbname()) {
        lastComparison = TBaseHelper.compareTo(this.dbname, typedOther.dbname);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetBase_tbl_name()).compareTo(typedOther.isSetBase_tbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetBase_tbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.base_tbl_name, typedOther.base_tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIdx_name()).compareTo(typedOther.isSetIdx_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIdx_name()) {
        lastComparison = TBaseHelper.compareTo(this.idx_name, typedOther.idx_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetNew_idx()).compareTo(typedOther.isSetNew_idx());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNew_idx()) {
        lastComparison = TBaseHelper.compareTo(this.new_idx, typedOther.new_idx);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DBNAME
            if (field.type == TType.STRING) {
              this.dbname = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // BASE_TBL_NAME
            if (field.type == TType.STRING) {
              this.base_tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // IDX_NAME
            if (field.type == TType.STRING) {
              this.idx_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // NEW_IDX
            if (field.type == TType.STRUCT) {
              this.new_idx = new Index();
              this.new_idx.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.dbname != null) {
        oprot.writeFieldBegin(DBNAME_FIELD_DESC);
        oprot.writeString(this.dbname);
        oprot.writeFieldEnd();
      }
      if (this.base_tbl_name != null) {
        oprot.writeFieldBegin(BASE_TBL_NAME_FIELD_DESC);
        oprot.writeString(this.base_tbl_name);
        oprot.writeFieldEnd();
      }
      if (this.idx_name != null) {
        oprot.writeFieldBegin(IDX_NAME_FIELD_DESC);
        oprot.writeString(this.idx_name);
        oprot.writeFieldEnd();
      }
      if (this.new_idx != null) {
        oprot.writeFieldBegin(NEW_IDX_FIELD_DESC);
        this.new_idx.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("alter_index_args(");
      boolean first = true;

      sb.append("dbname:");
      if (this.dbname == null) {
        sb.append("null");
      } else {
        sb.append(this.dbname);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("base_tbl_name:");
      if (this.base_tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.base_tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("idx_name:");
      if (this.idx_name == null) {
        sb.append("null");
      } else {
        sb.append(this.idx_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("new_idx:");
      if (this.new_idx == null) {
        sb.append("null");
      } else {
        sb.append(this.new_idx);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class alter_index_result implements TBase<alter_index_result, alter_index_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("alter_index_result");

    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private InvalidOperationException o1;
    private MetaException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(alter_index_result.class, metaDataMap);
    }

    public alter_index_result() {
    }

    public alter_index_result(
      InvalidOperationException o1,
      MetaException o2)
    {
      this();
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public alter_index_result(alter_index_result other) {
      if (other.isSetO1()) {
        this.o1 = new InvalidOperationException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new MetaException(other.o2);
      }
    }

    public alter_index_result deepCopy() {
      return new alter_index_result(this);
    }

    @Override
    public void clear() {
      this.o1 = null;
      this.o2 = null;
    }

    public InvalidOperationException getO1() {
      return this.o1;
    }

    public void setO1(InvalidOperationException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public MetaException getO2() {
      return this.o2;
    }

    public void setO2(MetaException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((InvalidOperationException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof alter_index_result)
        return this.equals((alter_index_result)that);
      return false;
    }

    public boolean equals(alter_index_result that) {
      if (that == null)
        return false;

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(alter_index_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      alter_index_result typedOther = (alter_index_result)other;

      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new InvalidOperationException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new MetaException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("alter_index_result(");
      boolean first = true;

      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_index_by_name_args implements TBase<drop_index_by_name_args, drop_index_by_name_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_index_by_name_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField INDEX_NAME_FIELD_DESC = new TField("index_name", TType.STRING, (short)3);
    private static final TField DELETE_DATA_FIELD_DESC = new TField("deleteData", TType.BOOL, (short)4);

    private String db_name;
    private String tbl_name;
    private String index_name;
    private boolean deleteData;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      INDEX_NAME((short)3, "index_name"),
      DELETE_DATA((short)4, "deleteData");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // INDEX_NAME
            return INDEX_NAME;
          case 4: // DELETE_DATA
            return DELETE_DATA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __DELETEDATA_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.INDEX_NAME, new FieldMetaData("index_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.DELETE_DATA, new FieldMetaData("deleteData", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_index_by_name_args.class, metaDataMap);
    }

    public drop_index_by_name_args() {
    }

    public drop_index_by_name_args(
      String db_name,
      String tbl_name,
      String index_name,
      boolean deleteData)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.index_name = index_name;
      this.deleteData = deleteData;
      setDeleteDataIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_index_by_name_args(drop_index_by_name_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      if (other.isSetIndex_name()) {
        this.index_name = other.index_name;
      }
      this.deleteData = other.deleteData;
    }

    public drop_index_by_name_args deepCopy() {
      return new drop_index_by_name_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.index_name = null;
      setDeleteDataIsSet(false);
      this.deleteData = false;
    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public String getIndex_name() {
      return this.index_name;
    }

    public void setIndex_name(String index_name) {
      this.index_name = index_name;
    }

    public void unsetIndex_name() {
      this.index_name = null;
    }

    /** Returns true if field index_name is set (has been asigned a value) and false otherwise */
    public boolean isSetIndex_name() {
      return this.index_name != null;
    }

    public void setIndex_nameIsSet(boolean value) {
      if (!value) {
        this.index_name = null;
      }
    }

    public boolean isDeleteData() {
      return this.deleteData;
    }

    public void setDeleteData(boolean deleteData) {
      this.deleteData = deleteData;
      setDeleteDataIsSet(true);
    }

    public void unsetDeleteData() {
      __isset_bit_vector.clear(__DELETEDATA_ISSET_ID);
    }

    /** Returns true if field deleteData is set (has been asigned a value) and false otherwise */
    public boolean isSetDeleteData() {
      return __isset_bit_vector.get(__DELETEDATA_ISSET_ID);
    }

    public void setDeleteDataIsSet(boolean value) {
      __isset_bit_vector.set(__DELETEDATA_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case INDEX_NAME:
        if (value == null) {
          unsetIndex_name();
        } else {
          setIndex_name((String)value);
        }
        break;

      case DELETE_DATA:
        if (value == null) {
          unsetDeleteData();
        } else {
          setDeleteData((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case INDEX_NAME:
        return getIndex_name();

      case DELETE_DATA:
        return new Boolean(isDeleteData());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case INDEX_NAME:
        return isSetIndex_name();
      case DELETE_DATA:
        return isSetDeleteData();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_index_by_name_args)
        return this.equals((drop_index_by_name_args)that);
      return false;
    }

    public boolean equals(drop_index_by_name_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_index_name = true && this.isSetIndex_name();
      boolean that_present_index_name = true && that.isSetIndex_name();
      if (this_present_index_name || that_present_index_name) {
        if (!(this_present_index_name && that_present_index_name))
          return false;
        if (!this.index_name.equals(that.index_name))
          return false;
      }

      boolean this_present_deleteData = true;
      boolean that_present_deleteData = true;
      if (this_present_deleteData || that_present_deleteData) {
        if (!(this_present_deleteData && that_present_deleteData))
          return false;
        if (this.deleteData != that.deleteData)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_index_by_name_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_index_by_name_args typedOther = (drop_index_by_name_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIndex_name()).compareTo(typedOther.isSetIndex_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIndex_name()) {
        lastComparison = TBaseHelper.compareTo(this.index_name, typedOther.index_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetDeleteData()).compareTo(typedOther.isSetDeleteData());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDeleteData()) {
        lastComparison = TBaseHelper.compareTo(this.deleteData, typedOther.deleteData);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // INDEX_NAME
            if (field.type == TType.STRING) {
              this.index_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // DELETE_DATA
            if (field.type == TType.BOOL) {
              this.deleteData = iprot.readBool();
              setDeleteDataIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      if (this.index_name != null) {
        oprot.writeFieldBegin(INDEX_NAME_FIELD_DESC);
        oprot.writeString(this.index_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(DELETE_DATA_FIELD_DESC);
      oprot.writeBool(this.deleteData);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_index_by_name_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("index_name:");
      if (this.index_name == null) {
        sb.append("null");
      } else {
        sb.append(this.index_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("deleteData:");
      sb.append(this.deleteData);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_index_by_name_result implements TBase<drop_index_by_name_result, drop_index_by_name_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_index_by_name_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private boolean success;
    private NoSuchObjectException o1;
    private MetaException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_index_by_name_result.class, metaDataMap);
    }

    public drop_index_by_name_result() {
    }

    public drop_index_by_name_result(
      boolean success,
      NoSuchObjectException o1,
      MetaException o2)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_index_by_name_result(drop_index_by_name_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetO1()) {
        this.o1 = new NoSuchObjectException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new MetaException(other.o2);
      }
    }

    public drop_index_by_name_result deepCopy() {
      return new drop_index_by_name_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
      this.o1 = null;
      this.o2 = null;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public NoSuchObjectException getO1() {
      return this.o1;
    }

    public void setO1(NoSuchObjectException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public MetaException getO2() {
      return this.o2;
    }

    public void setO2(MetaException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((NoSuchObjectException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_index_by_name_result)
        return this.equals((drop_index_by_name_result)that);
      return false;
    }

    public boolean equals(drop_index_by_name_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_index_by_name_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_index_by_name_result typedOther = (drop_index_by_name_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new NoSuchObjectException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new MetaException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_index_by_name_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_index_by_name_args implements TBase<get_index_by_name_args, get_index_by_name_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_index_by_name_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField INDEX_NAME_FIELD_DESC = new TField("index_name", TType.STRING, (short)3);

    private String db_name;
    private String tbl_name;
    private String index_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      INDEX_NAME((short)3, "index_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // INDEX_NAME
            return INDEX_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.INDEX_NAME, new FieldMetaData("index_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_index_by_name_args.class, metaDataMap);
    }

    public get_index_by_name_args() {
    }

    public get_index_by_name_args(
      String db_name,
      String tbl_name,
      String index_name)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.index_name = index_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_index_by_name_args(get_index_by_name_args other) {
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      if (other.isSetIndex_name()) {
        this.index_name = other.index_name;
      }
    }

    public get_index_by_name_args deepCopy() {
      return new get_index_by_name_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.index_name = null;
    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public String getIndex_name() {
      return this.index_name;
    }

    public void setIndex_name(String index_name) {
      this.index_name = index_name;
    }

    public void unsetIndex_name() {
      this.index_name = null;
    }

    /** Returns true if field index_name is set (has been asigned a value) and false otherwise */
    public boolean isSetIndex_name() {
      return this.index_name != null;
    }

    public void setIndex_nameIsSet(boolean value) {
      if (!value) {
        this.index_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case INDEX_NAME:
        if (value == null) {
          unsetIndex_name();
        } else {
          setIndex_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case INDEX_NAME:
        return getIndex_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case INDEX_NAME:
        return isSetIndex_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_index_by_name_args)
        return this.equals((get_index_by_name_args)that);
      return false;
    }

    public boolean equals(get_index_by_name_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_index_name = true && this.isSetIndex_name();
      boolean that_present_index_name = true && that.isSetIndex_name();
      if (this_present_index_name || that_present_index_name) {
        if (!(this_present_index_name && that_present_index_name))
          return false;
        if (!this.index_name.equals(that.index_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_index_by_name_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_index_by_name_args typedOther = (get_index_by_name_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIndex_name()).compareTo(typedOther.isSetIndex_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIndex_name()) {
        lastComparison = TBaseHelper.compareTo(this.index_name, typedOther.index_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // INDEX_NAME
            if (field.type == TType.STRING) {
              this.index_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      if (this.index_name != null) {
        oprot.writeFieldBegin(INDEX_NAME_FIELD_DESC);
        oprot.writeString(this.index_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_index_by_name_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("index_name:");
      if (this.index_name == null) {
        sb.append("null");
      } else {
        sb.append(this.index_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_index_by_name_result implements TBase<get_index_by_name_result, get_index_by_name_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_index_by_name_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private Index success;
    private MetaException o1;
    private NoSuchObjectException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Index.class)));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_index_by_name_result.class, metaDataMap);
    }

    public get_index_by_name_result() {
    }

    public get_index_by_name_result(
      Index success,
      MetaException o1,
      NoSuchObjectException o2)
    {
      this();
      this.success = success;
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_index_by_name_result(get_index_by_name_result other) {
      if (other.isSetSuccess()) {
        this.success = new Index(other.success);
      }
      if (other.isSetO1()) {
        this.o1 = new MetaException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new NoSuchObjectException(other.o2);
      }
    }

    public get_index_by_name_result deepCopy() {
      return new get_index_by_name_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
      this.o2 = null;
    }

    public Index getSuccess() {
      return this.success;
    }

    public void setSuccess(Index success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO1() {
      return this.o1;
    }

    public void setO1(MetaException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public NoSuchObjectException getO2() {
      return this.o2;
    }

    public void setO2(NoSuchObjectException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Index)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((MetaException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((NoSuchObjectException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_index_by_name_result)
        return this.equals((get_index_by_name_result)that);
      return false;
    }

    public boolean equals(get_index_by_name_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_index_by_name_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_index_by_name_result typedOther = (get_index_by_name_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new Index();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new MetaException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new NoSuchObjectException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_index_by_name_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_indexes_args implements TBase<get_indexes_args, get_indexes_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_indexes_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField MAX_INDEXES_FIELD_DESC = new TField("max_indexes", TType.I16, (short)3);

    private String db_name;
    private String tbl_name;
    private short max_indexes;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      MAX_INDEXES((short)3, "max_indexes");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // MAX_INDEXES
            return MAX_INDEXES;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __MAX_INDEXES_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.MAX_INDEXES, new FieldMetaData("max_indexes", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_indexes_args.class, metaDataMap);
    }

    public get_indexes_args() {
      this.max_indexes = (short)-1;

    }

    public get_indexes_args(
      String db_name,
      String tbl_name,
      short max_indexes)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.max_indexes = max_indexes;
      setMax_indexesIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_indexes_args(get_indexes_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      this.max_indexes = other.max_indexes;
    }

    public get_indexes_args deepCopy() {
      return new get_indexes_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.max_indexes = (short)-1;

    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public short getMax_indexes() {
      return this.max_indexes;
    }

    public void setMax_indexes(short max_indexes) {
      this.max_indexes = max_indexes;
      setMax_indexesIsSet(true);
    }

    public void unsetMax_indexes() {
      __isset_bit_vector.clear(__MAX_INDEXES_ISSET_ID);
    }

    /** Returns true if field max_indexes is set (has been asigned a value) and false otherwise */
    public boolean isSetMax_indexes() {
      return __isset_bit_vector.get(__MAX_INDEXES_ISSET_ID);
    }

    public void setMax_indexesIsSet(boolean value) {
      __isset_bit_vector.set(__MAX_INDEXES_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case MAX_INDEXES:
        if (value == null) {
          unsetMax_indexes();
        } else {
          setMax_indexes((Short)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case MAX_INDEXES:
        return new Short(getMax_indexes());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case MAX_INDEXES:
        return isSetMax_indexes();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_indexes_args)
        return this.equals((get_indexes_args)that);
      return false;
    }

    public boolean equals(get_indexes_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_max_indexes = true;
      boolean that_present_max_indexes = true;
      if (this_present_max_indexes || that_present_max_indexes) {
        if (!(this_present_max_indexes && that_present_max_indexes))
          return false;
        if (this.max_indexes != that.max_indexes)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_indexes_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_indexes_args typedOther = (get_indexes_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMax_indexes()).compareTo(typedOther.isSetMax_indexes());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMax_indexes()) {
        lastComparison = TBaseHelper.compareTo(this.max_indexes, typedOther.max_indexes);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // MAX_INDEXES
            if (field.type == TType.I16) {
              this.max_indexes = iprot.readI16();
              setMax_indexesIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(MAX_INDEXES_FIELD_DESC);
      oprot.writeI16(this.max_indexes);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_indexes_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("max_indexes:");
      sb.append(this.max_indexes);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_indexes_result implements TBase<get_indexes_result, get_indexes_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_indexes_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField O1_FIELD_DESC = new TField("o1", TType.STRUCT, (short)1);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)2);

    private List<Index> success;
    private NoSuchObjectException o1;
    private MetaException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O1((short)1, "o1"),
      O2((short)2, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O1
            return O1;
          case 2: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Index.class))));
      tmpMap.put(_Fields.O1, new FieldMetaData("o1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_indexes_result.class, metaDataMap);
    }

    public get_indexes_result() {
    }

    public get_indexes_result(
      List<Index> success,
      NoSuchObjectException o1,
      MetaException o2)
    {
      this();
      this.success = success;
      this.o1 = o1;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_indexes_result(get_indexes_result other) {
      if (other.isSetSuccess()) {
        List<Index> __this__success = new ArrayList<Index>();
        for (Index other_element : other.success) {
          __this__success.add(new Index(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetO1()) {
        this.o1 = new NoSuchObjectException(other.o1);
      }
      if (other.isSetO2()) {
        this.o2 = new MetaException(other.o2);
      }
    }

    public get_indexes_result deepCopy() {
      return new get_indexes_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o1 = null;
      this.o2 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Index> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Index elem) {
      if (this.success == null) {
        this.success = new ArrayList<Index>();
      }
      this.success.add(elem);
    }

    public List<Index> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<Index> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public NoSuchObjectException getO1() {
      return this.o1;
    }

    public void setO1(NoSuchObjectException o1) {
      this.o1 = o1;
    }

    public void unsetO1() {
      this.o1 = null;
    }

    /** Returns true if field o1 is set (has been asigned a value) and false otherwise */
    public boolean isSetO1() {
      return this.o1 != null;
    }

    public void setO1IsSet(boolean value) {
      if (!value) {
        this.o1 = null;
      }
    }

    public MetaException getO2() {
      return this.o2;
    }

    public void setO2(MetaException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Index>)value);
        }
        break;

      case O1:
        if (value == null) {
          unsetO1();
        } else {
          setO1((NoSuchObjectException)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O1:
        return getO1();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O1:
        return isSetO1();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_indexes_result)
        return this.equals((get_indexes_result)that);
      return false;
    }

    public boolean equals(get_indexes_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o1 = true && this.isSetO1();
      boolean that_present_o1 = true && that.isSetO1();
      if (this_present_o1 || that_present_o1) {
        if (!(this_present_o1 && that_present_o1))
          return false;
        if (!this.o1.equals(that.o1))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_indexes_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_indexes_result typedOther = (get_indexes_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO1()).compareTo(typedOther.isSetO1());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO1()) {
        lastComparison = TBaseHelper.compareTo(this.o1, typedOther.o1);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list141 = iprot.readListBegin();
                this.success = new ArrayList<Index>(_list141.size);
                for (int _i142 = 0; _i142 < _list141.size; ++_i142)
                {
                  Index _elem143;
                  _elem143 = new Index();
                  _elem143.read(iprot);
                  this.success.add(_elem143);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O1
            if (field.type == TType.STRUCT) {
              this.o1 = new NoSuchObjectException();
              this.o1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new MetaException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Index _iter144 : this.success)
          {
            _iter144.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO1()) {
        oprot.writeFieldBegin(O1_FIELD_DESC);
        this.o1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_indexes_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o1:");
      if (this.o1 == null) {
        sb.append("null");
      } else {
        sb.append(this.o1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_index_names_args implements TBase<get_index_names_args, get_index_names_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_index_names_args");

    private static final TField DB_NAME_FIELD_DESC = new TField("db_name", TType.STRING, (short)1);
    private static final TField TBL_NAME_FIELD_DESC = new TField("tbl_name", TType.STRING, (short)2);
    private static final TField MAX_INDEXES_FIELD_DESC = new TField("max_indexes", TType.I16, (short)3);

    private String db_name;
    private String tbl_name;
    private short max_indexes;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DB_NAME((short)1, "db_name"),
      TBL_NAME((short)2, "tbl_name"),
      MAX_INDEXES((short)3, "max_indexes");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DB_NAME
            return DB_NAME;
          case 2: // TBL_NAME
            return TBL_NAME;
          case 3: // MAX_INDEXES
            return MAX_INDEXES;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __MAX_INDEXES_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DB_NAME, new FieldMetaData("db_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TBL_NAME, new FieldMetaData("tbl_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.MAX_INDEXES, new FieldMetaData("max_indexes", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_index_names_args.class, metaDataMap);
    }

    public get_index_names_args() {
      this.max_indexes = (short)-1;

    }

    public get_index_names_args(
      String db_name,
      String tbl_name,
      short max_indexes)
    {
      this();
      this.db_name = db_name;
      this.tbl_name = tbl_name;
      this.max_indexes = max_indexes;
      setMax_indexesIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_index_names_args(get_index_names_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetDb_name()) {
        this.db_name = other.db_name;
      }
      if (other.isSetTbl_name()) {
        this.tbl_name = other.tbl_name;
      }
      this.max_indexes = other.max_indexes;
    }

    public get_index_names_args deepCopy() {
      return new get_index_names_args(this);
    }

    @Override
    public void clear() {
      this.db_name = null;
      this.tbl_name = null;
      this.max_indexes = (short)-1;

    }

    public String getDb_name() {
      return this.db_name;
    }

    public void setDb_name(String db_name) {
      this.db_name = db_name;
    }

    public void unsetDb_name() {
      this.db_name = null;
    }

    /** Returns true if field db_name is set (has been asigned a value) and false otherwise */
    public boolean isSetDb_name() {
      return this.db_name != null;
    }

    public void setDb_nameIsSet(boolean value) {
      if (!value) {
        this.db_name = null;
      }
    }

    public String getTbl_name() {
      return this.tbl_name;
    }

    public void setTbl_name(String tbl_name) {
      this.tbl_name = tbl_name;
    }

    public void unsetTbl_name() {
      this.tbl_name = null;
    }

    /** Returns true if field tbl_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTbl_name() {
      return this.tbl_name != null;
    }

    public void setTbl_nameIsSet(boolean value) {
      if (!value) {
        this.tbl_name = null;
      }
    }

    public short getMax_indexes() {
      return this.max_indexes;
    }

    public void setMax_indexes(short max_indexes) {
      this.max_indexes = max_indexes;
      setMax_indexesIsSet(true);
    }

    public void unsetMax_indexes() {
      __isset_bit_vector.clear(__MAX_INDEXES_ISSET_ID);
    }

    /** Returns true if field max_indexes is set (has been asigned a value) and false otherwise */
    public boolean isSetMax_indexes() {
      return __isset_bit_vector.get(__MAX_INDEXES_ISSET_ID);
    }

    public void setMax_indexesIsSet(boolean value) {
      __isset_bit_vector.set(__MAX_INDEXES_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DB_NAME:
        if (value == null) {
          unsetDb_name();
        } else {
          setDb_name((String)value);
        }
        break;

      case TBL_NAME:
        if (value == null) {
          unsetTbl_name();
        } else {
          setTbl_name((String)value);
        }
        break;

      case MAX_INDEXES:
        if (value == null) {
          unsetMax_indexes();
        } else {
          setMax_indexes((Short)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DB_NAME:
        return getDb_name();

      case TBL_NAME:
        return getTbl_name();

      case MAX_INDEXES:
        return new Short(getMax_indexes());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DB_NAME:
        return isSetDb_name();
      case TBL_NAME:
        return isSetTbl_name();
      case MAX_INDEXES:
        return isSetMax_indexes();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_index_names_args)
        return this.equals((get_index_names_args)that);
      return false;
    }

    public boolean equals(get_index_names_args that) {
      if (that == null)
        return false;

      boolean this_present_db_name = true && this.isSetDb_name();
      boolean that_present_db_name = true && that.isSetDb_name();
      if (this_present_db_name || that_present_db_name) {
        if (!(this_present_db_name && that_present_db_name))
          return false;
        if (!this.db_name.equals(that.db_name))
          return false;
      }

      boolean this_present_tbl_name = true && this.isSetTbl_name();
      boolean that_present_tbl_name = true && that.isSetTbl_name();
      if (this_present_tbl_name || that_present_tbl_name) {
        if (!(this_present_tbl_name && that_present_tbl_name))
          return false;
        if (!this.tbl_name.equals(that.tbl_name))
          return false;
      }

      boolean this_present_max_indexes = true;
      boolean that_present_max_indexes = true;
      if (this_present_max_indexes || that_present_max_indexes) {
        if (!(this_present_max_indexes && that_present_max_indexes))
          return false;
        if (this.max_indexes != that.max_indexes)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_index_names_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_index_names_args typedOther = (get_index_names_args)other;

      lastComparison = Boolean.valueOf(isSetDb_name()).compareTo(typedOther.isSetDb_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDb_name()) {
        lastComparison = TBaseHelper.compareTo(this.db_name, typedOther.db_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTbl_name()).compareTo(typedOther.isSetTbl_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTbl_name()) {
        lastComparison = TBaseHelper.compareTo(this.tbl_name, typedOther.tbl_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMax_indexes()).compareTo(typedOther.isSetMax_indexes());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMax_indexes()) {
        lastComparison = TBaseHelper.compareTo(this.max_indexes, typedOther.max_indexes);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DB_NAME
            if (field.type == TType.STRING) {
              this.db_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TBL_NAME
            if (field.type == TType.STRING) {
              this.tbl_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // MAX_INDEXES
            if (field.type == TType.I16) {
              this.max_indexes = iprot.readI16();
              setMax_indexesIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.db_name != null) {
        oprot.writeFieldBegin(DB_NAME_FIELD_DESC);
        oprot.writeString(this.db_name);
        oprot.writeFieldEnd();
      }
      if (this.tbl_name != null) {
        oprot.writeFieldBegin(TBL_NAME_FIELD_DESC);
        oprot.writeString(this.tbl_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(MAX_INDEXES_FIELD_DESC);
      oprot.writeI16(this.max_indexes);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_index_names_args(");
      boolean first = true;

      sb.append("db_name:");
      if (this.db_name == null) {
        sb.append("null");
      } else {
        sb.append(this.db_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tbl_name:");
      if (this.tbl_name == null) {
        sb.append("null");
      } else {
        sb.append(this.tbl_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("max_indexes:");
      sb.append(this.max_indexes);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_index_names_result implements TBase<get_index_names_result, get_index_names_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_index_names_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField O2_FIELD_DESC = new TField("o2", TType.STRUCT, (short)1);

    private List<String> success;
    private MetaException o2;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      O2((short)1, "o2");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // O2
            return O2;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.O2, new FieldMetaData("o2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_index_names_result.class, metaDataMap);
    }

    public get_index_names_result() {
    }

    public get_index_names_result(
      List<String> success,
      MetaException o2)
    {
      this();
      this.success = success;
      this.o2 = o2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_index_names_result(get_index_names_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetO2()) {
        this.o2 = new MetaException(other.o2);
      }
    }

    public get_index_names_result deepCopy() {
      return new get_index_names_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.o2 = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<String> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public MetaException getO2() {
      return this.o2;
    }

    public void setO2(MetaException o2) {
      this.o2 = o2;
    }

    public void unsetO2() {
      this.o2 = null;
    }

    /** Returns true if field o2 is set (has been asigned a value) and false otherwise */
    public boolean isSetO2() {
      return this.o2 != null;
    }

    public void setO2IsSet(boolean value) {
      if (!value) {
        this.o2 = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case O2:
        if (value == null) {
          unsetO2();
        } else {
          setO2((MetaException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case O2:
        return getO2();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case O2:
        return isSetO2();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_index_names_result)
        return this.equals((get_index_names_result)that);
      return false;
    }

    public boolean equals(get_index_names_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_o2 = true && this.isSetO2();
      boolean that_present_o2 = true && that.isSetO2();
      if (this_present_o2 || that_present_o2) {
        if (!(this_present_o2 && that_present_o2))
          return false;
        if (!this.o2.equals(that.o2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_index_names_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_index_names_result typedOther = (get_index_names_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetO2()).compareTo(typedOther.isSetO2());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetO2()) {
        lastComparison = TBaseHelper.compareTo(this.o2, typedOther.o2);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list145 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list145.size);
                for (int _i146 = 0; _i146 < _list145.size; ++_i146)
                {
                  String _elem147;
                  _elem147 = iprot.readString();
                  this.success.add(_elem147);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // O2
            if (field.type == TType.STRUCT) {
              this.o2 = new MetaException();
              this.o2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter148 : this.success)
          {
            oprot.writeString(_iter148);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetO2()) {
        oprot.writeFieldBegin(O2_FIELD_DESC);
        this.o2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_index_names_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("o2:");
      if (this.o2 == null) {
        sb.append("null");
      } else {
        sb.append(this.o2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
